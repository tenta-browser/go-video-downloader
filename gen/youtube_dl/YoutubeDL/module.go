// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * YoutubeDL/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/YoutubeDL.py
 */

package YoutubeDL

import (
	Ωcollections "github.com/tenta-browser/go-video-downloader/gen/collections"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωrandom "github.com/tenta-browser/go-video-downloader/gen/random"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωsocket "github.com/tenta-browser/go-video-downloader/gen/socket"
	Ωstring "github.com/tenta-browser/go-video-downloader/gen/string"
	Ωsys "github.com/tenta-browser/go-video-downloader/gen/sys"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωerror "github.com/tenta-browser/go-video-downloader/gen/urllib/error"
	Ωcache "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/cache"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωextractor "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor"
	Ωopenload "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/openload"
	Ωpostprocessor "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/postprocessor"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	Cache                  λ.Object
	DEFAULT_OUTTMPL        λ.Object
	DownloadError          λ.Object
	ExtractorError         λ.Object
	FFmpegPostProcessor    λ.Object
	GeoRestrictedError     λ.Object
	MaxDownloadsReached    λ.Object
	PagedList              λ.Object
	PhantomJSwrapper       λ.Object
	PostProcessingError    λ.Object
	UnavailableVideoError  λ.Object
	YoutubeDL              λ.Object
	ϒage_restricted        λ.Object
	ϒascii_letters         λ.Object
	ϒcompat_basestring     λ.Object
	ϒcompat_http_client    λ.Object
	ϒcompat_kwargs         λ.Object
	ϒcompat_numeric_types  λ.Object
	ϒcompat_str            λ.Object
	ϒdetermine_ext         λ.Object
	ϒdetermine_protocol    λ.Object
	ϒerror_to_compat_str   λ.Object
	ϒexpand_path           λ.Object
	ϒgen_extractor_classes λ.Object
	ϒget_info_extractor    λ.Object
	ϒint_or_none           λ.Object
	ϒparse_filesize        λ.Object
	ϒpreferredencoding     λ.Object
	ϒsanitize_filename     λ.Object
	ϒsanitize_path         λ.Object
	ϒsanitize_url          λ.Object
	ϒsanitized_Request     λ.Object
	ϒstd_headers           λ.Object
	ϒstr_or_none           λ.Object
	ϒurl_basename          λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒascii_letters = Ωstring.ϒascii_letters
		ϒcompat_basestring = Ωcompat.ϒcompat_basestring
		ϒcompat_http_client = Ωcompat.ϒcompat_http_client
		ϒcompat_kwargs = Ωcompat.ϒcompat_kwargs
		ϒcompat_numeric_types = Ωcompat.ϒcompat_numeric_types
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒage_restricted = Ωutils.ϒage_restricted
		DEFAULT_OUTTMPL = Ωutils.DEFAULT_OUTTMPL
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒdetermine_protocol = Ωutils.ϒdetermine_protocol
		DownloadError = Ωutils.DownloadError
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ϒexpand_path = Ωutils.ϒexpand_path
		ExtractorError = Ωutils.ExtractorError
		GeoRestrictedError = Ωutils.GeoRestrictedError
		ϒint_or_none = Ωutils.ϒint_or_none
		MaxDownloadsReached = Ωutils.MaxDownloadsReached
		PagedList = Ωutils.PagedList
		ϒparse_filesize = Ωutils.ϒparse_filesize
		PostProcessingError = Ωutils.PostProcessingError
		ϒpreferredencoding = Ωutils.ϒpreferredencoding
		ϒsanitize_filename = Ωutils.ϒsanitize_filename
		ϒsanitize_path = Ωutils.ϒsanitize_path
		ϒsanitize_url = Ωutils.ϒsanitize_url
		ϒsanitized_Request = Ωutils.ϒsanitized_Request
		ϒstd_headers = Ωutils.ϒstd_headers
		ϒstr_or_none = Ωutils.ϒstr_or_none
		UnavailableVideoError = Ωutils.UnavailableVideoError
		ϒurl_basename = Ωutils.ϒurl_basename
		Cache = Ωcache.Cache
		ϒget_info_extractor = Ωextractor.ϒget_info_extractor
		ϒgen_extractor_classes = Ωextractor.ϒgen_extractor_classes
		PhantomJSwrapper = Ωopenload.PhantomJSwrapper
		FFmpegPostProcessor = Ωpostprocessor.FFmpegPostProcessor
		if λ.IsTrue(λ.Eq(λ.None, λ.StrLiteral("nt"))) {

		}
		YoutubeDL = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeDL"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				YoutubeDL__NUMERIC_FIELDS                λ.Object
				YoutubeDL___extract_info                 λ.Object
				YoutubeDL___forced_printings             λ.Object
				YoutubeDL___handle_extraction_exceptions λ.Object
				YoutubeDL__bidi_workaround               λ.Object
				YoutubeDL__calc_cookies                  λ.Object
				YoutubeDL__calc_headers                  λ.Object
				YoutubeDL__default_format_spec           λ.Object
				YoutubeDL__ies                           λ.Object
				YoutubeDL__num_downloads                 λ.Object
				YoutubeDL__screen_file                   λ.Object
				YoutubeDL_add_default_extra_info         λ.Object
				YoutubeDL_add_default_info_extractors    λ.Object
				YoutubeDL_add_extra_info                 λ.Object
				YoutubeDL_add_info_extractor             λ.Object
				YoutubeDL_extract_info                   λ.Object
				YoutubeDL_format_resolution              λ.Object
				YoutubeDL_get_info_extractor             λ.Object
				YoutubeDL_params                         λ.Object
				YoutubeDL_prepare_filename               λ.Object
				YoutubeDL_process_ie_result              λ.Object
				YoutubeDL_process_info                   λ.Object
				YoutubeDL_process_subtitles              λ.Object
				YoutubeDL_process_video_result           λ.Object
				YoutubeDL_report_error                   λ.Object
				YoutubeDL_report_warning                 λ.Object
				YoutubeDL_to_screen                      λ.Object
				YoutubeDL_to_stderr                      λ.Object
				YoutubeDL_to_stdout                      λ.Object
				YoutubeDL_trouble                        λ.Object
			)
			YoutubeDL__NUMERIC_FIELDS = λ.Cal(λ.SetType, λ.NewTuple(
				λ.StrLiteral("width"),
				λ.StrLiteral("height"),
				λ.StrLiteral("tbr"),
				λ.StrLiteral("abr"),
				λ.StrLiteral("asr"),
				λ.StrLiteral("vbr"),
				λ.StrLiteral("fps"),
				λ.StrLiteral("filesize"),
				λ.StrLiteral("filesize_approx"),
				λ.StrLiteral("timestamp"),
				λ.StrLiteral("upload_year"),
				λ.StrLiteral("upload_month"),
				λ.StrLiteral("upload_day"),
				λ.StrLiteral("duration"),
				λ.StrLiteral("view_count"),
				λ.StrLiteral("like_count"),
				λ.StrLiteral("dislike_count"),
				λ.StrLiteral("repost_count"),
				λ.StrLiteral("average_rating"),
				λ.StrLiteral("comment_count"),
				λ.StrLiteral("age_limit"),
				λ.StrLiteral("start_time"),
				λ.StrLiteral("end_time"),
				λ.StrLiteral("chapter_number"),
				λ.StrLiteral("season_number"),
				λ.StrLiteral("episode_number"),
				λ.StrLiteral("track_number"),
				λ.StrLiteral("disc_number"),
				λ.StrLiteral("release_year"),
				λ.StrLiteral("playlist_index"),
			))
			YoutubeDL_params = λ.None
			YoutubeDL__ies = λ.NewList()
			YoutubeDL__num_downloads = λ.None
			YoutubeDL__screen_file = λ.None
			YoutubeDL_add_info_extractor = λ.NewFunction("add_info_extractor",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie   = λargs[1]
						ϒself = λargs[0]
					)
					λ.Calm(λ.GetAttr(ϒself, "_ies", nil), "append", ϒie)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie, λ.TypeType)) {
						λ.SetItem(λ.GetAttr(ϒself, "_ies_instances", nil), λ.Calm(ϒie, "ie_key"), ϒie)
						λ.Calm(ϒie, "set_downloader", ϒself)
					}
					return λ.None
				})
			YoutubeDL_get_info_extractor = λ.NewFunction("get_info_extractor",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_key"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie     λ.Object
						ϒie_key = λargs[1]
						ϒself   = λargs[0]
					)
					ϒie = λ.Calm(λ.GetAttr(ϒself, "_ies_instances", nil), "get", ϒie_key)
					if ϒie == λ.None {
						ϒie = λ.Cal(λ.Cal(ϒget_info_extractor, ϒie_key))
						λ.Calm(ϒself, "add_info_extractor", ϒie)
					}
					return ϒie
				})
			YoutubeDL_add_default_info_extractors = λ.NewFunction("add_default_info_extractors",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie   λ.Object
						ϒself = λargs[0]
						τmp0  λ.Object
						τmp1  λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(ϒgen_extractor_classes))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒie = τmp1
						λ.Calm(ϒself, "add_info_extractor", ϒie)
					}
					return λ.None
				})
			YoutubeDL__bidi_workaround = λ.NewFunction("_bidi_workaround",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒline_count λ.Object
						ϒmessage    = λargs[1]
						ϒres        λ.Object
						ϒself       = λargs[0]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, ϒself, λ.StrLiteral("_output_channel"))) {
						return ϒmessage
					}
					if !λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, ϒself, λ.StrLiteral("_output_process"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒmessage, ϒcompat_str)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒline_count = λ.Add(λ.Calm(ϒmessage, "count", λ.StrLiteral("\n")), λ.IntLiteral(1))
					λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_output_process", nil), "stdin", nil), "write", λ.Calm(λ.Add(ϒmessage, λ.StrLiteral("\n")), "encode", λ.StrLiteral("utf-8")))
					λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_output_process", nil), "stdin", nil), "flush")
					ϒres = λ.Calm(λ.StrLiteral(""), "join", λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, ϒline_count))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									_ = τmp1
									λgy.Yield(λ.Calm(λ.Calm(λ.GetAttr(ϒself, "_output_channel", nil), "readline"), "decode", λ.StrLiteral("utf-8")))
								}
								return λ.None
							})
						})))
					return λ.GetItem(ϒres, λ.NewSlice(λ.None, λ.Neg(λ.Cal(λ.BuiltinLen, λ.StrLiteral("\n"))), λ.None))
				})
			YoutubeDL_to_screen = λ.NewFunction("to_screen",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "skip_eol", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmessage  = λargs[1]
						ϒself     = λargs[0]
						ϒskip_eol = λargs[2]
					)
					return λ.Call(λ.GetAttr(ϒself, "to_stdout", nil), λ.NewArgs(
						ϒmessage,
						ϒskip_eol,
					), λ.KWArgs{
						{Name: "check_quiet", Value: λ.True},
					})
				})
			YoutubeDL_to_stdout = λ.NewFunction("to_stdout",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "skip_eol", Def: λ.False},
					{Name: "check_quiet", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcheck_quiet = λargs[3]
						ϒmessage     = λargs[1]
						ϒoutput      λ.Object
						ϒself        = λargs[0]
						ϒskip_eol    = λargs[2]
						ϒterminator  λ.Object
					)
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("logger"))) {
						λ.Calm(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.StrLiteral("logger")), "debug", ϒmessage)
					} else {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒcheck_quiet)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("quiet"), λ.False)))
							}
						}()) {
							ϒmessage = λ.Calm(ϒself, "_bidi_workaround", ϒmessage)
							ϒterminator = λ.GetItem(λ.NewList(
								λ.StrLiteral("\n"),
								λ.StrLiteral(""),
							), ϒskip_eol)
							ϒoutput = λ.Add(ϒmessage, ϒterminator)
							λ.Calm(ϒself, "_write_string", ϒoutput, λ.GetAttr(ϒself, "_screen_file", nil))
						}
					}
					return λ.None
				})
			YoutubeDL_to_stderr = λ.NewFunction("to_stderr",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmessage = λargs[1]
						ϒoutput  λ.Object
						ϒself    = λargs[0]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒmessage, ϒcompat_str)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("logger"))) {
						λ.Calm(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.StrLiteral("logger")), "error", ϒmessage)
					} else {
						ϒmessage = λ.Calm(ϒself, "_bidi_workaround", ϒmessage)
						ϒoutput = λ.Add(ϒmessage, λ.StrLiteral("\n"))
						λ.Calm(ϒself, "_write_string", ϒoutput, λ.GetAttr(ϒself, "_err_file", nil))
					}
					return λ.None
				})
			YoutubeDL_trouble = λ.NewFunction("trouble",
				[]λ.Param{
					{Name: "self"},
					{Name: "message", Def: λ.None},
					{Name: "tb", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒexc_info λ.Object
						ϒmessage  = λargs[1]
						ϒself     = λargs[0]
						ϒtb       = λargs[2]
						ϒtb_data  λ.Object
						τmp0      λ.Object
					)
					if ϒmessage != λ.None {
						λ.Calm(ϒself, "to_stderr", ϒmessage)
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("verbose"))) {
						if ϒtb == λ.None {
							if λ.IsTrue(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(0))) {
								ϒtb = λ.StrLiteral("")
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinHasAttr, λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), λ.StrLiteral("exc_info")); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.GetItem(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), "exc_info", nil), λ.IntLiteral(0))
									}
								}()) {
									τmp0 = λ.IAdd(ϒtb, λ.Calm(λ.StrLiteral(""), "join", λ.Calm(λ.None, "format_exception", λ.Unpack(λ.AsStarred(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), "exc_info", nil)))...)))
									ϒtb = τmp0
								}
								τmp0 = λ.IAdd(ϒtb, λ.Cal(λ.None, λ.Calm(λ.None, "format_exc")))
								ϒtb = τmp0
							} else {
								ϒtb_data = λ.Calm(λ.None, "format_list", λ.Calm(λ.None, "extract_stack"))
								ϒtb = λ.Calm(λ.StrLiteral(""), "join", ϒtb_data)
							}
						}
						λ.Calm(ϒself, "to_stderr", ϒtb)
					}
					if !λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("ignoreerrors"), λ.False)) {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(0)); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Cal(λ.BuiltinHasAttr, λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), λ.StrLiteral("exc_info")); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), "exc_info", nil), λ.IntLiteral(0))
							}
						}()) {
							ϒexc_info = λ.GetAttr(λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(1)), "exc_info", nil)
						} else {
							ϒexc_info = λ.Cal(Ωsys.ϒexc_info)
						}
						panic(λ.Raise(λ.Cal(DownloadError, ϒmessage, ϒexc_info)))
					}
					λ.SetAttr(ϒself, "_download_retcode", λ.IntLiteral(1))
					return λ.None
				})
			YoutubeDL_report_warning = λ.NewFunction("report_warning",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_msg_header     λ.Object
						ϒmessage         = λargs[1]
						ϒself            = λargs[0]
						ϒwarning_message λ.Object
					)
					if λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("logger")) != λ.None {
						λ.Calm(λ.GetItem(λ.GetAttr(ϒself, "params", nil), λ.StrLiteral("logger")), "warning", ϒmessage)
					} else {
						if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("no_warnings"))) {
							return λ.None
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("no_color")))); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Calm(λ.GetAttr(ϒself, "_err_file", nil), "isatty"); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Ne(λ.None, λ.StrLiteral("nt"))
							}
						}()) {
							ϒ_msg_header = λ.StrLiteral("[0;33mWARNING:[0m")
						} else {
							ϒ_msg_header = λ.StrLiteral("WARNING:")
						}
						ϒwarning_message = λ.Mod(λ.StrLiteral("%s %s"), λ.NewTuple(
							ϒ_msg_header,
							ϒmessage,
						))
						λ.Calm(ϒself, "to_stderr", ϒwarning_message)
					}
					return λ.None
				})
			YoutubeDL_report_error = λ.NewFunction("report_error",
				[]λ.Param{
					{Name: "self"},
					{Name: "message"},
					{Name: "tb", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_msg_header   λ.Object
						ϒerror_message λ.Object
						ϒmessage       = λargs[1]
						ϒself          = λargs[0]
						ϒtb            = λargs[2]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("no_color")))); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Calm(λ.GetAttr(ϒself, "_err_file", nil), "isatty"); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Ne(λ.None, λ.StrLiteral("nt"))
						}
					}()) {
						ϒ_msg_header = λ.StrLiteral("[0;31mERROR:[0m")
					} else {
						ϒ_msg_header = λ.StrLiteral("ERROR:")
					}
					ϒerror_message = λ.Mod(λ.StrLiteral("%s %s"), λ.NewTuple(
						ϒ_msg_header,
						ϒmessage,
					))
					λ.Calm(ϒself, "trouble", ϒerror_message, ϒtb)
					return λ.None
				})
			YoutubeDL_prepare_filename = λ.NewFunction("prepare_filename",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						FIELD_SIZE_COMPAT_RE   λ.Object
						FORMAT_RE              λ.Object
						ϒautonumber_size       λ.Object
						ϒfield_size_compat_map λ.Object
						ϒfilename              λ.Object
						ϒinfo_dict             = λargs[1]
						ϒmobj                  λ.Object
						ϒnumeric_field         λ.Object
						ϒouttmpl               λ.Object
						ϒsanitize              λ.Object
						ϒself                  = λargs[0]
						ϒsep                   λ.Object
						ϒtemplate_dict         λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
						τmp3                   λ.Object
					)
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
								var ϒerr λ.Object = λex
								λ.Calm(ϒself, "report_error", λ.Add(λ.Add(λ.Add(λ.Add(λ.StrLiteral("Error in output template: "), λ.Cal(λ.StrType, ϒerr)), λ.StrLiteral(" (encoding: ")), λ.Cal(λ.BuiltinRepr, λ.Cal(ϒpreferredencoding))), λ.StrLiteral(")")))
								λexit, λret = λ.BlockExitReturn, λ.None
								return
							}},
						)
						ϒtemplate_dict = λ.Cal(λ.DictType, ϒinfo_dict)
						λ.SetItem(ϒtemplate_dict, λ.StrLiteral("epoch"), λ.Cal(λ.IntType, λ.Cal(Ωtime.ϒtime)))
						ϒautonumber_size = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("autonumber_size"))
						if ϒautonumber_size == λ.None {
							ϒautonumber_size = λ.IntLiteral(5)
						}
						λ.SetItem(ϒtemplate_dict, λ.StrLiteral("autonumber"), λ.Add(λ.Sub(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("autonumber_start"), λ.IntLiteral(1)), λ.IntLiteral(1)), λ.GetAttr(ϒself, "_num_downloads", nil)))
						if λ.Calm(ϒtemplate_dict, "get", λ.StrLiteral("resolution")) == λ.None {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(ϒtemplate_dict, "get", λ.StrLiteral("width")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒtemplate_dict, "get", λ.StrLiteral("height"))
								}
							}()) {
								λ.SetItem(ϒtemplate_dict, λ.StrLiteral("resolution"), λ.Mod(λ.StrLiteral("%dx%d"), λ.NewTuple(
									λ.GetItem(ϒtemplate_dict, λ.StrLiteral("width")),
									λ.GetItem(ϒtemplate_dict, λ.StrLiteral("height")),
								)))
							} else {
								if λ.IsTrue(λ.Calm(ϒtemplate_dict, "get", λ.StrLiteral("height"))) {
									λ.SetItem(ϒtemplate_dict, λ.StrLiteral("resolution"), λ.Mod(λ.StrLiteral("%sp"), λ.GetItem(ϒtemplate_dict, λ.StrLiteral("height"))))
								} else {
									if λ.IsTrue(λ.Calm(ϒtemplate_dict, "get", λ.StrLiteral("width"))) {
										λ.SetItem(ϒtemplate_dict, λ.StrLiteral("resolution"), λ.Mod(λ.StrLiteral("%dx?"), λ.GetItem(ϒtemplate_dict, λ.StrLiteral("width"))))
									}
								}
							}
						}
						ϒsanitize = λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "k"},
								{Name: "v"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒk = λargs[0]
									ϒv = λargs[1]
								)
								return λ.Call(ϒsanitize_filename, λ.NewArgs(λ.Cal(ϒcompat_str, ϒv)), λ.KWArgs{
									{Name: "restricted", Value: λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("restrictfilenames"))},
									{Name: "is_id", Value: func() λ.Object {
										if λv := λ.Eq(ϒk, λ.StrLiteral("id")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(ϒk, "endswith", λ.StrLiteral("_id"))
										}
									}()},
								})
							})
						ϒtemplate_dict = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒk   λ.Object
										ϒv   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
										τmp2 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒtemplate_dict, "items"))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										τmp2 = τmp1
										ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
										ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
										if λ.IsTrue(func() λ.Object {
											if λv := λ.NewBool(ϒv != λ.None); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒv, λ.NewTuple(
													λ.ListType,
													λ.TupleType,
													λ.DictType,
												))))
											}
										}()) {
											λgy.Yield(λ.NewTuple(
												ϒk,
												func() λ.Object {
													if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒv, ϒcompat_numeric_types)) {
														return ϒv
													} else {
														return λ.Cal(ϒsanitize, ϒk, ϒv)
													}
												}(),
											))
										}
									}
									return λ.None
								})
							})))
						ϒtemplate_dict = λ.Cal(Ωcollections.ϒdefaultdict, λ.NewFunction("<lambda>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("outtmpl_na_placeholder"), λ.StrLiteral("NA"))
							}), ϒtemplate_dict)
						ϒouttmpl = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("outtmpl"), DEFAULT_OUTTMPL)
						ϒfield_size_compat_map = λ.DictLiteral(map[string]λ.Object{
							"playlist_index": λ.Cal(λ.BuiltinLen, λ.Cal(λ.StrType, λ.GetItem(ϒtemplate_dict, λ.StrLiteral("n_entries")))),
							"autonumber":     ϒautonumber_size,
						})
						FIELD_SIZE_COMPAT_RE = λ.StrLiteral("(?<!%)%\\((?P<field>autonumber|playlist_index)\\)s")
						ϒmobj = λ.Cal(Ωre.ϒsearch, FIELD_SIZE_COMPAT_RE, ϒouttmpl)
						if λ.IsTrue(ϒmobj) {
							ϒouttmpl = λ.Cal(Ωre.ϒsub, FIELD_SIZE_COMPAT_RE, λ.Mod(λ.StrLiteral("%%(\\1)0%dd"), λ.GetItem(ϒfield_size_compat_map, λ.Calm(ϒmobj, "group", λ.StrLiteral("field")))), ϒouttmpl)
						}
						τmp2 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_NUMERIC_FIELDS", nil))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒnumeric_field = τmp3
							if !λ.Contains(ϒtemplate_dict, ϒnumeric_field) {
								FORMAT_RE = λ.StrLiteral("(?x)\n                        (?<!%)\n                        %\n                        \\({0}\\)  # mapping key\n                        (?:[#0\\-+ ]+)?  # conversion flags (optional)\n                        (?:\\d+)?  # minimum field width (optional)\n                        (?:\\.\\d+)?  # precision (optional)\n                        [hlL]?  # length modifier (optional)\n                        [diouxXeEfFgGcrs%]  # conversion type\n                    ")
								ϒouttmpl = λ.Cal(Ωre.ϒsub, λ.Calm(FORMAT_RE, "format", ϒnumeric_field), λ.Calm(λ.StrLiteral("%({0})s"), "format", ϒnumeric_field), ϒouttmpl)
							}
						}
						ϒsep = λ.Calm(λ.StrLiteral(""), "join", λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.IntLiteral(32)))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										_ = τmp1
										λgy.Yield(λ.Cal(Ωrandom.ϒchoice, ϒascii_letters))
									}
									return λ.None
								})
							}))))
						ϒouttmpl = λ.Calm(λ.Calm(ϒouttmpl, "replace", λ.StrLiteral("%%"), λ.Calm(λ.StrLiteral("%{0}%"), "format", ϒsep)), "replace", λ.StrLiteral("$$"), λ.Calm(λ.StrLiteral("${0}$"), "format", ϒsep))
						ϒfilename = λ.Mod(λ.Calm(λ.Cal(ϒexpand_path, ϒouttmpl), "replace", ϒsep, λ.StrLiteral("")), ϒtemplate_dict)
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Lt(Ωsys.ϒversion_info, λ.NewTuple(
								λ.IntLiteral(3),
								λ.IntLiteral(0),
							)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(Ωsys.ϒplatform, λ.StrLiteral("win32"))
							}
						}()) {
							ϒfilename = λ.Calm(λ.Cal(λ.None, ϒfilename, λ.True), "decode", λ.Cal(ϒpreferredencoding))
						}
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒsanitize_path, ϒfilename)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			YoutubeDL_add_extra_info = λ.NewFunction("add_extra_info",
				[]λ.Param{
					{Name: "info_dict"},
					{Name: "extra_info"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒextra_info = λargs[1]
						ϒinfo_dict  = λargs[0]
						ϒkey        λ.Object
						ϒvalue      λ.Object
						τmp0        λ.Object
						τmp1        λ.Object
						τmp2        λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒextra_info, "items"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒkey = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒvalue = λ.GetItem(τmp2, λ.IntLiteral(1))
						λ.Calm(ϒinfo_dict, "setdefault", ϒkey, ϒvalue)
					}
					return λ.None
				})
			YoutubeDL_add_extra_info = λ.Cal(λ.StaticMethodType, YoutubeDL_add_extra_info)
			YoutubeDL_extract_info = λ.NewFunction("extract_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "download", Def: λ.True},
					{Name: "ie_key", Def: λ.None},
					{Name: "extra_info", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "process", Def: λ.True},
					{Name: "force_generic_extractor", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownload                = λargs[2]
						ϒextra_info              = λargs[4]
						ϒforce_generic_extractor = λargs[6]
						ϒie                      λ.Object
						ϒie_key                  = λargs[3]
						ϒies                     λ.Object
						ϒprocess                 = λargs[5]
						ϒself                    = λargs[0]
						ϒurl                     = λargs[1]
						τmp0                     λ.Object
						τmp1                     λ.Object
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(ϒie_key)); !λ.IsTrue(λv) {
							return λv
						} else {
							return ϒforce_generic_extractor
						}
					}()) {
						ϒie_key = λ.StrLiteral("Generic")
					}
					if λ.IsTrue(ϒie_key) {
						ϒies = λ.NewList(λ.Calm(ϒself, "get_info_extractor", ϒie_key))
					} else {
						ϒies = λ.GetAttr(ϒself, "_ies", nil)
					}
					τmp0 = λ.Cal(λ.BuiltinIter, ϒies)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒie = τmp1
						if !λ.IsTrue(λ.Calm(ϒie, "suitable", ϒurl)) {
							continue
						}
						ϒie = λ.Calm(ϒself, "get_info_extractor", λ.Calm(ϒie, "ie_key"))
						if !λ.IsTrue(λ.Calm(ϒie, "working")) {
							λ.Calm(ϒself, "report_warning", λ.StrLiteral("The program functionality for this site has been marked as broken, and will probably not work."))
						}
						return λ.Calm(ϒself, "__extract_info", ϒurl, ϒie, ϒdownload, ϒextra_info, ϒprocess)
					}
					if τmp1 == λ.AfterLast {
						λ.Calm(ϒself, "report_error", λ.Mod(λ.StrLiteral("no suitable InfoExtractor for URL %s"), ϒurl))
					}
					return λ.None
				})
			YoutubeDL___handle_extraction_exceptions = λ.NewFunction("__handle_extraction_exceptions",
				[]λ.Param{
					{Name: "func"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfunc    = λargs[0]
						ϒwrapper λ.Object
					)
					ϒwrapper = λ.NewFunction("wrapper",
						[]λ.Param{
							{Name: "self"},
						},
						0, true, true,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒargs   = λargs[1]
								ϒkwargs = λargs[2]
								ϒmsg    λ.Object
								ϒself   = λargs[0]
								τmp0    λ.Object
								τmp1    λ.Object
								τmp2    λ.Object
							)
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{GeoRestrictedError, func(λex λ.BaseException) {
										var ϒe λ.Object = λex
										ϒmsg = λ.GetAttr(ϒe, "msg", nil)
										if λ.IsTrue(λ.GetAttr(ϒe, "countries", nil)) {
											τmp2 = λ.IAdd(ϒmsg, λ.Mod(λ.StrLiteral("\nThis video is available in %s."), λ.Calm(λ.StrLiteral(", "), "join", λ.Cal(λ.MapIteratorType, λ.GetAttr(λ.None, "short2full", nil), λ.GetAttr(ϒe, "countries", nil)))))
											ϒmsg = τmp2
										}
										τmp2 = λ.IAdd(ϒmsg, λ.StrLiteral("\nYou might want to use a VPN or a proxy server (with --proxy) to workaround."))
										ϒmsg = τmp2
										λ.Calm(ϒself, "report_error", ϒmsg)
									}},
									&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
										var ϒe λ.Object = λex
										λ.Calm(ϒself, "report_error", λ.Cal(ϒcompat_str, ϒe), λ.Calm(ϒe, "format_traceback"))
									}},
									&λ.Catcher{MaxDownloadsReached, func(λex λ.BaseException) {
										panic(λ.Raise(λex))
									}},
									&λ.Catcher{λ.ExceptionType, func(λex λ.BaseException) {
										var ϒe λ.Object = λex
										if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("ignoreerrors"), λ.False)) {
											λ.Call(λ.GetAttr(ϒself, "report_error", nil), λ.NewArgs(λ.Cal(ϒerror_to_compat_str, ϒe)), λ.KWArgs{
												{Name: "tb", Value: λ.Cal(λ.None, λ.Calm(λ.None, "format_exc"))},
											})
										} else {
											panic(λ.Raise(λex))
										}
									}},
								)
								λexit, λret = λ.BlockExitReturn, λ.Call(ϒfunc, λ.NewArgs(λ.Unpack(
									ϒself,
									λ.AsStarred(ϒargs),
								)...), λ.KWArgs{
									{Name: "", Value: ϒkwargs},
								})
								return
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
							return λ.None
						})
					return ϒwrapper
				})
			YoutubeDL___extract_info = λ.NewFunction("__extract_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "ie"},
					{Name: "download"},
					{Name: "extra_info"},
					{Name: "process"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownload   = λargs[3]
						ϒextra_info = λargs[4]
						ϒie         = λargs[2]
						ϒie_result  λ.Object
						ϒprocess    = λargs[5]
						ϒself       = λargs[0]
						ϒurl        = λargs[1]
					)
					ϒie_result = λ.Calm(ϒie, "extract", ϒurl)
					if ϒie_result == λ.None {
						return λ.None
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒie_result, λ.ListType)) {
						ϒie_result = λ.DictLiteral(map[string]λ.Object{
							"_type":   λ.StrLiteral("compat_list"),
							"entries": ϒie_result,
						})
					}
					λ.Calm(ϒself, "add_default_extra_info", ϒie_result, ϒie, ϒurl)
					if λ.IsTrue(ϒprocess) {
						return λ.Calm(ϒself, "process_ie_result", ϒie_result, ϒdownload, ϒextra_info)
					} else {
						return ϒie_result
					}
					return λ.None
				})
			YoutubeDL___extract_info = λ.Cal(YoutubeDL___handle_extraction_exceptions, YoutubeDL___extract_info)
			YoutubeDL_add_default_extra_info = λ.NewFunction("add_default_extra_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_result"},
					{Name: "ie"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie        = λargs[2]
						ϒie_result = λargs[1]
						ϒself      = λargs[0]
						ϒurl       = λargs[3]
					)
					λ.Calm(ϒself, "add_extra_info", ϒie_result, λ.DictLiteral(map[string]λ.Object{
						"extractor":            λ.GetAttr(ϒie, "IE_NAME", nil),
						"webpage_url":          ϒurl,
						"webpage_url_basename": λ.Cal(ϒurl_basename, ϒurl),
						"extractor_key":        λ.Calm(ϒie, "ie_key"),
					}))
					return λ.None
				})
			YoutubeDL_process_ie_result = λ.NewFunction("process_ie_result",
				[]λ.Param{
					{Name: "self"},
					{Name: "ie_result"},
					{Name: "download", Def: λ.True},
					{Name: "extra_info", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_fixup           λ.Object
						ϒdownload         = λargs[2]
						ϒextra_info       = λargs[3]
						ϒextract_flat     λ.Object
						ϒf                λ.Object
						ϒforce_properties λ.Object
						ϒie_result        = λargs[1]
						ϒinfo             λ.Object
						ϒnew_result       λ.Object
						ϒresult_type      λ.Object
						ϒself             = λargs[0]
						ϒwebpage_url      λ.Object
						τmp0              λ.Object
						τmp1              λ.Object
						τmp2              λ.Object
					)
					ϒresult_type = λ.Calm(ϒie_result, "get", λ.StrLiteral("_type"), λ.StrLiteral("video"))
					if λ.Contains(λ.NewTuple(
						λ.StrLiteral("url"),
						λ.StrLiteral("url_transparent"),
					), ϒresult_type) {
						λ.SetItem(ϒie_result, λ.StrLiteral("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒie_result, λ.StrLiteral("url"))))
						ϒextract_flat = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("extract_flat"), λ.False)
						if λ.IsTrue(func() λ.Object {
							if λv := func() λ.Object {
								if λv := λ.Eq(ϒextract_flat, λ.StrLiteral("in_playlist")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Contains(ϒextra_info, λ.StrLiteral("playlist")))
								}
							}(); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(ϒextract_flat == λ.True)
							}
						}()) {
							λ.Call(λ.GetAttr(ϒself, "__forced_printings", nil), λ.NewArgs(
								ϒie_result,
								λ.Calm(ϒself, "prepare_filename", ϒie_result),
							), λ.KWArgs{
								{Name: "incomplete", Value: λ.True},
							})
							return ϒie_result
						}
					}
					if λ.IsTrue(λ.Eq(ϒresult_type, λ.StrLiteral("video"))) {
						λ.Calm(ϒself, "add_extra_info", ϒie_result, ϒextra_info)
						return λ.Call(λ.GetAttr(ϒself, "process_video_result", nil), λ.NewArgs(ϒie_result), λ.KWArgs{
							{Name: "download", Value: ϒdownload},
						})
					} else {
						if λ.IsTrue(λ.Eq(ϒresult_type, λ.StrLiteral("url"))) {
							return λ.Call(λ.GetAttr(ϒself, "extract_info", nil), λ.NewArgs(
								λ.GetItem(ϒie_result, λ.StrLiteral("url")),
								ϒdownload,
							), λ.KWArgs{
								{Name: "ie_key", Value: λ.Calm(ϒie_result, "get", λ.StrLiteral("ie_key"))},
								{Name: "extra_info", Value: ϒextra_info},
							})
						} else {
							if λ.IsTrue(λ.Eq(ϒresult_type, λ.StrLiteral("url_transparent"))) {
								ϒinfo = λ.Call(λ.GetAttr(ϒself, "extract_info", nil), λ.NewArgs(λ.GetItem(ϒie_result, λ.StrLiteral("url"))), λ.KWArgs{
									{Name: "ie_key", Value: λ.Calm(ϒie_result, "get", λ.StrLiteral("ie_key"))},
									{Name: "extra_info", Value: ϒextra_info},
									{Name: "download", Value: λ.False},
									{Name: "process", Value: λ.False},
								})
								if !λ.IsTrue(ϒinfo) {
									return ϒinfo
								}
								ϒforce_properties = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒk   λ.Object
												ϒv   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
												τmp2 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒie_result, "items"))
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												τmp2 = τmp1
												ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
												ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
												if ϒv != λ.None {
													λgy.Yield(λ.NewTuple(
														ϒk,
														ϒv,
													))
												}
											}
											return λ.None
										})
									})))
								τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
									λ.StrLiteral("_type"),
									λ.StrLiteral("url"),
									λ.StrLiteral("id"),
									λ.StrLiteral("extractor"),
									λ.StrLiteral("extractor_key"),
									λ.StrLiteral("ie_key"),
								))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒf = τmp1
									if λ.Contains(ϒforce_properties, ϒf) {
										λ.DelItem(ϒforce_properties, ϒf)
									}
								}
								ϒnew_result = λ.Calm(ϒinfo, "copy")
								λ.Calm(ϒnew_result, "update", ϒforce_properties)
								if λ.IsTrue(λ.Eq(λ.Calm(ϒnew_result, "get", λ.StrLiteral("_type")), λ.StrLiteral("url"))) {
									λ.SetItem(ϒnew_result, λ.StrLiteral("_type"), λ.StrLiteral("url_transparent"))
								}
								return λ.Call(λ.GetAttr(ϒself, "process_ie_result", nil), λ.NewArgs(ϒnew_result), λ.KWArgs{
									{Name: "download", Value: ϒdownload},
									{Name: "extra_info", Value: ϒextra_info},
								})
							} else {
								if λ.Contains(λ.NewTuple(
									λ.StrLiteral("playlist"),
									λ.StrLiteral("multi_video"),
								), ϒresult_type) {
									panic(λ.Raise(λ.Cal(λ.ExceptionType, λ.StrLiteral("Playlists and multi video results are not supported!"))))
									ϒwebpage_url = λ.GetItem(ϒie_result, λ.StrLiteral("webpage_url"))
									if λ.Contains(λ.GetAttr(ϒself, "_playlist_urls", nil), ϒwebpage_url) {
										λ.Calm(ϒself, "to_screen", func() λ.Object {
											if λv := λ.Mod(λ.StrLiteral("[download] Skipping already downloaded playlist: %s"), λ.Calm(ϒie_result, "get", λ.StrLiteral("title"))); λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Calm(ϒie_result, "get", λ.StrLiteral("id"))
											}
										}())
										return λ.None
									}
									τmp0 = λ.IAdd(λ.GetAttr(ϒself, "_playlist_level", nil), λ.IntLiteral(1))
									λ.SetAttr(ϒself, "_playlist_level", τmp0)
									λ.Calm(λ.GetAttr(ϒself, "_playlist_urls", nil), "add", ϒwebpage_url)
									τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
										defer func() {
											τmp2 = λ.ISub(λ.GetAttr(ϒself, "_playlist_level", nil), λ.IntLiteral(1))
											λ.SetAttr(ϒself, "_playlist_level", τmp2)
											if !λ.IsTrue(λ.GetAttr(ϒself, "_playlist_level", nil)) {
												λ.Calm(λ.GetAttr(ϒself, "_playlist_urls", nil), "clear")
											}
										}()
										λexit, λret = λ.BlockExitReturn, λ.Calm(ϒself, "__process_playlist", ϒie_result, ϒdownload)
										return
										return λ.BlockExitNormally, nil
									}()
									if τmp0 == λ.BlockExitReturn {
										return τmp1
									}
								} else {
									if λ.IsTrue(λ.Eq(ϒresult_type, λ.StrLiteral("compat_list"))) {
										λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("Extractor %s returned a compat_list result. It needs to be updated."), λ.Calm(ϒie_result, "get", λ.StrLiteral("extractor"))))
										ϒ_fixup = λ.NewFunction("_fixup",
											[]λ.Param{
												{Name: "r"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒr = λargs[0]
												)
												λ.Calm(ϒself, "add_extra_info", ϒr, λ.DictLiteral(map[string]λ.Object{
													"extractor":            λ.GetItem(ϒie_result, λ.StrLiteral("extractor")),
													"webpage_url":          λ.GetItem(ϒie_result, λ.StrLiteral("webpage_url")),
													"webpage_url_basename": λ.Cal(ϒurl_basename, λ.GetItem(ϒie_result, λ.StrLiteral("webpage_url"))),
													"extractor_key":        λ.GetItem(ϒie_result, λ.StrLiteral("extractor_key")),
												}))
												return ϒr
											})
										λ.SetItem(ϒie_result, λ.StrLiteral("entries"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
											nil,
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒr   λ.Object
														τmp0 λ.Object
														τmp1 λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒie_result, λ.StrLiteral("entries")))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒr = τmp1
														λgy.Yield(λ.Calm(ϒself, "process_ie_result", λ.Cal(ϒ_fixup, ϒr), ϒdownload, ϒextra_info))
													}
													return λ.None
												})
											}))))
										return ϒie_result
									} else {
										panic(λ.Raise(λ.Cal(λ.ExceptionType, λ.Mod(λ.StrLiteral("Invalid result type: %s"), ϒresult_type))))
									}
								}
							}
						}
					}
					return λ.None
				})
			YoutubeDL__default_format_spec = λ.NewFunction("_default_format_spec",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "download", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcan_merge       λ.Object
						ϒdownload        = λargs[2]
						ϒinfo_dict       = λargs[1]
						ϒprefer_best     λ.Object
						ϒreq_format_list λ.Object
						ϒself            = λargs[0]
					)
					ϒcan_merge = λ.NewFunction("can_merge",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmerger λ.Object
							)
							ϒmerger = λ.Cal(λ.None, ϒself)
							return func() λ.Object {
								if λv := λ.GetAttr(ϒmerger, "available", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒmerger, "can_merge")
								}
							}()
						})
					ϒprefer_best = λ.NewFunction("prefer_best",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("simulate"), λ.False)) {
								return λ.False
							}
							if !λ.IsTrue(ϒdownload) {
								return λ.False
							}
							if λ.IsTrue(λ.Eq(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("outtmpl"), DEFAULT_OUTTMPL), λ.StrLiteral("-"))) {
								return λ.True
							}
							if λ.IsTrue(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("is_live"))) {
								return λ.True
							}
							if !λ.IsTrue(λ.Cal(ϒcan_merge)) {
								return λ.True
							}
							return λ.False
						})
					ϒreq_format_list = λ.NewList(
						λ.StrLiteral("bestvideo+bestaudio"),
						λ.StrLiteral("best"),
					)
					if λ.IsTrue(λ.Cal(ϒprefer_best)) {
						λ.Calm(ϒreq_format_list, "reverse")
					}
					return λ.Calm(λ.StrLiteral("/"), "join", ϒreq_format_list)
				})
			YoutubeDL__calc_headers = λ.NewFunction("_calc_headers",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒadd_headers        λ.Object
						ϒcookies            λ.Object
						ϒinfo_dict          = λargs[1]
						ϒres                λ.Object
						ϒself               = λargs[0]
						ϒx_forwarded_for_ip λ.Object
					)
					ϒres = λ.Calm(ϒstd_headers, "copy")
					ϒadd_headers = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("http_headers"))
					if λ.IsTrue(ϒadd_headers) {
						λ.Calm(ϒres, "update", ϒadd_headers)
					}
					ϒcookies = λ.Calm(ϒself, "_calc_cookies", ϒinfo_dict)
					if λ.IsTrue(ϒcookies) {
						λ.SetItem(ϒres, λ.StrLiteral("Cookie"), ϒcookies)
					}
					if !λ.Contains(ϒres, λ.StrLiteral("X-Forwarded-For")) {
						ϒx_forwarded_for_ip = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("__x_forwarded_for_ip"))
						if λ.IsTrue(ϒx_forwarded_for_ip) {
							λ.SetItem(ϒres, λ.StrLiteral("X-Forwarded-For"), ϒx_forwarded_for_ip)
						}
					}
					return ϒres
				})
			YoutubeDL__calc_cookies = λ.NewFunction("_calc_cookies",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒinfo_dict = λargs[1]
						ϒpr        λ.Object
						ϒself      = λargs[0]
					)
					ϒpr = λ.Cal(ϒsanitized_Request, λ.GetItem(ϒinfo_dict, λ.StrLiteral("url")))
					λ.Calm(λ.GetAttr(ϒself, "cookiejar", nil), "add_cookie_header", ϒpr)
					return λ.Calm(ϒpr, "get_header", λ.StrLiteral("Cookie"))
				})
			YoutubeDL_process_video_result = λ.NewFunction("process_video_result",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "download", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒambiguous_formats       λ.Object
						ϒautomatic_captions      λ.Object
						ϒcc                      λ.Object
						ϒcc_kind                 λ.Object
						ϒctx                     λ.Object
						ϒdownload                = λargs[2]
						ϒfield                   λ.Object
						ϒformat                  λ.Object
						ϒformat_id               λ.Object
						ϒformat_selector         λ.Object
						ϒformats                 λ.Object
						ϒformats_dict            λ.Object
						ϒformats_to_download     λ.Object
						ϒfull_format_info        λ.Object
						ϒi                       λ.Object
						ϒincomplete_formats      λ.Object
						ϒinfo_dict               = λargs[1]
						ϒis_wellformed           λ.Object
						ϒnew_info                λ.Object
						ϒreport_force_conversion λ.Object
						ϒreq_format              λ.Object
						ϒsanitize_numeric_fields λ.Object
						ϒsanitize_string_field   λ.Object
						ϒself                    = λargs[0]
						ϒsubtitle                λ.Object
						ϒsubtitle_format         λ.Object
						ϒsubtitles               λ.Object
						ϒt                       λ.Object
						ϒthumbnail               λ.Object
						ϒthumbnails              λ.Object
						τmp0                     λ.Object
						τmp1                     λ.Object
						τmp2                     λ.Object
						τmp3                     λ.Object
						τmp4                     λ.Object
						τmp5                     λ.Object
					)
					if !λ.IsTrue(λ.Eq(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("_type"), λ.StrLiteral("video")), λ.StrLiteral("video"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if !λ.Contains(ϒinfo_dict, λ.StrLiteral("id")) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("Missing \"id\" field in extractor result"))))
					}
					if !λ.Contains(ϒinfo_dict, λ.StrLiteral("title")) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("Missing \"title\" field in extractor result"))))
					}
					ϒreport_force_conversion = λ.NewFunction("report_force_conversion",
						[]λ.Param{
							{Name: "field"},
							{Name: "field_not"},
							{Name: "conversion"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒconversion = λargs[2]
								ϒfield      = λargs[0]
								ϒfield_not  = λargs[1]
							)
							λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("\"%s\" field is not %s - forcing %s conversion, there is an error in extractor"), λ.NewTuple(
								ϒfield,
								ϒfield_not,
								ϒconversion,
							)))
							return λ.None
						})
					ϒsanitize_string_field = λ.NewFunction("sanitize_string_field",
						[]λ.Param{
							{Name: "info"},
							{Name: "string_field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield        λ.Object
								ϒinfo         = λargs[0]
								ϒstring_field = λargs[1]
							)
							ϒfield = λ.Calm(ϒinfo, "get", ϒstring_field)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒfield == λ.None); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.BuiltinIsInstance, ϒfield, ϒcompat_str)
								}
							}()) {
								return λ.None
							}
							λ.Cal(ϒreport_force_conversion, ϒstring_field, λ.StrLiteral("a string"), λ.StrLiteral("string"))
							λ.SetItem(ϒinfo, ϒstring_field, λ.Cal(ϒcompat_str, ϒfield))
							return λ.None
						})
					ϒsanitize_numeric_fields = λ.NewFunction("sanitize_numeric_fields",
						[]λ.Param{
							{Name: "info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield         λ.Object
								ϒinfo          = λargs[0]
								ϒnumeric_field λ.Object
								τmp0           λ.Object
								τmp1           λ.Object
							)
							τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_NUMERIC_FIELDS", nil))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒnumeric_field = τmp1
								ϒfield = λ.Calm(ϒinfo, "get", ϒnumeric_field)
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(ϒfield == λ.None); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(λ.BuiltinIsInstance, ϒfield, ϒcompat_numeric_types)
									}
								}()) {
									continue
								}
								λ.Cal(ϒreport_force_conversion, ϒnumeric_field, λ.StrLiteral("numeric"), λ.StrLiteral("int"))
								λ.SetItem(ϒinfo, ϒnumeric_field, λ.Cal(ϒint_or_none, ϒfield))
							}
							return λ.None
						})
					λ.Cal(ϒsanitize_string_field, ϒinfo_dict, λ.StrLiteral("id"))
					λ.Cal(ϒsanitize_numeric_fields, ϒinfo_dict)
					if !λ.Contains(ϒinfo_dict, λ.StrLiteral("playlist")) {
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("playlist"), λ.None)
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("playlist_index"), λ.None)
					}
					ϒthumbnails = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("thumbnails"))
					if ϒthumbnails == λ.None {
						ϒthumbnail = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("thumbnail"))
						if λ.IsTrue(ϒthumbnail) {
							τmp0 = λ.NewList(λ.DictLiteral(map[string]λ.Object{
								"url": ϒthumbnail,
							}))
							λ.SetItem(ϒinfo_dict, λ.StrLiteral("thumbnails"), τmp0)
							ϒthumbnails = τmp0
						}
					}
					if λ.IsTrue(ϒthumbnails) {
						λ.Call(λ.GetAttr(ϒthumbnails, "sort", nil), nil, λ.KWArgs{
							{Name: "key", Value: λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "t"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒt = λargs[0]
									)
									return λ.NewTuple(
										func() λ.Object {
											if λ.Calm(ϒt, "get", λ.StrLiteral("preference")) != λ.None {
												return λ.Calm(ϒt, "get", λ.StrLiteral("preference"))
											} else {
												return λ.Neg(λ.IntLiteral(1))
											}
										}(),
										func() λ.Object {
											if λ.Calm(ϒt, "get", λ.StrLiteral("width")) != λ.None {
												return λ.Calm(ϒt, "get", λ.StrLiteral("width"))
											} else {
												return λ.Neg(λ.IntLiteral(1))
											}
										}(),
										func() λ.Object {
											if λ.Calm(ϒt, "get", λ.StrLiteral("height")) != λ.None {
												return λ.Calm(ϒt, "get", λ.StrLiteral("height"))
											} else {
												return λ.Neg(λ.IntLiteral(1))
											}
										}(),
										func() λ.Object {
											if λ.Calm(ϒt, "get", λ.StrLiteral("id")) != λ.None {
												return λ.Calm(ϒt, "get", λ.StrLiteral("id"))
											} else {
												return λ.StrLiteral("")
											}
										}(),
										λ.Calm(ϒt, "get", λ.StrLiteral("url")),
									)
								})},
						})
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒthumbnails))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒi = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒt = λ.GetItem(τmp2, λ.IntLiteral(1))
							λ.SetItem(ϒt, λ.StrLiteral("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒt, λ.StrLiteral("url"))))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(ϒt, "get", λ.StrLiteral("width")); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒt, "get", λ.StrLiteral("height"))
								}
							}()) {
								λ.SetItem(ϒt, λ.StrLiteral("resolution"), λ.Mod(λ.StrLiteral("%dx%d"), λ.NewTuple(
									λ.GetItem(ϒt, λ.StrLiteral("width")),
									λ.GetItem(ϒt, λ.StrLiteral("height")),
								)))
							}
							if λ.Calm(ϒt, "get", λ.StrLiteral("id")) == λ.None {
								λ.SetItem(ϒt, λ.StrLiteral("id"), λ.Mod(λ.StrLiteral("%d"), ϒi))
							}
						}
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("list_thumbnails"))) {
						λ.Calm(ϒself, "list_thumbnails", ϒinfo_dict)
						return λ.None
					}
					ϒthumbnail = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("thumbnail"))
					if λ.IsTrue(ϒthumbnail) {
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("thumbnail"), λ.Cal(ϒsanitize_url, ϒthumbnail))
					} else {
						if λ.IsTrue(ϒthumbnails) {
							λ.SetItem(ϒinfo_dict, λ.StrLiteral("thumbnail"), λ.GetItem(λ.GetItem(ϒthumbnails, λ.Neg(λ.IntLiteral(1))), λ.StrLiteral("url")))
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.Contains(ϒinfo_dict, λ.StrLiteral("display_id"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒinfo_dict, λ.StrLiteral("id")))
						}
					}()) {
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("display_id"), λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.StrLiteral("chapter"),
						λ.StrLiteral("season"),
						λ.StrLiteral("episode"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒfield = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(λ.Calm(ϒinfo_dict, "get", λ.Mod(λ.StrLiteral("%s_number"), ϒfield)) != λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Calm(ϒinfo_dict, "get", ϒfield)))
							}
						}()) {
							λ.SetItem(ϒinfo_dict, ϒfield, λ.Mod(λ.StrLiteral("%s %d"), λ.NewTuple(
								λ.Calm(ϒfield, "capitalize"),
								λ.GetItem(ϒinfo_dict, λ.Mod(λ.StrLiteral("%s_number"), ϒfield)),
							)))
						}
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.StrLiteral("subtitles"),
						λ.StrLiteral("automatic_captions"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒcc_kind = τmp1
						ϒcc = λ.Calm(ϒinfo_dict, "get", ϒcc_kind)
						if λ.IsTrue(ϒcc) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒcc, "items"))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								τmp4 = τmp3
								_ = λ.GetItem(τmp4, λ.IntLiteral(0))
								ϒsubtitle = λ.GetItem(τmp4, λ.IntLiteral(1))
								τmp4 = λ.Cal(λ.BuiltinIter, ϒsubtitle)
								for {
									if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
										break
									}
									ϒsubtitle_format = τmp5
									if λ.IsTrue(λ.Calm(ϒsubtitle_format, "get", λ.StrLiteral("url"))) {
										λ.SetItem(ϒsubtitle_format, λ.StrLiteral("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒsubtitle_format, λ.StrLiteral("url"))))
									}
									if λ.Calm(ϒsubtitle_format, "get", λ.StrLiteral("ext")) == λ.None {
										λ.SetItem(ϒsubtitle_format, λ.StrLiteral("ext"), λ.Calm(λ.Cal(ϒdetermine_ext, λ.GetItem(ϒsubtitle_format, λ.StrLiteral("url"))), "lower"))
									}
								}
							}
						}
					}
					ϒautomatic_captions = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("automatic_captions"))
					ϒsubtitles = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("subtitles"))
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("listsubtitles"), λ.False)) {
						if λ.Contains(ϒinfo_dict, λ.StrLiteral("automatic_captions")) {
							λ.Calm(ϒself, "list_subtitles", λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")), ϒautomatic_captions, λ.StrLiteral("automatic captions"))
						}
						λ.Calm(ϒself, "list_subtitles", λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")), ϒsubtitles, λ.StrLiteral("subtitles"))
						return λ.None
					}
					λ.SetItem(ϒinfo_dict, λ.StrLiteral("requested_subtitles"), λ.Calm(ϒself, "process_subtitles", λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")), ϒsubtitles, ϒautomatic_captions))
					if λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("formats")) == λ.None {
						ϒformats = λ.NewList(ϒinfo_dict)
					} else {
						ϒformats = λ.GetItem(ϒinfo_dict, λ.StrLiteral("formats"))
					}
					if !λ.IsTrue(ϒformats) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("No video formats found!"))))
					}
					ϒis_wellformed = λ.NewFunction("is_wellformed",
						[]λ.Param{
							{Name: "f"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒf   = λargs[0]
								ϒurl λ.Object
							)
							ϒurl = λ.Calm(ϒf, "get", λ.StrLiteral("url"))
							if !λ.IsTrue(ϒurl) {
								λ.Calm(ϒself, "report_warning", λ.StrLiteral("\"url\" field is missing or empty - skipping format, there is an error in extractor"))
								return λ.False
							}
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl, λ.BytesType)) {
								λ.Cal(ϒsanitize_string_field, ϒf, λ.StrLiteral("url"))
							}
							return λ.True
						})
					ϒformats = λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, ϒis_wellformed, ϒformats))
					ϒformats_dict = λ.DictLiteral(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒformats))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒformat = λ.GetItem(τmp2, λ.IntLiteral(1))
						λ.Cal(ϒsanitize_string_field, ϒformat, λ.StrLiteral("format_id"))
						λ.Cal(ϒsanitize_numeric_fields, ϒformat)
						λ.SetItem(ϒformat, λ.StrLiteral("url"), λ.Cal(ϒsanitize_url, λ.GetItem(ϒformat, λ.StrLiteral("url"))))
						if !λ.IsTrue(λ.Calm(ϒformat, "get", λ.StrLiteral("format_id"))) {
							λ.SetItem(ϒformat, λ.StrLiteral("format_id"), λ.Cal(ϒcompat_str, ϒi))
						} else {
							λ.SetItem(ϒformat, λ.StrLiteral("format_id"), λ.Cal(Ωre.ϒsub, λ.StrLiteral("[\\s,/+\\[\\]()]"), λ.StrLiteral("_"), λ.GetItem(ϒformat, λ.StrLiteral("format_id"))))
						}
						ϒformat_id = λ.GetItem(ϒformat, λ.StrLiteral("format_id"))
						if !λ.Contains(ϒformats_dict, ϒformat_id) {
							λ.SetItem(ϒformats_dict, ϒformat_id, λ.NewList())
						}
						λ.Calm(λ.GetItem(ϒformats_dict, ϒformat_id), "append", ϒformat)
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒformats_dict, "items"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒformat_id = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒambiguous_formats = λ.GetItem(τmp2, λ.IntLiteral(1))
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒambiguous_formats), λ.IntLiteral(1))) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒambiguous_formats))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								τmp4 = τmp3
								ϒi = λ.GetItem(τmp4, λ.IntLiteral(0))
								ϒformat = λ.GetItem(τmp4, λ.IntLiteral(1))
								λ.SetItem(ϒformat, λ.StrLiteral("format_id"), λ.Mod(λ.StrLiteral("%s-%d"), λ.NewTuple(
									ϒformat_id,
									ϒi,
								)))
							}
						}
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒformats))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒformat = λ.GetItem(τmp2, λ.IntLiteral(1))
						if λ.Calm(ϒformat, "get", λ.StrLiteral("format")) == λ.None {
							λ.SetItem(ϒformat, λ.StrLiteral("format"), λ.Call(λ.GetAttr(λ.StrLiteral("{id} - {res}{note}"), "format", nil), nil, λ.KWArgs{
								{Name: "id", Value: λ.GetItem(ϒformat, λ.StrLiteral("format_id"))},
								{Name: "res", Value: λ.Calm(ϒself, "format_resolution", ϒformat)},
								{Name: "note", Value: func() λ.Object {
									if λ.Calm(ϒformat, "get", λ.StrLiteral("format_note")) != λ.None {
										return λ.Calm(λ.StrLiteral(" ({0})"), "format", λ.GetItem(ϒformat, λ.StrLiteral("format_note")))
									} else {
										return λ.StrLiteral("")
									}
								}()},
							}))
						}
						if λ.Calm(ϒformat, "get", λ.StrLiteral("ext")) == λ.None {
							λ.SetItem(ϒformat, λ.StrLiteral("ext"), λ.Calm(λ.Cal(ϒdetermine_ext, λ.GetItem(ϒformat, λ.StrLiteral("url"))), "lower"))
						}
						if λ.Calm(ϒformat, "get", λ.StrLiteral("protocol")) == λ.None {
							λ.SetItem(ϒformat, λ.StrLiteral("protocol"), λ.Cal(ϒdetermine_protocol, ϒformat))
						}
						ϒfull_format_info = λ.Calm(ϒinfo_dict, "copy")
						λ.Calm(ϒfull_format_info, "update", ϒformat)
						λ.SetItem(ϒformat, λ.StrLiteral("http_headers"), λ.Calm(ϒself, "_calc_headers", ϒfull_format_info))
					}
					if λ.Contains(ϒinfo_dict, λ.StrLiteral("__x_forwarded_for_ip")) {
						λ.DelItem(ϒinfo_dict, λ.StrLiteral("__x_forwarded_for_ip"))
					}
					if λ.GetItem(ϒformats, λ.IntLiteral(0)) != ϒinfo_dict {
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("formats"), ϒformats)
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("listformats"))) {
						λ.Calm(ϒself, "list_formats", ϒinfo_dict)
						return λ.None
					}
					ϒreq_format = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("format"))
					if ϒreq_format == λ.None {
						ϒreq_format = λ.Call(λ.GetAttr(ϒself, "_default_format_spec", nil), λ.NewArgs(ϒinfo_dict), λ.KWArgs{
							{Name: "download", Value: ϒdownload},
						})
						if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("verbose"))) {
							λ.Calm(ϒself, "_write_string", λ.Mod(λ.StrLiteral("[debug] Default format spec: %s\n"), ϒreq_format))
						}
					}
					ϒformat_selector = λ.Calm(ϒself, "build_format_selector", ϒreq_format)
					ϒincomplete_formats = func() λ.Object {
						if λv := λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒf   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒf = τmp1
										λgy.Yield(func() λ.Object {
											if λv := λ.Ne(λ.Calm(ϒf, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none")); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Eq(λ.Calm(ϒf, "get", λ.StrLiteral("acodec")), λ.StrLiteral("none"))
											}
										}())
									}
									return λ.None
								})
							}))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(λ.BuiltinAll, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
										var (
											ϒf   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒf = τmp1
											λgy.Yield(func() λ.Object {
												if λv := λ.Eq(λ.Calm(ϒf, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none")); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Ne(λ.Calm(ϒf, "get", λ.StrLiteral("acodec")), λ.StrLiteral("none"))
												}
											}())
										}
										return λ.None
									})
								})))
						}
					}()
					ϒctx = λ.DictLiteral(map[string]λ.Object{
						"formats":            ϒformats,
						"incomplete_formats": ϒincomplete_formats,
					})
					ϒformats_to_download = λ.Cal(λ.ListType, λ.Cal(ϒformat_selector, ϒctx))
					if !λ.IsTrue(ϒformats_to_download) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("requested format not available")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.IsTrue(ϒdownload) {
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒformats_to_download), λ.IntLiteral(1))) {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("[info] %s: downloading video in %s formats"), λ.NewTuple(
								λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
								λ.Cal(λ.BuiltinLen, ϒformats_to_download),
							)))
						}
						τmp0 = λ.Cal(λ.BuiltinIter, ϒformats_to_download)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒformat = τmp1
							ϒnew_info = λ.Cal(λ.DictType, ϒinfo_dict)
							λ.Calm(ϒnew_info, "update", ϒformat)
							λ.Calm(ϒself, "process_info", ϒnew_info)
						}
					}
					λ.Calm(ϒinfo_dict, "update", λ.GetItem(ϒformats_to_download, λ.Neg(λ.IntLiteral(1))))
					return ϒinfo_dict
				})
			YoutubeDL_process_subtitles = λ.NewFunction("process_subtitles",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
					{Name: "normal_subtitles"},
					{Name: "automatic_captions"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒautomatic_captions = λargs[3]
						ϒavailable_subs     λ.Object
						ϒcap_info           λ.Object
						ϒext                λ.Object
						ϒf                  λ.Object
						ϒformats            λ.Object
						ϒformats_preference λ.Object
						ϒformats_query      λ.Object
						ϒlang               λ.Object
						ϒmatches            λ.Object
						ϒnormal_subtitles   = λargs[2]
						ϒrequested_langs    λ.Object
						ϒself               = λargs[0]
						ϒsubs               λ.Object
						ϒvideo_id           = λargs[1]
						τmp0                λ.Object
						τmp1                λ.Object
						τmp2                λ.Object
						τmp3                λ.Object
					)
					ϒavailable_subs = λ.DictLiteral(map[λ.Object]λ.Object{})
					if λ.IsTrue(func() λ.Object {
						if λv := ϒnormal_subtitles; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writesubtitles"))
						}
					}()) {
						λ.Calm(ϒavailable_subs, "update", ϒnormal_subtitles)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := ϒautomatic_captions; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writeautomaticsub"))
						}
					}()) {
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒautomatic_captions, "items"))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒlang = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒcap_info = λ.GetItem(τmp2, λ.IntLiteral(1))
							if !λ.Contains(ϒavailable_subs, ϒlang) {
								λ.SetItem(ϒavailable_subs, ϒlang, ϒcap_info)
							}
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writesubtitles")))); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writeautomaticsub"))))
							}
						}(); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒavailable_subs))
						}
					}()) {
						return λ.None
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("allsubtitles"), λ.False)) {
						ϒrequested_langs = λ.Calm(ϒavailable_subs, "keys")
					} else {
						if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("subtitleslangs"), λ.False)) {
							ϒrequested_langs = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("subtitleslangs"))
						} else {
							if λ.Contains(ϒavailable_subs, λ.StrLiteral("en")) {
								ϒrequested_langs = λ.NewList(λ.StrLiteral("en"))
							} else {
								ϒrequested_langs = λ.NewList(λ.GetItem(λ.Cal(λ.ListType, λ.Calm(ϒavailable_subs, "keys")), λ.IntLiteral(0)))
							}
						}
					}
					ϒformats_query = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("subtitlesformat"), λ.StrLiteral("best"))
					ϒformats_preference = func() λ.Object {
						if λ.IsTrue(ϒformats_query) {
							return λ.Calm(ϒformats_query, "split", λ.StrLiteral("/"))
						} else {
							return λ.NewList()
						}
					}()
					ϒsubs = λ.DictLiteral(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, ϒrequested_langs)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒlang = τmp1
						ϒformats = λ.Calm(ϒavailable_subs, "get", ϒlang)
						if ϒformats == λ.None {
							λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s subtitles not available for %s"), λ.NewTuple(
								ϒlang,
								ϒvideo_id,
							)))
							continue
						}
						τmp2 = λ.Cal(λ.BuiltinIter, ϒformats_preference)
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒext = τmp3
							if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("best"))) {
								ϒf = λ.GetItem(ϒformats, λ.Neg(λ.IntLiteral(1)))
								break
							}
							ϒmatches = λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "f"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒf = λargs[0]
									)
									return λ.Eq(λ.GetItem(ϒf, λ.StrLiteral("ext")), ϒext)
								}), ϒformats))
							if λ.IsTrue(ϒmatches) {
								ϒf = λ.GetItem(ϒmatches, λ.Neg(λ.IntLiteral(1)))
								break
							}
						}
						if τmp3 == λ.AfterLast {
							ϒf = λ.GetItem(ϒformats, λ.Neg(λ.IntLiteral(1)))
							λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("No subtitle format found matching \"%s\" for language %s, using %s"), λ.NewTuple(
								ϒformats_query,
								ϒlang,
								λ.GetItem(ϒf, λ.StrLiteral("ext")),
							)))
						}
						λ.SetItem(ϒsubs, ϒlang, ϒf)
					}
					return ϒsubs
				})
			YoutubeDL___forced_printings = λ.NewFunction("__forced_printings",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
					{Name: "filename"},
					{Name: "incomplete"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf               λ.Object
						ϒfilename        = λargs[2]
						ϒincomplete      = λargs[3]
						ϒinfo_dict       = λargs[1]
						ϒprint_mandatory λ.Object
						ϒprint_optional  λ.Object
						ϒself            = λargs[0]
						τmp0             λ.Object
						τmp1             λ.Object
					)
					ϒprint_mandatory = λ.NewFunction("print_mandatory",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.Mod(λ.StrLiteral("force%s"), ϒfield), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return func() λ.Object {
										if λv := λ.NewBool(!λ.IsTrue(ϒincomplete)); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(λ.Calm(ϒinfo_dict, "get", ϒfield) != λ.None)
										}
									}()
								}
							}()) {
								λ.Calm(ϒself, "to_stdout", λ.GetItem(ϒinfo_dict, ϒfield))
							}
							return λ.None
						})
					ϒprint_optional = λ.NewFunction("print_optional",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.Mod(λ.StrLiteral("force%s"), ϒfield), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Calm(ϒinfo_dict, "get", ϒfield) != λ.None)
								}
							}()) {
								λ.Calm(ϒself, "to_stdout", λ.GetItem(ϒinfo_dict, ϒfield))
							}
							return λ.None
						})
					λ.Cal(ϒprint_mandatory, λ.StrLiteral("title"))
					λ.Cal(ϒprint_mandatory, λ.StrLiteral("id"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("forceurl"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒincomplete))
						}
					}()) {
						if λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("requested_formats")) != λ.None {
							τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒinfo_dict, λ.StrLiteral("requested_formats")))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒf = τmp1
								λ.Calm(ϒself, "to_stdout", λ.Add(λ.GetItem(ϒf, λ.StrLiteral("url")), λ.Calm(ϒf, "get", λ.StrLiteral("play_path"), λ.StrLiteral(""))))
							}
						} else {
							λ.Calm(ϒself, "to_stdout", λ.Add(λ.GetItem(ϒinfo_dict, λ.StrLiteral("url")), λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("play_path"), λ.StrLiteral(""))))
						}
					}
					λ.Cal(ϒprint_optional, λ.StrLiteral("thumbnail"))
					λ.Cal(ϒprint_optional, λ.StrLiteral("description"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("forcefilename"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(ϒfilename != λ.None)
						}
					}()) {
						λ.Calm(ϒself, "to_stdout", ϒfilename)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("forceduration"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("duration")) != λ.None)
						}
					}()) {
						λ.Calm(ϒself, "to_stdout", λ.Cal(λ.None, λ.GetItem(ϒinfo_dict, λ.StrLiteral("duration"))))
					}
					λ.Cal(ϒprint_mandatory, λ.StrLiteral("format"))
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("forcejson"), λ.False)) {
						λ.Calm(ϒself, "to_stdout", λ.Cal(Ωjson.ϒdumps, ϒinfo_dict))
					}
					return λ.None
				})
			YoutubeDL_process_info = λ.NewFunction("process_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "info_dict"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						INSTALL_FFMPEG_MESSAGE   λ.Object
						ϒannofile                λ.Object
						ϒannofn                  λ.Object
						ϒcompatible_formats      λ.Object
						ϒdescfile                λ.Object
						ϒdescfn                  λ.Object
						ϒdl                      λ.Object
						ϒdownloaded              λ.Object
						ϒensure_dir_exists       λ.Object
						ϒf                       λ.Object
						ϒfilename                λ.Object
						ϒfilename_real_ext       λ.Object
						ϒfilename_wo_ext         λ.Object
						ϒfixup_policy            λ.Object
						ϒfixup_pp                λ.Object
						ϒfname                   λ.Object
						ϒie                      λ.Object
						ϒinfo_dict               = λargs[1]
						ϒinfofn                  λ.Object
						ϒmax_downloads           λ.Object
						ϒmerger                  λ.Object
						ϒnew_info                λ.Object
						ϒpartial_success         λ.Object
						ϒpostprocessors          λ.Object
						ϒreason                  λ.Object
						ϒrequested_formats       λ.Object
						ϒself                    = λargs[0]
						ϒstretched_pp            λ.Object
						ϒstretched_ratio         λ.Object
						ϒsub_data                λ.Object
						ϒsub_filename            λ.Object
						ϒsub_format              λ.Object
						ϒsub_info                λ.Object
						ϒsub_lang                λ.Object
						ϒsubfile                 λ.Object
						ϒsubtitles               λ.Object
						ϒsubtitles_are_requested λ.Object
						ϒsuccess                 λ.Object
						τmp0                     λ.Object
						τmp1                     λ.Object
						τmp2                     λ.Object
						τmp3                     λ.Object
						τmp4                     λ.Object
						τmp5                     λ.Object
						τmp6                     λ.Object
						τmp7                     λ.Object
					)
					_ = τmp6
					_ = τmp7
					if !λ.IsTrue(λ.Eq(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("_type"), λ.StrLiteral("video")), λ.StrLiteral("video"))) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒmax_downloads = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("max_downloads"))
					if ϒmax_downloads != λ.None {
						if λ.IsTrue(λ.Ge(λ.GetAttr(ϒself, "_num_downloads", nil), λ.Cal(λ.IntType, ϒmax_downloads))) {
							panic(λ.Raise(λ.Cal(MaxDownloadsReached)))
						}
					}
					λ.SetItem(ϒinfo_dict, λ.StrLiteral("fulltitle"), λ.GetItem(ϒinfo_dict, λ.StrLiteral("title")))
					if !λ.Contains(ϒinfo_dict, λ.StrLiteral("format")) {
						λ.SetItem(ϒinfo_dict, λ.StrLiteral("format"), λ.GetItem(ϒinfo_dict, λ.StrLiteral("ext")))
					}
					ϒreason = λ.Call(λ.GetAttr(ϒself, "_match_entry", nil), λ.NewArgs(ϒinfo_dict), λ.KWArgs{
						{Name: "incomplete", Value: λ.False},
					})
					if ϒreason != λ.None {
						λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("[download] "), ϒreason))
						return λ.None
					}
					τmp0 = λ.IAdd(λ.GetAttr(ϒself, "_num_downloads", nil), λ.IntLiteral(1))
					λ.SetAttr(ϒself, "_num_downloads", τmp0)
					τmp0 = λ.Calm(ϒself, "prepare_filename", ϒinfo_dict)
					λ.SetItem(ϒinfo_dict, λ.StrLiteral("_filename"), τmp0)
					ϒfilename = τmp0
					λ.Call(λ.GetAttr(ϒself, "__forced_printings", nil), λ.NewArgs(
						ϒinfo_dict,
						ϒfilename,
					), λ.KWArgs{
						{Name: "incomplete", Value: λ.False},
					})
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("simulate"), λ.False)) {
						return λ.None
					}
					if ϒfilename == λ.None {
						return λ.None
					}
					ϒensure_dir_exists = λ.NewFunction("ensure_dir_exists",
						[]λ.Param{
							{Name: "path"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdn   λ.Object
								ϒpath = λargs[0]
								τmp0  λ.Object
								τmp1  λ.Object
							)
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										λ.OSErrorType,
										λ.OSErrorType,
									), func(λex λ.BaseException) {
										var ϒerr λ.Object = λex
										if λ.IsTrue(func() λ.Object {
											if λv := λ.Cal(λ.BuiltinIsInstance, ϒerr, λ.OSErrorType); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Eq(λ.GetAttr(ϒerr, "errno", nil), λ.GetAttr(λ.None, "EEXIST", nil))
											}
										}()) {
											λexit, λret = λ.BlockExitReturn, λ.True
											return
										}
										λ.Calm(ϒself, "report_error", λ.Add(λ.StrLiteral("unable to create directory "), λ.Cal(ϒerror_to_compat_str, ϒerr)))
										λexit, λret = λ.BlockExitReturn, λ.False
										return
									}},
								)
								ϒdn = λ.Cal(λ.None, ϒpath)
								if λ.IsTrue(func() λ.Object {
									if λv := ϒdn; !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(λ.None, ϒdn)))
									}
								}()) {
									λ.Cal(λ.None, ϒdn)
								}
								λexit, λret = λ.BlockExitReturn, λ.True
								return
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
							return λ.None
						})
					if !λ.IsTrue(λ.Cal(ϒensure_dir_exists, λ.Cal(ϒsanitize_path, λ.Cal(λ.None, ϒfilename)))) {
						return λ.None
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writedescription"), λ.False)) {
						ϒdescfn = λ.Cal(λ.None, ϒfilename, λ.StrLiteral("description"), λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒdescfn))
							}
						}()) {
							λ.Calm(ϒself, "to_screen", λ.StrLiteral("[info] Video description is already present"))
						} else {
							if λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("description")) == λ.None {
								λ.Calm(ϒself, "report_warning", λ.StrLiteral("There's no description to write."))
							} else {
								τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.NewTuple(
											λ.OSErrorType,
											λ.OSErrorType,
										), func(λex λ.BaseException) {
											λ.Calm(ϒself, "report_error", λ.Add(λ.StrLiteral("Cannot write description file "), ϒdescfn))
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}},
									)
									λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("[info] Writing video description to: "), ϒdescfn))
									τmp2 = λ.Call(λ.None, λ.NewArgs(
										λ.Cal(λ.None, ϒdescfn),
										λ.StrLiteral("w"),
									), λ.KWArgs{
										{Name: "encoding", Value: λ.StrLiteral("utf-8")},
									})
									τmp3 = λ.GetAttr(τmp2, "__exit__", nil)
									ϒdescfile = λ.Calm(τmp2, "__enter__")
									τmp4, τmp5 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
											if ret := λ.Cal(τmp3, λex.Type(), λex, λ.StrLiteral("..todo..traceback..")); λ.IsTrue(ret) {
												panic(λ.Raise(λex))
											}
										}, func() {
											λ.Cal(τmp3, λ.None, λ.None, λ.None)
										})
										λ.Calm(ϒdescfile, "write", λ.GetItem(ϒinfo_dict, λ.StrLiteral("description")))
										return λ.BlockExitNormally, nil
									}()
									return λ.BlockExitNormally, nil
								}()
								if τmp0 == λ.BlockExitReturn {
									return τmp1
								}
							}
						}
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writeannotations"), λ.False)) {
						ϒannofn = λ.Cal(λ.None, ϒfilename, λ.StrLiteral("annotations.xml"), λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒannofn))
							}
						}()) {
							λ.Calm(ϒself, "to_screen", λ.StrLiteral("[info] Video annotations are already present"))
						} else {
							if !λ.IsTrue(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("annotations"))) {
								λ.Calm(ϒself, "report_warning", λ.StrLiteral("There are no annotations to write."))
							} else {
								τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.NewTuple(
											λ.KeyErrorType,
											λ.TypeErrorType,
										), func(λex λ.BaseException) {
											λ.Calm(ϒself, "report_warning", λ.StrLiteral("There are no annotations to write."))
										}},
										&λ.Catcher{λ.NewTuple(
											λ.OSErrorType,
											λ.OSErrorType,
										), func(λex λ.BaseException) {
											λ.Calm(ϒself, "report_error", λ.Add(λ.StrLiteral("Cannot write annotations file: "), ϒannofn))
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}},
									)
									λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("[info] Writing video annotations to: "), ϒannofn))
									τmp3 = λ.Call(λ.None, λ.NewArgs(
										λ.Cal(λ.None, ϒannofn),
										λ.StrLiteral("w"),
									), λ.KWArgs{
										{Name: "encoding", Value: λ.StrLiteral("utf-8")},
									})
									τmp2 = λ.GetAttr(τmp3, "__exit__", nil)
									ϒannofile = λ.Calm(τmp3, "__enter__")
									τmp5, τmp4 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
											if ret := λ.Cal(τmp2, λex.Type(), λex, λ.StrLiteral("..todo..traceback..")); λ.IsTrue(ret) {
												panic(λ.Raise(λex))
											}
										}, func() {
											λ.Cal(τmp2, λ.None, λ.None, λ.None)
										})
										λ.Calm(ϒannofile, "write", λ.GetItem(ϒinfo_dict, λ.StrLiteral("annotations")))
										return λ.BlockExitNormally, nil
									}()
									return λ.BlockExitNormally, nil
								}()
								if τmp1 == λ.BlockExitReturn {
									return τmp0
								}
							}
						}
					}
					ϒsubtitles_are_requested = λ.Cal(λ.BuiltinAny, λ.NewList(
						λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writesubtitles"), λ.False),
						λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writeautomaticsub")),
					))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒsubtitles_are_requested; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("requested_subtitles"))
						}
					}()) {
						ϒsubtitles = λ.GetItem(ϒinfo_dict, λ.StrLiteral("requested_subtitles"))
						ϒie = λ.Calm(ϒself, "get_info_extractor", λ.GetItem(ϒinfo_dict, λ.StrLiteral("extractor_key")))
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒsubtitles, "items"))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							ϒsub_lang = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒsub_info = λ.GetItem(τmp2, λ.IntLiteral(1))
							ϒsub_format = λ.GetItem(ϒsub_info, λ.StrLiteral("ext"))
							ϒsub_filename = λ.Cal(λ.None, ϒfilename, ϒsub_lang, ϒsub_format, λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("ext")))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("nooverwrites"), λ.False); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(λ.None, λ.Cal(λ.None, ϒsub_filename))
								}
							}()) {
								λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("[info] Video subtitle %s.%s is already present"), λ.NewTuple(
									ϒsub_lang,
									ϒsub_format,
								)))
							} else {
								λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("[info] Writing video subtitles to: "), ϒsub_filename))
								if λ.Calm(ϒsub_info, "get", λ.StrLiteral("data")) != λ.None {
									τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.NewTuple(
												λ.OSErrorType,
												λ.OSErrorType,
											), func(λex λ.BaseException) {
												λ.Calm(ϒself, "report_error", λ.Add(λ.StrLiteral("Cannot write subtitles file "), ϒsub_filename))
												λexit, λret = λ.BlockExitReturn, λ.None
												return
											}},
										)
										τmp4 = λ.Call(λ.None, λ.NewArgs(
											λ.Cal(λ.None, ϒsub_filename),
											λ.StrLiteral("w"),
										), λ.KWArgs{
											{Name: "encoding", Value: λ.StrLiteral("utf-8")},
											{Name: "newline", Value: λ.StrLiteral("")},
										})
										τmp5 = λ.GetAttr(τmp4, "__exit__", nil)
										ϒsubfile = λ.Calm(τmp4, "__enter__")
										τmp6, τmp7 = func() (λexit λ.Object, λret λ.Object) {
											defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
												if ret := λ.Cal(τmp5, λex.Type(), λex, λ.StrLiteral("..todo..traceback..")); λ.IsTrue(ret) {
													panic(λ.Raise(λex))
												}
											}, func() {
												λ.Cal(τmp5, λ.None, λ.None, λ.None)
											})
											λ.Calm(ϒsubfile, "write", λ.GetItem(ϒsub_info, λ.StrLiteral("data")))
											return λ.BlockExitNormally, nil
										}()
										return λ.BlockExitNormally, nil
									}()
									if τmp2 == λ.BlockExitReturn {
										return τmp3
									}
								} else {
									τmp3, τmp2 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.NewTuple(
												ExtractorError,
												λ.OSErrorType,
												λ.OSErrorType,
												λ.ValueErrorType,
											), func(λex λ.BaseException) {
												var ϒerr λ.Object = λex
												λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("Unable to download subtitle for \"%s\": %s"), λ.NewTuple(
													ϒsub_lang,
													λ.Cal(ϒerror_to_compat_str, ϒerr),
												)))
												λexit = λ.BlockExitContinue
												return
											}},
										)
										ϒsub_data = λ.Calm(λ.Call(λ.GetAttr(ϒie, "_request_webpage", nil), λ.NewArgs(
											λ.GetItem(ϒsub_info, λ.StrLiteral("url")),
											λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
										), λ.KWArgs{
											{Name: "note", Value: λ.False},
										}), "read")
										τmp5 = λ.Cal(λ.None, λ.Cal(λ.None, ϒsub_filename), λ.StrLiteral("wb"))
										τmp4 = λ.GetAttr(τmp5, "__exit__", nil)
										ϒsubfile = λ.Calm(τmp5, "__enter__")
										τmp7, τmp6 = func() (λexit λ.Object, λret λ.Object) {
											defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
												if ret := λ.Cal(τmp4, λex.Type(), λex, λ.StrLiteral("..todo..traceback..")); λ.IsTrue(ret) {
													panic(λ.Raise(λex))
												}
											}, func() {
												λ.Cal(τmp4, λ.None, λ.None, λ.None)
											})
											λ.Calm(ϒsubfile, "write", ϒsub_data)
											return λ.BlockExitNormally, nil
										}()
										return λ.BlockExitNormally, nil
									}()
									if τmp3 == λ.BlockExitContinue {
										continue
									}
								}
							}
						}
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("writeinfojson"), λ.False)) {
						ϒinfofn = λ.Cal(λ.None, ϒfilename, λ.StrLiteral("info.json"), λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("ext")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("nooverwrites"), λ.False); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.None, λ.Cal(λ.None, ϒinfofn))
							}
						}()) {
							λ.Calm(ϒself, "to_screen", λ.StrLiteral("[info] Video description metadata is already present"))
						} else {
							λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("[info] Writing video description metadata as JSON to: "), ϒinfofn))
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										λ.OSErrorType,
										λ.OSErrorType,
									), func(λex λ.BaseException) {
										λ.Calm(ϒself, "report_error", λ.Add(λ.StrLiteral("Cannot write metadata to JSON file "), ϒinfofn))
										λexit, λret = λ.BlockExitReturn, λ.None
										return
									}},
								)
								λ.Cal(λ.None, λ.Calm(ϒself, "filter_requested_info", ϒinfo_dict), ϒinfofn)
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
						}
					}
					λ.Calm(ϒself, "_write_thumbnails", ϒinfo_dict, ϒfilename)
					if !λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("skip_download"), λ.False)) {
						τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.NewTuple(
									Ωerror.URLError,
									λ.GetAttr(ϒcompat_http_client, "HTTPException", nil),
									Ωsocket.ϒerror,
								), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									λ.Calm(ϒself, "report_error", λ.Mod(λ.StrLiteral("unable to download video data: %s"), λ.Cal(ϒerror_to_compat_str, ϒerr)))
									λexit, λret = λ.BlockExitReturn, λ.None
									return
								}},
								&λ.Catcher{λ.NewTuple(
									λ.OSErrorType,
									λ.OSErrorType,
								), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									panic(λ.Raise(λ.Cal(UnavailableVideoError, ϒerr)))
								}},
								&λ.Catcher{λ.NewTuple(λ.None), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									λ.Calm(ϒself, "report_error", λ.Mod(λ.StrLiteral("content too short (expected %s bytes and served %s)"), λ.NewTuple(
										λ.GetAttr(ϒerr, "expected", nil),
										λ.GetAttr(ϒerr, "downloaded", nil),
									)))
									λexit, λret = λ.BlockExitReturn, λ.None
									return
								}},
							)
							ϒdl = λ.NewFunction("dl",
								[]λ.Param{
									{Name: "name"},
									{Name: "info"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒfd   λ.Object
										ϒinfo = λargs[1]
										ϒname = λargs[0]
										ϒph   λ.Object
										τmp0  λ.Object
										τmp1  λ.Object
									)
									ϒfd = λ.Cal(λ.Cal(λ.None, ϒinfo, λ.GetAttr(ϒself, "params", nil)), ϒself, λ.GetAttr(ϒself, "params", nil))
									τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_progress_hooks", nil))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒph = τmp1
										λ.Calm(ϒfd, "add_progress_hook", ϒph)
									}
									if λ.IsTrue(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("verbose"))) {
										λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("[debug] Invoking downloader on %r"), λ.Calm(ϒinfo, "get", λ.StrLiteral("url"))))
									}
									return λ.Calm(ϒfd, "download", ϒname, ϒinfo)
								})
							if λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("requested_formats")) != λ.None {
								ϒdownloaded = λ.NewList()
								ϒsuccess = λ.True
								ϒmerger = λ.Cal(λ.None, ϒself)
								if !λ.IsTrue(λ.GetAttr(ϒmerger, "available", nil)) {
									ϒpostprocessors = λ.NewList()
									λ.Calm(ϒself, "report_warning", λ.StrLiteral("You have requested multiple formats but ffmpeg or avconv are not installed. The formats won't be merged."))
								} else {
									ϒpostprocessors = λ.NewList(ϒmerger)
								}
								ϒcompatible_formats = λ.NewFunction("compatible_formats",
									[]λ.Param{
										{Name: "formats"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											COMPATIBLE_EXTS λ.Object
											ϒaudio          λ.Object
											ϒaudio_ext      λ.Object
											ϒexts           λ.Object
											ϒformats        = λargs[0]
											ϒvideo          λ.Object
											ϒvideo_ext      λ.Object
											τmp0            λ.Object
											τmp1            λ.Object
										)
										τmp0 = ϒformats
										ϒvideo = λ.GetItem(τmp0, λ.IntLiteral(0))
										ϒaudio = λ.GetItem(τmp0, λ.IntLiteral(1))
										τmp0 = λ.NewTuple(
											λ.Calm(ϒvideo, "get", λ.StrLiteral("ext")),
											λ.Calm(ϒaudio, "get", λ.StrLiteral("ext")),
										)
										ϒvideo_ext = λ.GetItem(τmp0, λ.IntLiteral(0))
										ϒaudio_ext = λ.GetItem(τmp0, λ.IntLiteral(1))
										if λ.IsTrue(func() λ.Object {
											if λv := ϒvideo_ext; !λ.IsTrue(λv) {
												return λv
											} else {
												return ϒaudio_ext
											}
										}()) {
											COMPATIBLE_EXTS = λ.NewTuple(
												λ.NewTuple(
													λ.StrLiteral("mp3"),
													λ.StrLiteral("mp4"),
													λ.StrLiteral("m4a"),
													λ.StrLiteral("m4p"),
													λ.StrLiteral("m4b"),
													λ.StrLiteral("m4r"),
													λ.StrLiteral("m4v"),
													λ.StrLiteral("ismv"),
													λ.StrLiteral("isma"),
												),
												λ.StrLiteral("webm"),
											)
											τmp0 = λ.Cal(λ.BuiltinIter, COMPATIBLE_EXTS)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒexts = τmp1
												if λ.IsTrue(func() λ.Object {
													if λv := λ.NewBool(λ.Contains(ϒexts, ϒvideo_ext)); !λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewBool(λ.Contains(ϒexts, ϒaudio_ext))
													}
												}()) {
													return λ.True
												}
											}
										}
										return λ.False
									})
								ϒfilename_real_ext = λ.GetItem(λ.GetItem(λ.Cal(λ.None, ϒfilename), λ.IntLiteral(1)), λ.NewSlice(λ.IntLiteral(1), λ.None, λ.None))
								ϒfilename_wo_ext = func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒfilename_real_ext, λ.GetItem(ϒinfo_dict, λ.StrLiteral("ext")))) {
										return λ.GetItem(λ.Cal(λ.None, ϒfilename), λ.IntLiteral(0))
									} else {
										return ϒfilename
									}
								}()
								ϒrequested_formats = λ.GetItem(ϒinfo_dict, λ.StrLiteral("requested_formats"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("merge_output_format")) == λ.None); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(ϒcompatible_formats, ϒrequested_formats)))
									}
								}()) {
									λ.SetItem(ϒinfo_dict, λ.StrLiteral("ext"), λ.StrLiteral("mkv"))
									λ.Calm(ϒself, "report_warning", λ.StrLiteral("Requested formats are incompatible for merge and will be merged into mkv."))
								}
								ϒfilename = λ.Mod(λ.StrLiteral("%s.%s"), λ.NewTuple(
									ϒfilename_wo_ext,
									λ.GetItem(ϒinfo_dict, λ.StrLiteral("ext")),
								))
								if λ.IsTrue(λ.Cal(λ.None, λ.Cal(λ.None, ϒfilename))) {
									λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("[download] %s has already been downloaded and merged"), ϒfilename))
								} else {
									τmp2 = λ.Cal(λ.BuiltinIter, ϒrequested_formats)
									for {
										if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
											break
										}
										ϒf = τmp3
										ϒnew_info = λ.Cal(λ.DictType, ϒinfo_dict)
										λ.Calm(ϒnew_info, "update", ϒf)
										ϒfname = λ.Cal(λ.None, λ.Calm(ϒself, "prepare_filename", ϒnew_info), λ.Mod(λ.StrLiteral("f%s"), λ.GetItem(ϒf, λ.StrLiteral("format_id"))), λ.GetItem(ϒnew_info, λ.StrLiteral("ext")))
										if !λ.IsTrue(λ.Cal(ϒensure_dir_exists, ϒfname)) {
											λexit, λret = λ.BlockExitReturn, λ.None
											return
										}
										λ.Calm(ϒdownloaded, "append", ϒfname)
										ϒpartial_success = λ.Cal(ϒdl, ϒfname, ϒnew_info)
										ϒsuccess = func() λ.Object {
											if λv := ϒsuccess; !λ.IsTrue(λv) {
												return λv
											} else {
												return ϒpartial_success
											}
										}()
									}
									λ.SetItem(ϒinfo_dict, λ.StrLiteral("__postprocessors"), ϒpostprocessors)
									λ.SetItem(ϒinfo_dict, λ.StrLiteral("__files_to_merge"), ϒdownloaded)
								}
							} else {
								ϒsuccess = λ.Cal(ϒdl, ϒfilename, ϒinfo_dict)
							}
							return λ.BlockExitNormally, nil
						}()
						if τmp1 == λ.BlockExitReturn {
							return τmp0
						}
						if λ.IsTrue(func() λ.Object {
							if λv := ϒsuccess; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Ne(ϒfilename, λ.StrLiteral("-"))
							}
						}()) {
							ϒfixup_policy = λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("fixup"))
							if ϒfixup_policy == λ.None {
								ϒfixup_policy = λ.StrLiteral("detect_or_warn")
							}
							INSTALL_FFMPEG_MESSAGE = λ.StrLiteral("Install ffmpeg or avconv to fix this automatically.")
							ϒstretched_ratio = λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("stretched_ratio"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒstretched_ratio != λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Ne(ϒstretched_ratio, λ.IntLiteral(1))
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("warn"))) {
									λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: Non-uniform pixel ratio (%s)"), λ.NewTuple(
										λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
										ϒstretched_ratio,
									)))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("detect_or_warn"))) {
										ϒstretched_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒstretched_pp, "available", nil)) {
											λ.Calm(ϒinfo_dict, "setdefault", λ.StrLiteral("__postprocessors"), λ.NewList())
											λ.Calm(λ.GetItem(ϒinfo_dict, λ.StrLiteral("__postprocessors")), "append", ϒstretched_pp)
										} else {
											λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: Non-uniform pixel ratio (%s). %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
												ϒstretched_ratio,
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.Contains(λ.NewTuple(
											λ.StrLiteral("ignore"),
											λ.StrLiteral("never"),
										), ϒfixup_policy) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("requested_formats")) == λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("container")), λ.StrLiteral("m4a_dash"))
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("warn"))) {
									λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: writing DASH m4a. Only some players support this container."), λ.GetItem(ϒinfo_dict, λ.StrLiteral("id"))))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("detect_or_warn"))) {
										ϒfixup_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒfixup_pp, "available", nil)) {
											λ.Calm(ϒinfo_dict, "setdefault", λ.StrLiteral("__postprocessors"), λ.NewList())
											λ.Calm(λ.GetItem(ϒinfo_dict, λ.StrLiteral("__postprocessors")), "append", ϒfixup_pp)
										} else {
											λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: writing DASH m4a. Only some players support this container. %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.Contains(λ.NewTuple(
											λ.StrLiteral("ignore"),
											λ.StrLiteral("never"),
										), ϒfixup_policy) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("protocol")), λ.StrLiteral("m3u8_native")); λ.IsTrue(λv) {
									return λv
								} else {
									return func() λ.Object {
										if λv := λ.Eq(λ.Calm(ϒinfo_dict, "get", λ.StrLiteral("protocol")), λ.StrLiteral("m3u8")); !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(λ.GetAttr(ϒself, "params", nil), "get", λ.StrLiteral("hls_prefer_native"))
										}
									}()
								}
							}()) {
								if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("warn"))) {
									λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: malformed AAC bitstream detected."), λ.GetItem(ϒinfo_dict, λ.StrLiteral("id"))))
								} else {
									if λ.IsTrue(λ.Eq(ϒfixup_policy, λ.StrLiteral("detect_or_warn"))) {
										ϒfixup_pp = λ.Cal(λ.None, ϒself)
										if λ.IsTrue(λ.GetAttr(ϒfixup_pp, "available", nil)) {
											λ.Calm(ϒinfo_dict, "setdefault", λ.StrLiteral("__postprocessors"), λ.NewList())
											λ.Calm(λ.GetItem(ϒinfo_dict, λ.StrLiteral("__postprocessors")), "append", ϒfixup_pp)
										} else {
											λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s: malformed AAC bitstream detected. %s"), λ.NewTuple(
												λ.GetItem(ϒinfo_dict, λ.StrLiteral("id")),
												INSTALL_FFMPEG_MESSAGE,
											)))
										}
									} else {
										if !λ.Contains(λ.NewTuple(
											λ.StrLiteral("ignore"),
											λ.StrLiteral("never"),
										), ϒfixup_policy) {
											panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
										}
									}
								}
							}
							τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{PostProcessingError, func(λex λ.BaseException) {
										var ϒerr λ.Object = λex
										λ.Calm(ϒself, "report_error", λ.Mod(λ.StrLiteral("postprocessing: %s"), λ.Cal(λ.StrType, ϒerr)))
										λexit, λret = λ.BlockExitReturn, λ.None
										return
									}},
								)
								λ.Calm(ϒself, "post_process", ϒfilename, ϒinfo_dict)
								return λ.BlockExitNormally, nil
							}()
							if τmp0 == λ.BlockExitReturn {
								return τmp1
							}
							λ.Calm(ϒself, "record_download_archive", ϒinfo_dict)
						}
					}
					return λ.None
				})
			YoutubeDL_format_resolution = λ.NewFunction("format_resolution",
				[]λ.Param{
					{Name: "format"},
					{Name: "default", Def: λ.StrLiteral("unknown")},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault = λargs[1]
						ϒformat  = λargs[0]
						ϒres     λ.Object
					)
					if λ.IsTrue(λ.Eq(λ.Calm(ϒformat, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none"))) {
						return λ.StrLiteral("audio only")
					}
					if λ.Calm(ϒformat, "get", λ.StrLiteral("resolution")) != λ.None {
						return λ.GetItem(ϒformat, λ.StrLiteral("resolution"))
					}
					if λ.Calm(ϒformat, "get", λ.StrLiteral("height")) != λ.None {
						if λ.Calm(ϒformat, "get", λ.StrLiteral("width")) != λ.None {
							ϒres = λ.Mod(λ.StrLiteral("%sx%s"), λ.NewTuple(
								λ.GetItem(ϒformat, λ.StrLiteral("width")),
								λ.GetItem(ϒformat, λ.StrLiteral("height")),
							))
						} else {
							ϒres = λ.Mod(λ.StrLiteral("%sp"), λ.GetItem(ϒformat, λ.StrLiteral("height")))
						}
					} else {
						if λ.Calm(ϒformat, "get", λ.StrLiteral("width")) != λ.None {
							ϒres = λ.Mod(λ.StrLiteral("%dx?"), λ.GetItem(ϒformat, λ.StrLiteral("width")))
						} else {
							ϒres = ϒdefault
						}
					}
					return ϒres
				})
			YoutubeDL_format_resolution = λ.Cal(λ.StaticMethodType, YoutubeDL_format_resolution)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_NUMERIC_FIELDS":                YoutubeDL__NUMERIC_FIELDS,
				"__extract_info":                 YoutubeDL___extract_info,
				"__forced_printings":             YoutubeDL___forced_printings,
				"__handle_extraction_exceptions": YoutubeDL___handle_extraction_exceptions,
				"_bidi_workaround":               YoutubeDL__bidi_workaround,
				"_calc_cookies":                  YoutubeDL__calc_cookies,
				"_calc_headers":                  YoutubeDL__calc_headers,
				"_default_format_spec":           YoutubeDL__default_format_spec,
				"_ies":                           YoutubeDL__ies,
				"_num_downloads":                 YoutubeDL__num_downloads,
				"_screen_file":                   YoutubeDL__screen_file,
				"add_default_extra_info":         YoutubeDL_add_default_extra_info,
				"add_default_info_extractors":    YoutubeDL_add_default_info_extractors,
				"add_extra_info":                 YoutubeDL_add_extra_info,
				"add_info_extractor":             YoutubeDL_add_info_extractor,
				"extract_info":                   YoutubeDL_extract_info,
				"format_resolution":              YoutubeDL_format_resolution,
				"get_info_extractor":             YoutubeDL_get_info_extractor,
				"params":                         YoutubeDL_params,
				"prepare_filename":               YoutubeDL_prepare_filename,
				"process_ie_result":              YoutubeDL_process_ie_result,
				"process_info":                   YoutubeDL_process_info,
				"process_subtitles":              YoutubeDL_process_subtitles,
				"process_video_result":           YoutubeDL_process_video_result,
				"report_error":                   YoutubeDL_report_error,
				"report_warning":                 YoutubeDL_report_warning,
				"to_screen":                      YoutubeDL_to_screen,
				"to_stderr":                      YoutubeDL_to_stderr,
				"to_stdout":                      YoutubeDL_to_stdout,
				"trouble":                        YoutubeDL_trouble,
			})
		}())
	})
}
