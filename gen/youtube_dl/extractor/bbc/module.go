// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * bbc/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/bbc.py
 */

package bbc

import (
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	BBCCoUkArticleIE         λ.Object
	BBCCoUkIE                λ.Object
	BBCCoUkIPlayerPlaylistIE λ.Object
	BBCCoUkPlaylistBaseIE    λ.Object
	BBCCoUkPlaylistIE        λ.Object
	BBCIE                    λ.Object
	ExtractorError           λ.Object
	InfoExtractor            λ.Object
	ϒclean_html              λ.Object
	ϒcompat_HTTPError        λ.Object
	ϒcompat_etree_Element    λ.Object
	ϒdict_get                λ.Object
	ϒfloat_or_none           λ.Object
	ϒget_element_by_class    λ.Object
	ϒint_or_none             λ.Object
	ϒjs_to_json              λ.Object
	ϒparse_duration          λ.Object
	ϒparse_iso8601           λ.Object
	ϒtry_get                 λ.Object
	ϒunescapeHTML            λ.Object
	ϒurl_or_none             λ.Object
	ϒurlencode_postdata      λ.Object
	ϒurljoin                 λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_etree_Element = Ωcompat.ϒcompat_etree_Element
		ϒcompat_HTTPError = Ωcompat.ϒcompat_HTTPError
		ExtractorError = Ωutils.ExtractorError
		ϒclean_html = Ωutils.ϒclean_html
		ϒdict_get = Ωutils.ϒdict_get
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒget_element_by_class = Ωutils.ϒget_element_by_class
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒjs_to_json = Ωutils.ϒjs_to_json
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒparse_iso8601 = Ωutils.ϒparse_iso8601
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒurl_or_none = Ωutils.ϒurl_or_none
		ϒurlencode_postdata = Ωutils.ϒurlencode_postdata
		ϒurljoin = Ωutils.ϒurljoin
		BBCCoUkIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCCoUkIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BBCCoUkIE_IE_NAME                      λ.Object
				BBCCoUkIE_MediaSelectionError          λ.Object
				BBCCoUkIE__ID_REGEX                    λ.Object
				BBCCoUkIE__MEDIA_SELECTOR_URL_TEMPL    λ.Object
				BBCCoUkIE__MEDIA_SETS                  λ.Object
				BBCCoUkIE__NETRC_MACHINE               λ.Object
				BBCCoUkIE__VALID_URL                   λ.Object
				BBCCoUkIE__download_media_selector     λ.Object
				BBCCoUkIE__download_media_selector_url λ.Object
				BBCCoUkIE__extract_connections         λ.Object
				BBCCoUkIE__extract_medias              λ.Object
				BBCCoUkIE__login                       λ.Object
				BBCCoUkIE__process_media_selector      λ.Object
				BBCCoUkIE__real_extract                λ.Object
				BBCCoUkIE__real_initialize             λ.Object
			)
			BBCCoUkIE_IE_NAME = λ.StrLiteral("bbc.co.uk")
			BBCCoUkIE__ID_REGEX = λ.StrLiteral("(?:[pbm][\\da-z]{7}|w[\\da-z]{7,14})")
			BBCCoUkIE__VALID_URL = λ.Mod(λ.StrLiteral("(?x)\n                    https?://\n                        (?:www\\.)?bbc\\.co\\.uk/\n                        (?:\n                            programmes/(?!articles/)|\n                            iplayer(?:/[^/]+)?/(?:episode/|playlist/)|\n                            music/(?:clips|audiovideo/popular)[/#]|\n                            radio/player/|\n                            sounds/play/|\n                            events/[^/]+/play/[^/]+/\n                        )\n                        (?P<id>%s)(?!/(?:episodes|broadcasts|clips))\n                    "), BBCCoUkIE__ID_REGEX)
			BBCCoUkIE__NETRC_MACHINE = λ.StrLiteral("bbc")
			BBCCoUkIE__MEDIA_SELECTOR_URL_TEMPL = λ.StrLiteral("https://open.live.bbc.co.uk/mediaselector/6/select/version/2.0/mediaset/%s/vpid/%s")
			BBCCoUkIE__MEDIA_SETS = λ.NewList(
				λ.StrLiteral("iptv-all"),
				λ.StrLiteral("pc"),
			)
			BBCCoUkIE__login = λ.NewFunction("_login",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerror      λ.Object
						ϒlogin_form λ.Object
						ϒlogin_page λ.Object
						ϒpassword   λ.Object
						ϒpost_url   λ.Object
						ϒresponse   λ.Object
						ϒself       = λargs[0]
						ϒurlh       λ.Object
						ϒusername   λ.Object
						τmp0        λ.Object
					)
					τmp0 = λ.Calm(ϒself, "_get_login_info")
					ϒusername = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒpassword = λ.GetItem(τmp0, λ.IntLiteral(1))
					if ϒusername == λ.None {
						return λ.None
					}
					ϒlogin_page = λ.Calm(ϒself, "_download_webpage", λ.GetAttr(ϒself, "_LOGIN_URL", nil), λ.None, λ.StrLiteral("Downloading signin page"))
					ϒlogin_form = λ.Calm(ϒself, "_hidden_inputs", ϒlogin_page)
					λ.Calm(ϒlogin_form, "update", λ.DictLiteral(map[string]λ.Object{
						"username": ϒusername,
						"password": ϒpassword,
					}))
					ϒpost_url = λ.Cal(ϒurljoin, λ.GetAttr(ϒself, "_LOGIN_URL", nil), λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("<form[^>]+action=([\"\\'])(?P<url>.+?)\\1"),
						ϒlogin_page,
						λ.StrLiteral("post url"),
					), λ.KWArgs{
						{Name: "default", Value: λ.GetAttr(ϒself, "_LOGIN_URL", nil)},
						{Name: "group", Value: λ.StrLiteral("url")},
					}))
					τmp0 = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒpost_url,
						λ.None,
						λ.StrLiteral("Logging in"),
					), λ.KWArgs{
						{Name: "data", Value: λ.Cal(ϒurlencode_postdata, ϒlogin_form)},
						{Name: "headers", Value: λ.DictLiteral(map[string]λ.Object{
							"Referer": λ.GetAttr(ϒself, "_LOGIN_URL", nil),
						})},
					})
					ϒresponse = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					if λ.Contains(λ.Calm(ϒurlh, "geturl"), λ.GetAttr(ϒself, "_LOGIN_URL", nil)) {
						ϒerror = λ.Cal(ϒclean_html, λ.Cal(ϒget_element_by_class, λ.StrLiteral("form-message"), ϒresponse))
						if λ.IsTrue(ϒerror) {
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.StrLiteral("Unable to login: %s"), ϒerror)), λ.KWArgs{
								{Name: "expected", Value: λ.True},
							})))
						}
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("Unable to log in"))))
					}
					return λ.None
				})
			BBCCoUkIE__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.Calm(ϒself, "_login")
					return λ.None
				})
			BBCCoUkIE_MediaSelectionError = λ.Cal(λ.TypeType, λ.StrLiteral("MediaSelectionError"), λ.NewTuple(λ.ExceptionType), func() λ.Dict {

				return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
			}())
			BBCCoUkIE__extract_medias = λ.NewFunction("_extract_medias",
				[]λ.Param{
					{Name: "self"},
					{Name: "media_selection"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerror           λ.Object
						ϒmedia_selection = λargs[1]
						ϒself            = λargs[0]
					)
					_ = ϒself
					ϒerror = λ.Calm(ϒmedia_selection, "get", λ.StrLiteral("result"))
					if λ.IsTrue(ϒerror) {
						panic(λ.Raise(λ.Calm(BBCCoUkIE, "MediaSelectionError", ϒerror)))
					}
					return func() λ.Object {
						if λv := λ.Calm(ϒmedia_selection, "get", λ.StrLiteral("media")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}()
				})
			BBCCoUkIE__extract_connections = λ.NewFunction("_extract_connections",
				[]λ.Param{
					{Name: "self"},
					{Name: "media"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmedia = λargs[1]
						ϒself  = λargs[0]
					)
					_ = ϒself
					return func() λ.Object {
						if λv := λ.Calm(ϒmedia, "get", λ.StrLiteral("connection")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}()
				})
			BBCCoUkIE__download_media_selector = λ.NewFunction("_download_media_selector",
				[]λ.Param{
					{Name: "self"},
					{Name: "programme_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒlast_exception λ.Object
						ϒmedia_set      λ.Object
						ϒprogramme_id   = λargs[1]
						ϒself           = λargs[0]
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
						τmp3            λ.Object
					)
					ϒlast_exception = λ.None
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒself, "_MEDIA_SETS", nil))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmedia_set = τmp1
						τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.GetAttr(BBCCoUkIE, "MediaSelectionError", nil), func(λex λ.BaseException) {
									var ϒe λ.Object = λex
									if λ.Contains(λ.NewTuple(
										λ.StrLiteral("notukerror"),
										λ.StrLiteral("geolocation"),
										λ.StrLiteral("selectionunavailable"),
									), λ.GetAttr(ϒe, "id", nil)) {
										ϒlast_exception = ϒe
										λexit = λ.BlockExitContinue
										return
									}
									λ.Calm(ϒself, "_raise_extractor_error", ϒe)
								}},
							)
							λexit, λret = λ.BlockExitReturn, λ.Calm(ϒself, "_download_media_selector_url", λ.Mod(λ.GetAttr(ϒself, "_MEDIA_SELECTOR_URL_TEMPL", nil), λ.NewTuple(
								ϒmedia_set,
								ϒprogramme_id,
							)), ϒprogramme_id)
							return
							return λ.BlockExitNormally, nil
						}()
						if τmp2 == λ.BlockExitReturn {
							return τmp3
						}
						if τmp2 == λ.BlockExitContinue {
							continue
						}
					}
					λ.Calm(ϒself, "_raise_extractor_error", ϒlast_exception)
					return λ.None
				})
			BBCCoUkIE__download_media_selector_url = λ.NewFunction("_download_media_selector_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "programme_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmedia_selection λ.Object
						ϒprogramme_id    = λargs[2]
						ϒself            = λargs[0]
						ϒurl             = λargs[1]
					)
					ϒmedia_selection = λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
						ϒurl,
						ϒprogramme_id,
						λ.StrLiteral("Downloading media selection JSON"),
					), λ.KWArgs{
						{Name: "expected_status", Value: λ.NewTuple(
							λ.IntLiteral(403),
							λ.IntLiteral(404),
						)},
					})
					return λ.Calm(ϒself, "_process_media_selector", ϒmedia_selection, ϒprogramme_id)
				})
			BBCCoUkIE__process_media_selector = λ.NewFunction("_process_media_selector",
				[]λ.Param{
					{Name: "self"},
					{Name: "media_selection"},
					{Name: "programme_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒapplication     λ.Object
						ϒauth_string     λ.Object
						ϒbitrate         λ.Object
						ϒconn_kind       λ.Object
						ϒconnection      λ.Object
						ϒencoding        λ.Object
						ϒfile_size       λ.Object
						ϒfmt             λ.Object
						ϒformat_id       λ.Object
						ϒformats         λ.Object
						ϒheight          λ.Object
						ϒhref            λ.Object
						ϒi               λ.Object
						ϒidentifier      λ.Object
						ϒkind            λ.Object
						ϒmedia           λ.Object
						ϒmedia_selection = λargs[1]
						ϒprogramme_id    = λargs[2]
						ϒprotocol        λ.Object
						ϒref             λ.Object
						ϒself            = λargs[0]
						ϒserver          λ.Object
						ϒsubtitles       λ.Object
						ϒsupplier        λ.Object
						ϒtransfer_format λ.Object
						ϒurls            λ.Object
						ϒwidth           λ.Object
						τmp0             λ.Object
						τmp1             λ.Object
						τmp2             λ.Object
						τmp3             λ.Object
						τmp4             λ.Object
						τmp5             λ.Object
						τmp6             λ.Object
					)
					ϒformats = λ.NewList()
					ϒsubtitles = λ.None
					ϒurls = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒself, "_extract_medias", ϒmedia_selection))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmedia = τmp1
						ϒkind = λ.Calm(ϒmedia, "get", λ.StrLiteral("kind"))
						if λ.Contains(λ.NewTuple(
							λ.StrLiteral("video"),
							λ.StrLiteral("audio"),
						), ϒkind) {
							ϒbitrate = λ.Cal(ϒint_or_none, λ.Calm(ϒmedia, "get", λ.StrLiteral("bitrate")))
							ϒencoding = λ.Calm(ϒmedia, "get", λ.StrLiteral("encoding"))
							ϒwidth = λ.Cal(ϒint_or_none, λ.Calm(ϒmedia, "get", λ.StrLiteral("width")))
							ϒheight = λ.Cal(ϒint_or_none, λ.Calm(ϒmedia, "get", λ.StrLiteral("height")))
							ϒfile_size = λ.Cal(ϒint_or_none, λ.Calm(ϒmedia, "get", λ.StrLiteral("media_file_size")))
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒself, "_extract_connections", ϒmedia))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒconnection = τmp3
								ϒhref = λ.Calm(ϒconnection, "get", λ.StrLiteral("href"))
								if λ.Contains(ϒurls, ϒhref) {
									continue
								}
								if λ.IsTrue(ϒhref) {
									λ.Calm(ϒurls, "append", ϒhref)
								}
								ϒconn_kind = λ.Calm(ϒconnection, "get", λ.StrLiteral("kind"))
								ϒprotocol = λ.Calm(ϒconnection, "get", λ.StrLiteral("protocol"))
								ϒsupplier = λ.Calm(ϒconnection, "get", λ.StrLiteral("supplier"))
								ϒtransfer_format = λ.Calm(ϒconnection, "get", λ.StrLiteral("transferFormat"))
								ϒformat_id = func() λ.Object {
									if λv := ϒsupplier; λ.IsTrue(λv) {
										return λv
									} else if λv := ϒconn_kind; λ.IsTrue(λv) {
										return λv
									} else {
										return ϒprotocol
									}
								}()
								if λ.IsTrue(λ.Eq(ϒsupplier, λ.StrLiteral("asx"))) {
									τmp4 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, λ.Calm(ϒself, "_extract_asx_playlist", ϒconnection, ϒprogramme_id)))
									for {
										if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
											break
										}
										τmp6 = τmp5
										ϒi = λ.GetItem(τmp6, λ.IntLiteral(0))
										ϒref = λ.GetItem(τmp6, λ.IntLiteral(1))
										λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
											"url": ϒref,
											"format_id": λ.Mod(λ.StrLiteral("ref%s_%s"), λ.NewTuple(
												ϒi,
												ϒformat_id,
											)),
										}))
									}
								} else {
									if λ.IsTrue(λ.Eq(ϒtransfer_format, λ.StrLiteral("dash"))) {
										λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
											ϒhref,
											ϒprogramme_id,
										), λ.KWArgs{
											{Name: "mpd_id", Value: ϒformat_id},
											{Name: "fatal", Value: λ.False},
										}))
									} else {
										if λ.IsTrue(λ.Eq(ϒtransfer_format, λ.StrLiteral("hls"))) {
											λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
												ϒhref,
												ϒprogramme_id,
											), λ.KWArgs{
												{Name: "ext", Value: λ.StrLiteral("mp4")},
												{Name: "entry_protocol", Value: λ.StrLiteral("m3u8_native")},
												{Name: "m3u8_id", Value: ϒformat_id},
												{Name: "fatal", Value: λ.False},
											}))
										} else {
											if λ.IsTrue(λ.Eq(ϒtransfer_format, λ.StrLiteral("hds"))) {
												λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
													ϒhref,
													ϒprogramme_id,
												), λ.KWArgs{
													{Name: "f4m_id", Value: ϒformat_id},
													{Name: "fatal", Value: λ.False},
												}))
											} else {
												if λ.IsTrue(func() λ.Object {
													if λv := λ.NewBool(!λ.IsTrue(ϒsupplier)); !λ.IsTrue(λv) {
														return λv
													} else {
														return ϒbitrate
													}
												}()) {
													τmp4 = λ.IAdd(ϒformat_id, λ.Mod(λ.StrLiteral("-%d"), ϒbitrate))
													ϒformat_id = τmp4
												}
												ϒfmt = λ.DictLiteral(map[string]λ.Object{
													"format_id": ϒformat_id,
													"filesize":  ϒfile_size,
												})
												if λ.IsTrue(λ.Eq(ϒkind, λ.StrLiteral("video"))) {
													λ.Calm(ϒfmt, "update", λ.DictLiteral(map[string]λ.Object{
														"width":  ϒwidth,
														"height": ϒheight,
														"tbr":    ϒbitrate,
														"vcodec": ϒencoding,
													}))
												} else {
													λ.Calm(ϒfmt, "update", λ.DictLiteral(map[string]λ.Object{
														"abr":    ϒbitrate,
														"acodec": ϒencoding,
														"vcodec": λ.StrLiteral("none"),
													}))
												}
												if λ.Contains(λ.NewTuple(
													λ.StrLiteral("http"),
													λ.StrLiteral("https"),
												), ϒprotocol) {
													λ.Calm(ϒfmt, "update", λ.DictLiteral(map[string]λ.Object{
														"url": ϒhref,
													}))
												} else {
													if λ.IsTrue(λ.Eq(ϒprotocol, λ.StrLiteral("rtmp"))) {
														ϒapplication = λ.Calm(ϒconnection, "get", λ.StrLiteral("application"), λ.StrLiteral("ondemand"))
														ϒauth_string = λ.Calm(ϒconnection, "get", λ.StrLiteral("authString"))
														ϒidentifier = λ.Calm(ϒconnection, "get", λ.StrLiteral("identifier"))
														ϒserver = λ.Calm(ϒconnection, "get", λ.StrLiteral("server"))
														λ.Calm(ϒfmt, "update", λ.DictLiteral(map[string]λ.Object{
															"url": λ.Mod(λ.StrLiteral("%s://%s/%s?%s"), λ.NewTuple(
																ϒprotocol,
																ϒserver,
																ϒapplication,
																ϒauth_string,
															)),
															"play_path": ϒidentifier,
															"app": λ.Mod(λ.StrLiteral("%s?%s"), λ.NewTuple(
																ϒapplication,
																ϒauth_string,
															)),
															"page_url":   λ.StrLiteral("http://www.bbc.co.uk"),
															"player_url": λ.StrLiteral("http://www.bbc.co.uk/emp/releases/iplayer/revisions/617463_618125_4/617463_618125_4_emp.swf"),
															"rtmp_live":  λ.False,
															"ext":        λ.StrLiteral("flv"),
														}))
													} else {
														continue
													}
												}
												λ.Calm(ϒformats, "append", ϒfmt)
											}
										}
									}
								}
							}
						} else {
							if λ.IsTrue(λ.Eq(ϒkind, λ.StrLiteral("captions"))) {
								ϒsubtitles = λ.Calm(ϒself, "extract_subtitles", ϒmedia, ϒprogramme_id)
							}
						}
					}
					return λ.NewTuple(
						ϒformats,
						ϒsubtitles,
					)
				})
			BBCCoUkIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdescription  λ.Object
						ϒduration     λ.Object
						ϒerror        λ.Object
						ϒformats      λ.Object
						ϒgroup_id     λ.Object
						ϒplayer       λ.Object
						ϒprogramme_id λ.Object
						ϒself         = λargs[0]
						ϒsubtitles    λ.Object
						ϒtitle        λ.Object
						ϒtviplayer    λ.Object
						ϒurl          = λargs[1]
						ϒwebpage      λ.Object
						τmp0          λ.Object
					)
					ϒgroup_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒgroup_id, λ.StrLiteral("Downloading video page"))
					ϒerror = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("<div\\b[^>]+\\bclass=[\"\\'](?:smp|playout)__message delta[\"\\'][^>]*>\\s*([^<]+?)\\s*<"),
						ϒwebpage,
						λ.StrLiteral("error"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒerror) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerror), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					ϒprogramme_id = λ.None
					ϒduration = λ.None
					ϒtviplayer = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("mediator\\.bind\\(({.+?})\\s*,\\s*document\\.getElementById"),
						ϒwebpage,
						λ.StrLiteral("player"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒtviplayer) {
						ϒplayer = λ.Calm(λ.Calm(ϒself, "_parse_json", ϒtviplayer, ϒgroup_id), "get", λ.StrLiteral("player"), λ.DictLiteral(map[λ.Object]λ.Object{}))
						ϒduration = λ.Cal(ϒint_or_none, λ.Calm(ϒplayer, "get", λ.StrLiteral("duration")))
						ϒprogramme_id = λ.Calm(ϒplayer, "get", λ.StrLiteral("vpid"))
					}
					if !λ.IsTrue(ϒprogramme_id) {
						ϒprogramme_id = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.Mod(λ.StrLiteral("\"vpid\"\\s*:\\s*\"(%s)\""), λ.GetAttr(ϒself, "_ID_REGEX", nil)),
							ϒwebpage,
							λ.StrLiteral("vpid"),
						), λ.KWArgs{
							{Name: "fatal", Value: λ.False},
							{Name: "default", Value: λ.None},
						})
					}
					if λ.IsTrue(ϒprogramme_id) {
						τmp0 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
						ϒformats = λ.GetItem(τmp0, λ.IntLiteral(0))
						ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(1))
						ϒtitle = func() λ.Object {
							if λv := λ.Call(λ.GetAttr(ϒself, "_og_search_title", nil), λ.NewArgs(ϒwebpage), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒself, "_html_search_regex", λ.NewTuple(
									λ.StrLiteral("<h2[^>]+id=\"parent-title\"[^>]*>(.+?)</h2>"),
									λ.StrLiteral("<div[^>]+class=\"info\"[^>]*>\\s*<h1>(.+?)</h1>"),
								), ϒwebpage, λ.StrLiteral("title"))
							}
						}()
						ϒdescription = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewTuple(
								λ.StrLiteral("<p class=\"[^\"]*medium-description[^\"]*\">([^<]+)</p>"),
								λ.StrLiteral("<div[^>]+class=\"info_+synopsis\"[^>]*>([^<]+)</div>"),
							),
							ϒwebpage,
							λ.StrLiteral("description"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if !λ.IsTrue(ϒdescription) {
							ϒdescription = λ.Calm(ϒself, "_html_search_meta", λ.StrLiteral("description"), ϒwebpage)
						}
					} else {
						τmp0 = λ.Calm(ϒself, "_download_playlist", ϒgroup_id)
						ϒprogramme_id = λ.GetItem(τmp0, λ.IntLiteral(0))
						ϒtitle = λ.GetItem(τmp0, λ.IntLiteral(1))
						ϒdescription = λ.GetItem(τmp0, λ.IntLiteral(2))
						ϒduration = λ.GetItem(τmp0, λ.IntLiteral(3))
						ϒformats = λ.GetItem(τmp0, λ.IntLiteral(4))
						ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(5))
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					return λ.DictLiteral(map[string]λ.Object{
						"id":          ϒprogramme_id,
						"title":       ϒtitle,
						"description": ϒdescription,
						"thumbnail": λ.Call(λ.GetAttr(ϒself, "_og_search_thumbnail", nil), λ.NewArgs(ϒwebpage), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}),
						"duration":  ϒduration,
						"formats":   ϒformats,
						"subtitles": ϒsubtitles,
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":                      BBCCoUkIE_IE_NAME,
				"MediaSelectionError":          BBCCoUkIE_MediaSelectionError,
				"_ID_REGEX":                    BBCCoUkIE__ID_REGEX,
				"_MEDIA_SELECTOR_URL_TEMPL":    BBCCoUkIE__MEDIA_SELECTOR_URL_TEMPL,
				"_MEDIA_SETS":                  BBCCoUkIE__MEDIA_SETS,
				"_NETRC_MACHINE":               BBCCoUkIE__NETRC_MACHINE,
				"_VALID_URL":                   BBCCoUkIE__VALID_URL,
				"_download_media_selector":     BBCCoUkIE__download_media_selector,
				"_download_media_selector_url": BBCCoUkIE__download_media_selector_url,
				"_extract_connections":         BBCCoUkIE__extract_connections,
				"_extract_medias":              BBCCoUkIE__extract_medias,
				"_login":                       BBCCoUkIE__login,
				"_process_media_selector":      BBCCoUkIE__process_media_selector,
				"_real_extract":                BBCCoUkIE__real_extract,
				"_real_initialize":             BBCCoUkIE__real_initialize,
			})
		}())
		BBCIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCIE"), λ.NewTuple(BBCCoUkIE), func() λ.Dict {
			var (
				BBCIE_IE_NAME       λ.Object
				BBCIE__MEDIA_SETS   λ.Object
				BBCIE__VALID_URL    λ.Object
				BBCIE__real_extract λ.Object
				BBCIE_suitable      λ.Object
			)
			BBCIE_IE_NAME = λ.StrLiteral("bbc")
			BBCIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?bbc\\.(?:com|co\\.uk)/(?:[^/]+/)+(?P<id>[^/#?]+)")
			BBCIE__MEDIA_SETS = λ.NewList(
				λ.StrLiteral("mobile-tablet-main"),
				λ.StrLiteral("pc"),
			)
			BBCIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						EXCLUDE_IE λ.Object
						ϒcls       = λargs[0]
						ϒurl       = λargs[1]
					)
					EXCLUDE_IE = λ.NewTuple(
						BBCCoUkIE,
						BBCCoUkArticleIE,
						BBCCoUkIPlayerPlaylistIE,
						BBCCoUkPlaylistIE,
					)
					return func() λ.Object {
						if λ.IsTrue(λ.Cal(λ.BuiltinAny, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒie  λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, EXCLUDE_IE)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒie = τmp1
										λgy.Yield(λ.Calm(ϒie, "suitable", ϒurl))
									}
									return λ.None
								})
							})))) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, BBCIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			BBCIE_suitable = λ.Cal(λ.ClassMethodType, BBCIE_suitable)
			BBCIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						EMBED_URL             λ.Object
						ϒbbc3_config          λ.Object
						ϒbbc3_item            λ.Object
						ϒbbc3_playlist        λ.Object
						ϒblock                λ.Object
						ϒclip                 λ.Object
						ϒclip_data            λ.Object
						ϒclip_title           λ.Object
						ϒclip_vpid            λ.Object
						ϒcomponent            λ.Object
						ϒcomponents           λ.Object
						ϒcurrent_programme    λ.Object
						ϒdata_playable        λ.Object
						ϒdata_playable_json   λ.Object
						ϒdata_playables       λ.Object
						ϒdescription          λ.Object
						ϒdigital_data         λ.Object
						ϒdisplay_date         λ.Object
						ϒduration             λ.Object
						ϒduration_d           λ.Object
						ϒembed_url            λ.Object
						ϒentries              λ.Object
						ϒentry                λ.Object
						ϒextract_all          λ.Object
						ϒformats              λ.Object
						ϒgroup_id             λ.Object
						ϒidentifiers          λ.Object
						ϒimage                λ.Object
						ϒimage_url            λ.Object
						ϒimages               λ.Object
						ϒinfo                 λ.Object
						ϒinit_data            λ.Object
						ϒinitial_data         λ.Object
						ϒitem                 λ.Object
						ϒitems                λ.Object
						ϒjson_ld_info         λ.Object
						ϒkey                  λ.Object
						ϒlead_media           λ.Object
						ϒmatch                λ.Object
						ϒmedia                λ.Object
						ϒmedia_asset          λ.Object
						ϒmedia_asset_page     λ.Object
						ϒmedia_meta           λ.Object
						ϒmedias               λ.Object
						ϒmorph_payload        λ.Object
						ϒname                 λ.Object
						ϒnetwork              λ.Object
						ϒnum                  λ.Object
						ϒpage_info            λ.Object
						ϒparse_media          λ.Object
						ϒpayload              λ.Object
						ϒplaylist             λ.Object
						ϒplaylist_description λ.Object
						ϒplaylist_id          λ.Object
						ϒplaylist_medias      λ.Object
						ϒplaylist_object      λ.Object
						ϒplaylist_title       λ.Object
						ϒplaylist_url         λ.Object
						ϒplaylists            λ.Object
						ϒpreload_state        λ.Object
						ϒprogramme_id         λ.Object
						ϒresp                 λ.Object
						ϒself                 = λargs[0]
						ϒsettings             λ.Object
						ϒsmp_data             λ.Object
						ϒsubtitles            λ.Object
						ϒsynopses             λ.Object
						ϒthumbnail            λ.Object
						ϒthumbnails           λ.Object
						ϒtimestamp            λ.Object
						ϒtitle                λ.Object
						ϒtopic_title          λ.Object
						ϒuploader             λ.Object
						ϒuploader_id          λ.Object
						ϒurl                  = λargs[1]
						ϒversion_id           λ.Object
						ϒvideo                λ.Object
						ϒvideo_id             λ.Object
						ϒvxp_playlist         λ.Object
						ϒwebpage              λ.Object
						τmp0                  λ.Object
						τmp1                  λ.Object
						τmp2                  λ.Object
						τmp3                  λ.Object
						τmp4                  λ.Object
						τmp5                  λ.Object
					)
					_ = τmp5
					ϒplaylist_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒplaylist_id)
					ϒjson_ld_info = λ.Call(λ.GetAttr(ϒself, "_search_json_ld", nil), λ.NewArgs(
						ϒwebpage,
						ϒplaylist_id,
					), λ.KWArgs{
						{Name: "default", Value: λ.DictLiteral(map[λ.Object]λ.Object{})},
					})
					ϒtimestamp = λ.Calm(ϒjson_ld_info, "get", λ.StrLiteral("timestamp"))
					ϒplaylist_title = λ.Calm(ϒjson_ld_info, "get", λ.StrLiteral("title"))
					if !λ.IsTrue(ϒplaylist_title) {
						ϒplaylist_title = func() λ.Object {
							if λv := λ.Call(λ.GetAttr(ϒself, "_og_search_title", nil), λ.NewArgs(ϒwebpage), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
									λ.StrLiteral("<title>(.+?)</title>"),
									ϒwebpage,
									λ.StrLiteral("playlist title"),
								), λ.KWArgs{
									{Name: "default", Value: λ.None},
								})
							}
						}()
						if λ.IsTrue(ϒplaylist_title) {
							ϒplaylist_title = λ.Calm(λ.Cal(Ωre.ϒsub, λ.StrLiteral("(.+)\\s*-\\s*BBC.*?$"), λ.StrLiteral("\\1"), ϒplaylist_title), "strip")
						}
					}
					ϒplaylist_description = func() λ.Object {
						if λv := λ.Calm(ϒjson_ld_info, "get", λ.StrLiteral("description")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Call(λ.GetAttr(ϒself, "_og_search_description", nil), λ.NewArgs(ϒwebpage), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})
						}
					}()
					if !λ.IsTrue(ϒtimestamp) {
						ϒtimestamp = λ.Cal(ϒparse_iso8601, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewList(
								λ.StrLiteral("<meta[^>]+property=\"article:published_time\"[^>]+content=\"([^\"]+)\""),
								λ.StrLiteral("itemprop=\"datePublished\"[^>]+datetime=\"([^\"]+)\""),
								λ.StrLiteral("\"datePublished\":\\s*\"([^\"]+)"),
							),
							ϒwebpage,
							λ.StrLiteral("date"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}))
					}
					ϒentries = λ.NewList()
					ϒplaylists = λ.Cal(Ωre.ϒfindall, λ.StrLiteral("<param[^>]+name=\"playlist\"[^>]+value=\"([^\"]+)\""), ϒwebpage)
					λ.Calm(ϒplaylists, "extend", λ.Cal(Ωre.ϒfindall, λ.StrLiteral("data-media-id=\"([^\"]+/playlist\\.sxml)\""), ϒwebpage))
					if λ.IsTrue(ϒplaylists) {
						ϒentries = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒplaylist_url λ.Object
										τmp0          λ.Object
										τmp1          λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒplaylists)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒplaylist_url = τmp1
										λgy.Yield(λ.Calm(ϒself, "_extract_from_playlist_sxml", ϒplaylist_url, ϒplaylist_id, ϒtimestamp))
									}
									return λ.None
								})
							})))
					}
					ϒdata_playables = λ.Cal(Ωre.ϒfindall, λ.StrLiteral("data-playable=([\"\\'])({.+?})\\1"), ϒwebpage)
					if λ.IsTrue(ϒdata_playables) {
						τmp0 = λ.Cal(λ.BuiltinIter, ϒdata_playables)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							τmp2 = τmp1
							_ = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒdata_playable_json = λ.GetItem(τmp2, λ.IntLiteral(1))
							ϒdata_playable = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
								λ.Cal(ϒunescapeHTML, ϒdata_playable_json),
								ϒplaylist_id,
							), λ.KWArgs{
								{Name: "fatal", Value: λ.False},
							})
							if !λ.IsTrue(ϒdata_playable) {
								continue
							}
							ϒsettings = λ.Calm(ϒdata_playable, "get", λ.StrLiteral("settings"), λ.DictLiteral(map[λ.Object]λ.Object{}))
							if λ.IsTrue(ϒsettings) {
								ϒplaylist_object = λ.Calm(ϒsettings, "get", λ.StrLiteral("playlistObject"), λ.DictLiteral(map[λ.Object]λ.Object{}))
								if λ.IsTrue(ϒplaylist_object) {
									ϒitems = λ.Calm(ϒplaylist_object, "get", λ.StrLiteral("items"))
									if λ.IsTrue(func() λ.Object {
										if λv := ϒitems; !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(λ.BuiltinIsInstance, ϒitems, λ.ListType)
										}
									}()) {
										ϒtitle = λ.GetItem(ϒplaylist_object, λ.StrLiteral("title"))
										ϒdescription = λ.Calm(ϒplaylist_object, "get", λ.StrLiteral("summary"))
										ϒduration = λ.Cal(ϒint_or_none, λ.Calm(λ.GetItem(ϒitems, λ.IntLiteral(0)), "get", λ.StrLiteral("duration")))
										ϒprogramme_id = λ.Calm(λ.GetItem(ϒitems, λ.IntLiteral(0)), "get", λ.StrLiteral("vpid"))
										τmp2 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
										ϒformats = λ.GetItem(τmp2, λ.IntLiteral(0))
										ϒsubtitles = λ.GetItem(τmp2, λ.IntLiteral(1))
										λ.Calm(ϒself, "_sort_formats", ϒformats)
										λ.Calm(ϒentries, "append", λ.DictLiteral(map[string]λ.Object{
											"id":          ϒprogramme_id,
											"title":       ϒtitle,
											"description": ϒdescription,
											"timestamp":   ϒtimestamp,
											"duration":    ϒduration,
											"formats":     ϒformats,
											"subtitles":   ϒsubtitles,
										}))
									}
								} else {
									ϒplaylist = λ.Calm(λ.Calm(ϒdata_playable, "get", λ.StrLiteral("otherSettings"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("playlist"), λ.DictLiteral(map[λ.Object]λ.Object{}))
									if λ.IsTrue(ϒplaylist) {
										ϒentry = λ.None
										τmp2 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
											λ.StrLiteral("streaming"),
											λ.StrLiteral("progressiveDownload"),
										))
										for {
											if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
												break
											}
											ϒkey = τmp3
											ϒplaylist_url = λ.Calm(ϒplaylist, "get", λ.Mod(λ.StrLiteral("%sUrl"), ϒkey))
											if !λ.IsTrue(ϒplaylist_url) {
												continue
											}
											τmp4, τmp5 = func() (λexit λ.Object, λret λ.Object) {
												defer λ.CatchMulti(
													nil,
													&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
														var ϒe λ.Object = λex
														if λ.IsTrue(func() λ.Object {
															if λv := λ.Cal(λ.BuiltinIsInstance, λ.GetAttr(ϒe, "cause", nil), ϒcompat_HTTPError); !λ.IsTrue(λv) {
																return λv
															} else {
																return λ.Eq(λ.GetAttr(λ.GetAttr(ϒe, "cause", nil), "code", nil), λ.IntLiteral(500))
															}
														}()) {
															λexit = λ.BlockExitContinue
															return
														}
														panic(λ.Raise(λex))
													}},
												)
												ϒinfo = λ.Calm(ϒself, "_extract_from_playlist_sxml", ϒplaylist_url, ϒplaylist_id, ϒtimestamp)
												if !λ.IsTrue(ϒentry) {
													ϒentry = ϒinfo
												} else {
													λ.SetItem(ϒentry, λ.StrLiteral("title"), λ.GetItem(ϒinfo, λ.StrLiteral("title")))
													λ.Calm(λ.GetItem(ϒentry, λ.StrLiteral("formats")), "extend", λ.GetItem(ϒinfo, λ.StrLiteral("formats")))
												}
												return λ.BlockExitNormally, nil
											}()
											if τmp4 == λ.BlockExitContinue {
												continue
											}
										}
										if λ.IsTrue(ϒentry) {
											λ.Calm(ϒself, "_sort_formats", λ.GetItem(ϒentry, λ.StrLiteral("formats")))
											λ.Calm(ϒentries, "append", ϒentry)
										}
									}
								}
							}
						}
					}
					if λ.IsTrue(ϒentries) {
						return λ.Calm(ϒself, "playlist_result", ϒentries, ϒplaylist_id, ϒplaylist_title, ϒplaylist_description)
					}
					ϒgroup_id = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.Mod(λ.StrLiteral("<div[^>]+\\bclass=[\"\\']video[\"\\'][^>]+\\bdata-pid=[\"\\'](%s)"), λ.GetAttr(ϒself, "_ID_REGEX", nil)),
						ϒwebpage,
						λ.StrLiteral("group id"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒgroup_id) {
						return λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(λ.Mod(λ.StrLiteral("https://www.bbc.co.uk/programmes/%s"), ϒgroup_id)), λ.KWArgs{
							{Name: "ie", Value: λ.Calm(BBCCoUkIE, "ie_key")},
						})
					}
					ϒprogramme_id = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewList(
							λ.Mod(λ.StrLiteral("data-(?:video-player|media)-vpid=\"(%s)\""), λ.GetAttr(ϒself, "_ID_REGEX", nil)),
							λ.Mod(λ.StrLiteral("<param[^>]+name=\"externalIdentifier\"[^>]+value=\"(%s)\""), λ.GetAttr(ϒself, "_ID_REGEX", nil)),
							λ.Mod(λ.StrLiteral("videoId\\s*:\\s*[\"\\'](%s)[\"\\']"), λ.GetAttr(ϒself, "_ID_REGEX", nil)),
						),
						ϒwebpage,
						λ.StrLiteral("vpid"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒprogramme_id) {
						τmp0 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
						ϒformats = λ.GetItem(τmp0, λ.IntLiteral(0))
						ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(1))
						λ.Calm(ϒself, "_sort_formats", ϒformats)
						ϒdigital_data = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("var\\s+digitalData\\s*=\\s*({.+?});?\\n"),
								ϒwebpage,
								λ.StrLiteral("digital data"),
							), λ.KWArgs{
								{Name: "default", Value: λ.StrLiteral("{}")},
							}),
							ϒprogramme_id,
						), λ.KWArgs{
							{Name: "fatal", Value: λ.False},
						})
						ϒpage_info = λ.Calm(λ.Calm(ϒdigital_data, "get", λ.StrLiteral("page"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("pageInfo"), λ.DictLiteral(map[λ.Object]λ.Object{}))
						ϒtitle = func() λ.Object {
							if λv := λ.Calm(ϒpage_info, "get", λ.StrLiteral("pageName")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒself, "_og_search_title", ϒwebpage)
							}
						}()
						ϒdescription = func() λ.Object {
							if λv := λ.Calm(ϒpage_info, "get", λ.StrLiteral("description")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒself, "_og_search_description", ϒwebpage)
							}
						}()
						ϒtimestamp = func() λ.Object {
							if λv := λ.Cal(ϒparse_iso8601, λ.Calm(ϒpage_info, "get", λ.StrLiteral("publicationDate"))); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒtimestamp
							}
						}()
						return λ.DictLiteral(map[string]λ.Object{
							"id":          ϒprogramme_id,
							"title":       ϒtitle,
							"description": ϒdescription,
							"timestamp":   ϒtimestamp,
							"formats":     ϒformats,
							"subtitles":   ϒsubtitles,
						})
					}
					ϒinitial_data = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("<script[^>]+id=([\"\\'])initial-data\\1[^>]+data-json=([\"\\'])(?P<json>(?:(?!\\2).)+)"),
							ϒwebpage,
							λ.StrLiteral("initial data"),
						), λ.KWArgs{
							{Name: "default", Value: λ.StrLiteral("{}")},
							{Name: "group", Value: λ.StrLiteral("json")},
						}),
						ϒplaylist_id,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(ϒinitial_data) {
						ϒinit_data = func() λ.Object {
							if λv := λ.Cal(ϒtry_get, ϒinitial_data, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("initData")), λ.StrLiteral("items")), λ.IntLiteral(0))
								}), λ.DictType); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}()
						ϒsmp_data = func() λ.Object {
							if λv := λ.Calm(ϒinit_data, "get", λ.StrLiteral("smpData")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}()
						ϒclip_data = func() λ.Object {
							if λv := λ.Cal(ϒtry_get, ϒsmp_data, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("items")), λ.IntLiteral(0))
								}), λ.DictType); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}()
						ϒversion_id = λ.Calm(ϒclip_data, "get", λ.StrLiteral("versionID"))
						if λ.IsTrue(ϒversion_id) {
							ϒtitle = λ.GetItem(ϒsmp_data, λ.StrLiteral("title"))
							τmp0 = λ.Calm(ϒself, "_download_media_selector", ϒversion_id)
							ϒformats = λ.GetItem(τmp0, λ.IntLiteral(0))
							ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(1))
							λ.Calm(ϒself, "_sort_formats", ϒformats)
							ϒimage_url = λ.Calm(ϒsmp_data, "get", λ.StrLiteral("holdingImageURL"))
							ϒdisplay_date = λ.Calm(ϒinit_data, "get", λ.StrLiteral("displayDate"))
							ϒtopic_title = λ.Calm(ϒinit_data, "get", λ.StrLiteral("topicTitle"))
							return λ.DictLiteral(map[string]λ.Object{
								"id":        ϒversion_id,
								"title":     ϒtitle,
								"formats":   ϒformats,
								"alt_title": λ.Calm(ϒinit_data, "get", λ.StrLiteral("shortTitle")),
								"thumbnail": func() λ.Object {
									if λ.IsTrue(ϒimage_url) {
										return λ.Calm(ϒimage_url, "replace", λ.StrLiteral("$recipe"), λ.StrLiteral("raw"))
									} else {
										return λ.None
									}
								}(),
								"description": func() λ.Object {
									if λv := λ.Calm(ϒsmp_data, "get", λ.StrLiteral("summary")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒinit_data, "get", λ.StrLiteral("shortSummary"))
									}
								}(),
								"upload_date": func() λ.Object {
									if λ.IsTrue(ϒdisplay_date) {
										return λ.Calm(ϒdisplay_date, "replace", λ.StrLiteral("-"), λ.StrLiteral(""))
									} else {
										return λ.None
									}
								}(),
								"subtitles": ϒsubtitles,
								"duration":  λ.Cal(ϒint_or_none, λ.Calm(ϒclip_data, "get", λ.StrLiteral("duration"))),
								"categories": func() λ.Object {
									if λ.IsTrue(ϒtopic_title) {
										return λ.NewList(ϒtopic_title)
									} else {
										return λ.None
									}
								}(),
							})
						}
					}
					ϒmorph_payload = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("Morph\\.setPayload\\([^,]+,\\s*({.+?})\\);"),
							ϒwebpage,
							λ.StrLiteral("morph payload"),
						), λ.KWArgs{
							{Name: "default", Value: λ.StrLiteral("{}")},
						}),
						ϒplaylist_id,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(ϒmorph_payload) {
						ϒcomponents = func() λ.Object {
							if λv := λ.Cal(ϒtry_get, ϒmorph_payload, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("body")), λ.StrLiteral("components"))
								}), λ.ListType); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewList()
							}
						}()
						τmp0 = λ.Cal(λ.BuiltinIter, ϒcomponents)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒcomponent = τmp1
							if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒcomponent, λ.DictType)) {
								continue
							}
							ϒlead_media = λ.Cal(ϒtry_get, ϒcomponent, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("props")), λ.StrLiteral("leadMedia"))
								}), λ.DictType)
							if !λ.IsTrue(ϒlead_media) {
								continue
							}
							ϒidentifiers = λ.Calm(ϒlead_media, "get", λ.StrLiteral("identifiers"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(!λ.IsTrue(ϒidentifiers)); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒidentifiers, λ.DictType)))
								}
							}()) {
								continue
							}
							ϒprogramme_id = func() λ.Object {
								if λv := λ.Calm(ϒidentifiers, "get", λ.StrLiteral("vpid")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒidentifiers, "get", λ.StrLiteral("playablePid"))
								}
							}()
							if !λ.IsTrue(ϒprogramme_id) {
								continue
							}
							ϒtitle = func() λ.Object {
								if λv := λ.Calm(ϒlead_media, "get", λ.StrLiteral("title")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒself, "_og_search_title", ϒwebpage)
								}
							}()
							τmp2 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
							ϒformats = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒsubtitles = λ.GetItem(τmp2, λ.IntLiteral(1))
							λ.Calm(ϒself, "_sort_formats", ϒformats)
							ϒdescription = λ.Calm(ϒlead_media, "get", λ.StrLiteral("summary"))
							ϒuploader = λ.Calm(ϒlead_media, "get", λ.StrLiteral("masterBrand"))
							ϒuploader_id = λ.Calm(ϒlead_media, "get", λ.StrLiteral("mid"))
							ϒduration = λ.None
							ϒduration_d = λ.Calm(ϒlead_media, "get", λ.StrLiteral("duration"))
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒduration_d, λ.DictType)) {
								ϒduration = λ.Cal(ϒparse_duration, λ.Cal(ϒdict_get, ϒduration_d, λ.NewTuple(
									λ.StrLiteral("rawDuration"),
									λ.StrLiteral("formattedDuration"),
									λ.StrLiteral("spokenDuration"),
								)))
							}
							return λ.DictLiteral(map[string]λ.Object{
								"id":          ϒprogramme_id,
								"title":       ϒtitle,
								"description": ϒdescription,
								"duration":    ϒduration,
								"uploader":    ϒuploader,
								"uploader_id": ϒuploader_id,
								"formats":     ϒformats,
								"subtitles":   ϒsubtitles,
							})
						}
					}
					ϒpreload_state = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("window\\.__PRELOADED_STATE__\\s*=\\s*({.+?});"),
							ϒwebpage,
							λ.StrLiteral("preload state"),
						), λ.KWArgs{
							{Name: "default", Value: λ.StrLiteral("{}")},
						}),
						ϒplaylist_id,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(ϒpreload_state) {
						ϒcurrent_programme = func() λ.Object {
							if λv := λ.Calm(λ.Calm(ϒpreload_state, "get", λ.StrLiteral("programmes"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("current")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}()
						ϒprogramme_id = λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("id"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒcurrent_programme; !λ.IsTrue(λv) {
								return λv
							} else if λv := ϒprogramme_id; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("type")), λ.StrLiteral("playable_item"))
							}
						}()) {
							ϒtitle = func() λ.Object {
								if λv := λ.Calm(λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("titles"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("tertiary")); λ.IsTrue(λv) {
									return λv
								} else {
									return ϒplaylist_title
								}
							}()
							τmp0 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
							ϒformats = λ.GetItem(τmp0, λ.IntLiteral(0))
							ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(1))
							λ.Calm(ϒself, "_sort_formats", ϒformats)
							ϒsynopses = func() λ.Object {
								if λv := λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("synopses")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.DictLiteral(map[λ.Object]λ.Object{})
								}
							}()
							ϒnetwork = func() λ.Object {
								if λv := λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("network")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.DictLiteral(map[λ.Object]λ.Object{})
								}
							}()
							ϒduration = λ.Cal(ϒint_or_none, λ.Calm(λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("duration"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("value")))
							ϒthumbnail = λ.None
							ϒimage_url = λ.Calm(ϒcurrent_programme, "get", λ.StrLiteral("image_url"))
							if λ.IsTrue(ϒimage_url) {
								ϒthumbnail = λ.Calm(ϒimage_url, "replace", λ.StrLiteral("{recipe}"), λ.StrLiteral("raw"))
							}
							return λ.DictLiteral(map[string]λ.Object{
								"id":    ϒprogramme_id,
								"title": ϒtitle,
								"description": λ.Cal(ϒdict_get, ϒsynopses, λ.NewTuple(
									λ.StrLiteral("long"),
									λ.StrLiteral("medium"),
									λ.StrLiteral("short"),
								)),
								"thumbnail":   ϒthumbnail,
								"duration":    ϒduration,
								"uploader":    λ.Calm(ϒnetwork, "get", λ.StrLiteral("short_title")),
								"uploader_id": λ.Calm(ϒnetwork, "get", λ.StrLiteral("id")),
								"formats":     ϒformats,
								"subtitles":   ϒsubtitles,
							})
						}
					}
					ϒbbc3_config = func() λ.Object {
						if λv := λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("(?s)bbcthreeConfig\\s*=\\s*({.+?})\\s*;\\s*<"),
								ϒwebpage,
								λ.StrLiteral("bbcthree config"),
							), λ.KWArgs{
								{Name: "default", Value: λ.StrLiteral("{}")},
							}),
							ϒplaylist_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒjs_to_json},
							{Name: "fatal", Value: λ.False},
						}); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}()
					ϒpayload = func() λ.Object {
						if λv := λ.Calm(ϒbbc3_config, "get", λ.StrLiteral("payload")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}()
					if λ.IsTrue(ϒpayload) {
						ϒclip = func() λ.Object {
							if λv := λ.Calm(ϒpayload, "get", λ.StrLiteral("currentClip")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}()
						ϒclip_vpid = λ.Calm(ϒclip, "get", λ.StrLiteral("vpid"))
						ϒclip_title = λ.Calm(ϒclip, "get", λ.StrLiteral("title"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒclip_vpid; !λ.IsTrue(λv) {
								return λv
							} else {
								return ϒclip_title
							}
						}()) {
							τmp0 = λ.Calm(ϒself, "_download_media_selector", ϒclip_vpid)
							ϒformats = λ.GetItem(τmp0, λ.IntLiteral(0))
							ϒsubtitles = λ.GetItem(τmp0, λ.IntLiteral(1))
							λ.Calm(ϒself, "_sort_formats", ϒformats)
							return λ.DictLiteral(map[string]λ.Object{
								"id":    ϒclip_vpid,
								"title": ϒclip_title,
								"thumbnail": λ.Cal(ϒdict_get, ϒclip, λ.NewTuple(
									λ.StrLiteral("poster"),
									λ.StrLiteral("imageUrl"),
								)),
								"description": λ.Calm(ϒclip, "get", λ.StrLiteral("description")),
								"duration":    λ.Cal(ϒparse_duration, λ.Calm(ϒclip, "get", λ.StrLiteral("duration"))),
								"formats":     ϒformats,
								"subtitles":   ϒsubtitles,
							})
						}
						ϒbbc3_playlist = λ.Cal(ϒtry_get, ϒpayload, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("content")), λ.StrLiteral("bbcMedia")), λ.StrLiteral("playlist"))
							}), λ.DictType)
						if λ.IsTrue(ϒbbc3_playlist) {
							ϒplaylist_title = func() λ.Object {
								if λv := λ.Calm(ϒbbc3_playlist, "get", λ.StrLiteral("title")); λ.IsTrue(λv) {
									return λv
								} else {
									return ϒplaylist_title
								}
							}()
							ϒthumbnail = λ.Calm(ϒbbc3_playlist, "get", λ.StrLiteral("holdingImageURL"))
							ϒentries = λ.NewList()
							τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒbbc3_playlist, λ.StrLiteral("items")))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒbbc3_item = τmp1
								ϒprogramme_id = λ.Calm(ϒbbc3_item, "get", λ.StrLiteral("versionID"))
								if !λ.IsTrue(ϒprogramme_id) {
									continue
								}
								τmp2 = λ.Calm(ϒself, "_download_media_selector", ϒprogramme_id)
								ϒformats = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒsubtitles = λ.GetItem(τmp2, λ.IntLiteral(1))
								λ.Calm(ϒself, "_sort_formats", ϒformats)
								λ.Calm(ϒentries, "append", λ.DictLiteral(map[string]λ.Object{
									"id":        ϒprogramme_id,
									"title":     ϒplaylist_title,
									"thumbnail": ϒthumbnail,
									"timestamp": ϒtimestamp,
									"formats":   ϒformats,
									"subtitles": ϒsubtitles,
								}))
							}
							return λ.Calm(ϒself, "playlist_result", ϒentries, ϒplaylist_id, ϒplaylist_title, ϒplaylist_description)
						}
					}
					ϒinitial_data = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
						λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("window\\.__INITIAL_DATA__\\s*=\\s*({.+?});"),
							ϒwebpage,
							λ.StrLiteral("preload state"),
						), λ.KWArgs{
							{Name: "default", Value: λ.StrLiteral("{}")},
						}),
						ϒplaylist_id,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if λ.IsTrue(ϒinitial_data) {
						ϒparse_media = λ.NewFunction("parse_media",
							[]λ.Param{
								{Name: "media"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒformats    λ.Object
									ϒitem       λ.Object
									ϒitem_id    λ.Object
									ϒitem_title λ.Object
									ϒmedia      = λargs[0]
									ϒsubtitles  λ.Object
									τmp0        λ.Object
									τmp1        λ.Object
									τmp2        λ.Object
								)
								if !λ.IsTrue(ϒmedia) {
									return λ.None
								}
								τmp0 = λ.Cal(λ.BuiltinIter, func() λ.Object {
									if λv := λ.Cal(ϒtry_get, ϒmedia, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("media")), λ.StrLiteral("items"))
										}), λ.ListType); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewList()
									}
								}())
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒitem = τmp1
									ϒitem_id = λ.Calm(ϒitem, "get", λ.StrLiteral("id"))
									ϒitem_title = λ.Calm(ϒitem, "get", λ.StrLiteral("title"))
									if !λ.IsTrue(func() λ.Object {
										if λv := ϒitem_id; !λ.IsTrue(λv) {
											return λv
										} else {
											return ϒitem_title
										}
									}()) {
										continue
									}
									τmp2 = λ.Calm(ϒself, "_download_media_selector", ϒitem_id)
									ϒformats = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒsubtitles = λ.GetItem(τmp2, λ.IntLiteral(1))
									λ.Calm(ϒself, "_sort_formats", ϒformats)
									λ.Calm(ϒentries, "append", λ.DictLiteral(map[string]λ.Object{
										"id":        ϒitem_id,
										"title":     ϒitem_title,
										"thumbnail": λ.Calm(ϒitem, "get", λ.StrLiteral("holdingImageUrl")),
										"formats":   ϒformats,
										"subtitles": ϒsubtitles,
									}))
								}
								return λ.None
							})
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(func() λ.Object {
							if λv := λ.Calm(ϒinitial_data, "get", λ.StrLiteral("data")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}(), "values"))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒresp = τmp1
							ϒname = λ.Calm(ϒresp, "get", λ.StrLiteral("name"))
							if λ.IsTrue(λ.Eq(ϒname, λ.StrLiteral("media-experience"))) {
								λ.Cal(ϒparse_media, λ.Cal(ϒtry_get, ϒresp, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("data")), λ.StrLiteral("initialItem")), λ.StrLiteral("mediaItem"))
									}), λ.DictType))
							} else {
								if λ.IsTrue(λ.Eq(ϒname, λ.StrLiteral("article"))) {
									τmp2 = λ.Cal(λ.BuiltinIter, func() λ.Object {
										if λv := λ.Cal(ϒtry_get, ϒresp, λ.NewFunction("<lambda>",
											[]λ.Param{
												{Name: "x"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒx = λargs[0]
												)
												return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("data")), λ.StrLiteral("blocks"))
											}), λ.ListType); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewList()
										}
									}())
									for {
										if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
											break
										}
										ϒblock = τmp3
										if λ.IsTrue(λ.Ne(λ.Calm(ϒblock, "get", λ.StrLiteral("type")), λ.StrLiteral("media"))) {
											continue
										}
										λ.Cal(ϒparse_media, λ.Calm(ϒblock, "get", λ.StrLiteral("model")))
									}
								}
							}
						}
						return λ.Calm(ϒself, "playlist_result", ϒentries, ϒplaylist_id, ϒplaylist_title, ϒplaylist_description)
					}
					ϒextract_all = λ.NewFunction("extract_all",
						[]λ.Param{
							{Name: "pattern"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒpattern = λargs[0]
							)
							return λ.Cal(λ.ListType, λ.Cal(λ.FilterIteratorType, λ.None, λ.Cal(λ.MapIteratorType, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "s"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒs = λargs[0]
									)
									return λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
										ϒs,
										ϒplaylist_id,
									), λ.KWArgs{
										{Name: "fatal", Value: λ.False},
									})
								}), λ.Cal(Ωre.ϒfindall, ϒpattern, ϒwebpage))))
						})
					EMBED_URL = λ.Mod(λ.StrLiteral("https?://(?:www\\.)?bbc\\.co\\.uk/(?:[^/]+/)+%s(?:\\b[^\"]+)?"), λ.GetAttr(ϒself, "_ID_REGEX", nil))
					ϒentries = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(ϒextract_all, λ.StrLiteral("new\\s+SMP\\(({.+?})\\)")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmatch = τmp1
						ϒembed_url = λ.Calm(λ.Calm(ϒmatch, "get", λ.StrLiteral("playerSettings"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("externalEmbedUrl"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒembed_url; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(Ωre.ϒmatch, EMBED_URL, ϒembed_url)
							}
						}()) {
							λ.Calm(ϒentries, "append", ϒembed_url)
						}
					}
					λ.Calm(ϒentries, "extend", λ.Cal(Ωre.ϒfindall, λ.Mod(λ.StrLiteral("setPlaylist\\(\"(%s)\"\\)"), EMBED_URL), ϒwebpage))
					if λ.IsTrue(ϒentries) {
						return λ.Calm(ϒself, "playlist_result", λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒentry_ λ.Object
										τmp0    λ.Object
										τmp1    λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒentries)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒentry_ = τmp1
										λgy.Yield(λ.Calm(ϒself, "url_result", ϒentry_, λ.StrLiteral("BBCCoUk")))
									}
									return λ.None
								})
							}))), ϒplaylist_id, ϒplaylist_title, ϒplaylist_description)
					}
					ϒmedias = λ.Cal(ϒextract_all, λ.StrLiteral("data-media-meta='({[^']+})'"))
					if !λ.IsTrue(ϒmedias) {
						ϒmedia_asset = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("mediaAssetPage\\.init\\(\\s*({.+?}), \"/"),
							ϒwebpage,
							λ.StrLiteral("media asset"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if λ.IsTrue(ϒmedia_asset) {
							ϒmedia_asset_page = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
								ϒmedia_asset,
								ϒplaylist_id,
							), λ.KWArgs{
								{Name: "fatal", Value: λ.False},
							})
							ϒmedias = λ.NewList()
							τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(λ.Calm(ϒmedia_asset_page, "get", λ.StrLiteral("videos"), λ.DictLiteral(map[λ.Object]λ.Object{})), "values"))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒvideo = τmp1
								λ.Calm(ϒmedias, "extend", λ.Calm(ϒvideo, "values"))
							}
						}
					}
					if !λ.IsTrue(ϒmedias) {
						ϒvxp_playlist = λ.Calm(ϒself, "_parse_json", λ.Calm(ϒself, "_search_regex", λ.StrLiteral("<script[^>]+class=\"vxp-playlist-data\"[^>]+type=\"application/json\"[^>]*>([^<]+)</script>"), ϒwebpage, λ.StrLiteral("playlist data")), ϒplaylist_id)
						ϒplaylist_medias = λ.NewList()
						τmp0 = λ.Cal(λ.BuiltinIter, ϒvxp_playlist)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒitem = τmp1
							ϒmedia = λ.Calm(ϒitem, "get", λ.StrLiteral("media"))
							if !λ.IsTrue(ϒmedia) {
								continue
							}
							λ.Calm(ϒplaylist_medias, "append", ϒmedia)
							if λ.IsTrue(λ.Eq(λ.Calm(λ.Calm(ϒitem, "get", λ.StrLiteral("advert"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("assetId")), ϒplaylist_id)) {
								ϒmedias = λ.NewList(ϒmedia)
								break
							}
						}
						if !λ.IsTrue(ϒmedias) {
							ϒmedias = ϒplaylist_medias
						}
					}
					ϒentries = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Call(λ.EnumerateIteratorType, λ.NewArgs(ϒmedias), λ.KWArgs{
						{Name: "start", Value: λ.IntLiteral(1)},
					}))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒnum = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒmedia_meta = λ.GetItem(τmp2, λ.IntLiteral(1))
						τmp2 = λ.Calm(ϒself, "_extract_from_media_meta", ϒmedia_meta, ϒplaylist_id)
						ϒformats = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒsubtitles = λ.GetItem(τmp2, λ.IntLiteral(1))
						if !λ.IsTrue(ϒformats) {
							continue
						}
						λ.Calm(ϒself, "_sort_formats", ϒformats)
						ϒvideo_id = λ.Calm(ϒmedia_meta, "get", λ.StrLiteral("externalId"))
						if !λ.IsTrue(ϒvideo_id) {
							ϒvideo_id = func() λ.Object {
								if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒmedias), λ.IntLiteral(1))) {
									return ϒplaylist_id
								} else {
									return λ.Mod(λ.StrLiteral("%s-%s"), λ.NewTuple(
										ϒplaylist_id,
										ϒnum,
									))
								}
							}()
						}
						ϒtitle = λ.Calm(ϒmedia_meta, "get", λ.StrLiteral("caption"))
						if !λ.IsTrue(ϒtitle) {
							ϒtitle = func() λ.Object {
								if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒmedias), λ.IntLiteral(1))) {
									return ϒplaylist_title
								} else {
									return λ.Mod(λ.StrLiteral("%s - Video %s"), λ.NewTuple(
										ϒplaylist_title,
										ϒnum,
									))
								}
							}()
						}
						ϒduration = func() λ.Object {
							if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒmedia_meta, "get", λ.StrLiteral("durationInSeconds"))); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(ϒparse_duration, λ.Calm(ϒmedia_meta, "get", λ.StrLiteral("duration")))
							}
						}()
						ϒimages = λ.NewList()
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(λ.Calm(ϒmedia_meta, "get", λ.StrLiteral("images"), λ.DictLiteral(map[λ.Object]λ.Object{})), "values"))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒimage = τmp3
							λ.Calm(ϒimages, "extend", λ.Calm(ϒimage, "values"))
						}
						if λ.Contains(ϒmedia_meta, λ.StrLiteral("image")) {
							λ.Calm(ϒimages, "append", λ.GetItem(ϒmedia_meta, λ.StrLiteral("image")))
						}
						ϒthumbnails = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒimage λ.Object
										τmp0   λ.Object
										τmp1   λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒimages)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒimage = τmp1
										λgy.Yield(λ.DictLiteral(map[string]λ.Object{
											"url":    λ.Calm(ϒimage, "get", λ.StrLiteral("href")),
											"width":  λ.Cal(ϒint_or_none, λ.Calm(ϒimage, "get", λ.StrLiteral("width"))),
											"height": λ.Cal(ϒint_or_none, λ.Calm(ϒimage, "get", λ.StrLiteral("height"))),
										}))
									}
									return λ.None
								})
							})))
						λ.Calm(ϒentries, "append", λ.DictLiteral(map[string]λ.Object{
							"id":         ϒvideo_id,
							"title":      ϒtitle,
							"thumbnails": ϒthumbnails,
							"duration":   ϒduration,
							"timestamp":  ϒtimestamp,
							"formats":    ϒformats,
							"subtitles":  ϒsubtitles,
						}))
					}
					return λ.Calm(ϒself, "playlist_result", ϒentries, ϒplaylist_id, ϒplaylist_title, ϒplaylist_description)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       BBCIE_IE_NAME,
				"_MEDIA_SETS":   BBCIE__MEDIA_SETS,
				"_VALID_URL":    BBCIE__VALID_URL,
				"_real_extract": BBCIE__real_extract,
				"suitable":      BBCIE_suitable,
			})
		}())
		BBCCoUkArticleIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCCoUkArticleIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				BBCCoUkArticleIE__VALID_URL λ.Object
			)
			BBCCoUkArticleIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?bbc\\.co\\.uk/programmes/articles/(?P<id>[a-zA-Z0-9]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": BBCCoUkArticleIE__VALID_URL,
			})
		}())
		BBCCoUkPlaylistBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCCoUkPlaylistBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		BBCCoUkIPlayerPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCCoUkIPlayerPlaylistIE"), λ.NewTuple(BBCCoUkPlaylistBaseIE), func() λ.Dict {
			var (
				BBCCoUkIPlayerPlaylistIE__VALID_URL λ.Object
			)
			BBCCoUkIPlayerPlaylistIE__VALID_URL = λ.Mod(λ.StrLiteral("https?://(?:www\\.)?bbc\\.co\\.uk/iplayer/(?:episodes|group)/(?P<id>%s)"), λ.GetAttr(BBCCoUkIE, "_ID_REGEX", nil))
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": BBCCoUkIPlayerPlaylistIE__VALID_URL,
			})
		}())
		BBCCoUkPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("BBCCoUkPlaylistIE"), λ.NewTuple(BBCCoUkPlaylistBaseIE), func() λ.Dict {
			var (
				BBCCoUkPlaylistIE__VALID_URL λ.Object
			)
			BBCCoUkPlaylistIE__VALID_URL = λ.Mod(λ.StrLiteral("https?://(?:www\\.)?bbc\\.co\\.uk/programmes/(?P<id>%s)/(?:episodes|broadcasts|clips)"), λ.GetAttr(BBCCoUkIE, "_ID_REGEX", nil))
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": BBCCoUkPlaylistIE__VALID_URL,
			})
		}())
	})
}
