// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * daum/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/daum.py
 */

package daum

import (
	Ωitertools "github.com/tenta-browser/go-video-downloader/gen/itertools"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	DaumBaseIE                   λ.Object
	DaumClipIE                   λ.Object
	DaumIE                       λ.Object
	DaumListIE                   λ.Object
	DaumPlaylistIE               λ.Object
	DaumUserIE                   λ.Object
	InfoExtractor                λ.Object
	ϒcompat_parse_qs             λ.Object
	ϒcompat_urllib_parse_unquote λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_parse_qs = Ωcompat.ϒcompat_parse_qs
		ϒcompat_urllib_parse_unquote = Ωcompat.ϒcompat_urllib_parse_unquote
		DaumBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				DaumBaseIE__KAKAO_EMBED_BASE λ.Object
			)
			DaumBaseIE__KAKAO_EMBED_BASE = λ.StrLiteral("http://tv.kakao.com/embed/player/cliplink/")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_KAKAO_EMBED_BASE": DaumBaseIE__KAKAO_EMBED_BASE,
			})
		}())
		DaumIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumIE"), λ.NewTuple(DaumBaseIE), func() λ.Dict {
			var (
				DaumIE_IE_NAME       λ.Object
				DaumIE__VALID_URL    λ.Object
				DaumIE__real_extract λ.Object
			)
			DaumIE__VALID_URL = λ.StrLiteral("https?://(?:(?:m\\.)?tvpot\\.daum\\.net/v/|videofarm\\.daum\\.net/controller/player/VodPlayer\\.swf\\?vid=)(?P<id>[^?#&]+)")
			DaumIE_IE_NAME = λ.StrLiteral("daum.net")
			DaumIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself     = λargs[0]
						ϒurl      = λargs[1]
						ϒvideo_id λ.Object
						τmp0      λ.Object
					)
					ϒvideo_id = λ.Cal(ϒcompat_urllib_parse_unquote, λ.Calm(ϒself, "_match_id", ϒurl))
					if !λ.IsTrue(λ.Calm(ϒvideo_id, "isdigit")) {
						τmp0 = λ.IAdd(ϒvideo_id, λ.StrLiteral("@my"))
						ϒvideo_id = τmp0
					}
					return λ.Calm(ϒself, "url_result", λ.Add(λ.GetAttr(ϒself, "_KAKAO_EMBED_BASE", nil), ϒvideo_id), λ.StrLiteral("Kakao"), ϒvideo_id)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       DaumIE_IE_NAME,
				"_VALID_URL":    DaumIE__VALID_URL,
				"_real_extract": DaumIE__real_extract,
			})
		}())
		DaumClipIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumClipIE"), λ.NewTuple(DaumBaseIE), func() λ.Dict {
			var (
				DaumClipIE_IE_NAME       λ.Object
				DaumClipIE__URL_TEMPLATE λ.Object
				DaumClipIE__VALID_URL    λ.Object
				DaumClipIE__real_extract λ.Object
				DaumClipIE_suitable      λ.Object
			)
			DaumClipIE__VALID_URL = λ.StrLiteral("https?://(?:m\\.)?tvpot\\.daum\\.net/(?:clip/ClipView.(?:do|tv)|mypot/View.do)\\?.*?clipid=(?P<id>\\d+)")
			DaumClipIE_IE_NAME = λ.StrLiteral("daum.net:clip")
			DaumClipIE__URL_TEMPLATE = λ.StrLiteral("http://tvpot.daum.net/clip/ClipView.do?clipid=%s")
			DaumClipIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(DaumPlaylistIE, "suitable", ϒurl); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(DaumUserIE, "suitable", ϒurl)
							}
						}()) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, DaumClipIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			DaumClipIE_suitable = λ.Cal(λ.ClassMethodType, DaumClipIE_suitable)
			DaumClipIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself     = λargs[0]
						ϒurl      = λargs[1]
						ϒvideo_id λ.Object
					)
					ϒvideo_id = λ.Calm(ϒself, "_match_id", ϒurl)
					return λ.Calm(ϒself, "url_result", λ.Add(λ.GetAttr(ϒself, "_KAKAO_EMBED_BASE", nil), ϒvideo_id), λ.StrLiteral("Kakao"), ϒvideo_id)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       DaumClipIE_IE_NAME,
				"_URL_TEMPLATE": DaumClipIE__URL_TEMPLATE,
				"_VALID_URL":    DaumClipIE__VALID_URL,
				"_real_extract": DaumClipIE__real_extract,
				"suitable":      DaumClipIE_suitable,
			})
		}())
		DaumListIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumListIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				DaumListIE__check_clip  λ.Object
				DaumListIE__get_entries λ.Object
			)
			DaumListIE__get_entries = λ.NewFunction("_get_entries",
				[]λ.Param{
					{Name: "self"},
					{Name: "list_id"},
					{Name: "list_id_type"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentries      λ.Object
						ϒlist_id      = λargs[1]
						ϒlist_id_type = λargs[2]
						ϒlist_info    λ.Object
						ϒname         λ.Object
						ϒpagenum      λ.Object
						ϒself         = λargs[0]
						τmp0          λ.Object
						τmp1          λ.Object
					)
					ϒname = λ.None
					ϒentries = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωitertools.ϒcount, λ.IntLiteral(1)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒpagenum = τmp1
						ϒlist_info = λ.Calm(ϒself, "_download_json", λ.Mod(λ.StrLiteral("http://tvpot.daum.net/mypot/json/GetClipInfo.do?size=48&init=true&order=date&page=%d&%s=%s"), λ.NewTuple(
							ϒpagenum,
							ϒlist_id_type,
							ϒlist_id,
						)), ϒlist_id, λ.Mod(λ.StrLiteral("Downloading list info - %s"), ϒpagenum))
						λ.Calm(ϒentries, "extend", λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒclip λ.Object
										τmp0  λ.Object
										τmp1  λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒlist_info, λ.StrLiteral("clip_list")))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒclip = τmp1
										λgy.Yield(λ.Calm(ϒself, "url_result", λ.Mod(λ.StrLiteral("http://tvpot.daum.net/v/%s"), λ.GetItem(ϒclip, λ.StrLiteral("vid")))))
									}
									return λ.None
								})
							}))))
						if !λ.IsTrue(ϒname) {
							ϒname = func() λ.Object {
								if λv := λ.Calm(λ.Calm(ϒlist_info, "get", λ.StrLiteral("playlist_bean"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("name")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(λ.Calm(ϒlist_info, "get", λ.StrLiteral("potInfo"), λ.DictLiteral(map[λ.Object]λ.Object{})), "get", λ.StrLiteral("name"))
								}
							}()
						}
						if !λ.IsTrue(λ.Calm(ϒlist_info, "get", λ.StrLiteral("has_more"))) {
							break
						}
					}
					return λ.NewTuple(
						ϒname,
						ϒentries,
					)
				})
			DaumListIE__check_clip = λ.NewFunction("_check_clip",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "list_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒclip_id    λ.Object
						ϒlist_id    = λargs[2]
						ϒquery_dict λ.Object
						ϒself       = λargs[0]
						ϒurl        = λargs[1]
					)
					ϒquery_dict = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(λ.Cal(Ωparse.ϒurlparse, ϒurl), "query", nil))
					if λ.Contains(ϒquery_dict, λ.StrLiteral("clipid")) {
						ϒclip_id = λ.GetItem(λ.GetItem(ϒquery_dict, λ.StrLiteral("clipid")), λ.IntLiteral(0))
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("noplaylist"))) {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading just video %s because of --no-playlist"), ϒclip_id))
							return λ.Calm(ϒself, "url_result", λ.Mod(λ.GetAttr(DaumClipIE, "_URL_TEMPLATE", nil), ϒclip_id), λ.StrLiteral("DaumClip"))
						} else {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading playlist %s - add --no-playlist to just download video"), ϒlist_id))
						}
					}
					return λ.None
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_check_clip":  DaumListIE__check_clip,
				"_get_entries": DaumListIE__get_entries,
			})
		}())
		DaumPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumPlaylistIE"), λ.NewTuple(DaumListIE), func() λ.Dict {
			var (
				DaumPlaylistIE_IE_NAME       λ.Object
				DaumPlaylistIE__URL_TEMPLATE λ.Object
				DaumPlaylistIE__VALID_URL    λ.Object
				DaumPlaylistIE__real_extract λ.Object
				DaumPlaylistIE_suitable      λ.Object
			)
			DaumPlaylistIE__VALID_URL = λ.StrLiteral("https?://(?:m\\.)?tvpot\\.daum\\.net/mypot/(?:View\\.do|Top\\.tv)\\?.*?playlistid=(?P<id>[0-9]+)")
			DaumPlaylistIE_IE_NAME = λ.StrLiteral("daum.net:playlist")
			DaumPlaylistIE__URL_TEMPLATE = λ.StrLiteral("http://tvpot.daum.net/mypot/View.do?playlistid=%s")
			DaumPlaylistIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(λ.Calm(DaumUserIE, "suitable", ϒurl)) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, DaumPlaylistIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			DaumPlaylistIE_suitable = λ.Cal(λ.ClassMethodType, DaumPlaylistIE_suitable)
			DaumPlaylistIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒclip_result λ.Object
						ϒentries     λ.Object
						ϒlist_id     λ.Object
						ϒname        λ.Object
						ϒself        = λargs[0]
						ϒurl         = λargs[1]
						τmp0         λ.Object
					)
					ϒlist_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒclip_result = λ.Calm(ϒself, "_check_clip", ϒurl, ϒlist_id)
					if λ.IsTrue(ϒclip_result) {
						return ϒclip_result
					}
					τmp0 = λ.UnpackIterable(λ.Calm(ϒself, "_get_entries", ϒlist_id, λ.StrLiteral("playlistid")), 2)
					ϒname = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒentries = λ.GetItem(τmp0, λ.IntLiteral(1))
					return λ.Calm(ϒself, "playlist_result", ϒentries, ϒlist_id, ϒname)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       DaumPlaylistIE_IE_NAME,
				"_URL_TEMPLATE": DaumPlaylistIE__URL_TEMPLATE,
				"_VALID_URL":    DaumPlaylistIE__VALID_URL,
				"_real_extract": DaumPlaylistIE__real_extract,
				"suitable":      DaumPlaylistIE_suitable,
			})
		}())
		DaumUserIE = λ.Cal(λ.TypeType, λ.StrLiteral("DaumUserIE"), λ.NewTuple(DaumListIE), func() λ.Dict {
			var (
				DaumUserIE_IE_NAME       λ.Object
				DaumUserIE__VALID_URL    λ.Object
				DaumUserIE__real_extract λ.Object
			)
			DaumUserIE__VALID_URL = λ.StrLiteral("https?://(?:m\\.)?tvpot\\.daum\\.net/mypot/(?:View|Top)\\.(?:do|tv)\\?.*?ownerid=(?P<id>[0-9a-zA-Z]+)")
			DaumUserIE_IE_NAME = λ.StrLiteral("daum.net:user")
			DaumUserIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒclip_result λ.Object
						ϒentries     λ.Object
						ϒlist_id     λ.Object
						ϒname        λ.Object
						ϒplaylist_id λ.Object
						ϒquery_dict  λ.Object
						ϒself        = λargs[0]
						ϒurl         = λargs[1]
						τmp0         λ.Object
					)
					ϒlist_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒclip_result = λ.Calm(ϒself, "_check_clip", ϒurl, ϒlist_id)
					if λ.IsTrue(ϒclip_result) {
						return ϒclip_result
					}
					ϒquery_dict = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(λ.Cal(Ωparse.ϒurlparse, ϒurl), "query", nil))
					if λ.Contains(ϒquery_dict, λ.StrLiteral("playlistid")) {
						ϒplaylist_id = λ.GetItem(λ.GetItem(ϒquery_dict, λ.StrLiteral("playlistid")), λ.IntLiteral(0))
						return λ.Calm(ϒself, "url_result", λ.Mod(λ.GetAttr(DaumPlaylistIE, "_URL_TEMPLATE", nil), ϒplaylist_id), λ.StrLiteral("DaumPlaylist"))
					}
					τmp0 = λ.UnpackIterable(λ.Calm(ϒself, "_get_entries", ϒlist_id, λ.StrLiteral("ownerid")), 2)
					ϒname = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒentries = λ.GetItem(τmp0, λ.IntLiteral(1))
					return λ.Calm(ϒself, "playlist_result", ϒentries, ϒlist_id, ϒname)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       DaumUserIE_IE_NAME,
				"_VALID_URL":    DaumUserIE__VALID_URL,
				"_real_extract": DaumUserIE__real_extract,
			})
		}())
	})
}
