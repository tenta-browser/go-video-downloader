// Code generated by transpiler. DO NOT EDIT.
// +build !restricted

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * youtube/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/youtube.py
 */

package youtube

import (
	Ωitertools "github.com/tenta-browser/go-video-downloader/gen/itertools"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωpath "github.com/tenta-browser/go-video-downloader/gen/os/path"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωtime "github.com/tenta-browser/go-video-downloader/gen/time"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωjsinterp "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/jsinterp"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError                    λ.Object
	InfoExtractor                     λ.Object
	JSInterpreter                     λ.Object
	SearchInfoExtractor               λ.Object
	YoutubeBaseInfoExtractor          λ.Object
	YoutubeChannelIE                  λ.Object
	YoutubeEntryListBaseInfoExtractor λ.Object
	YoutubeFavouritesIE               λ.Object
	YoutubeFeedsInfoExtractor         λ.Object
	YoutubeHistoryIE                  λ.Object
	YoutubeIE                         λ.Object
	YoutubeLiveIE                     λ.Object
	YoutubePlaylistBaseInfoExtractor  λ.Object
	YoutubePlaylistIE                 λ.Object
	YoutubePlaylistsBaseInfoExtractor λ.Object
	YoutubePlaylistsIE                λ.Object
	YoutubeRecommendedIE              λ.Object
	YoutubeSearchBaseInfoExtractor    λ.Object
	YoutubeSearchIE                   λ.Object
	YoutubeSearchURLIE                λ.Object
	YoutubeShowIE                     λ.Object
	YoutubeSubscriptionsIE            λ.Object
	YoutubeTruncatedIDIE              λ.Object
	YoutubeTruncatedURLIE             λ.Object
	YoutubeUserIE                     λ.Object
	YoutubeWatchLaterIE               λ.Object
	ϒbool_or_none                     λ.Object
	ϒclean_html                       λ.Object
	ϒcompat_HTTPError                 λ.Object
	ϒcompat_chr                       λ.Object
	ϒcompat_kwargs                    λ.Object
	ϒcompat_parse_qs                  λ.Object
	ϒcompat_str                       λ.Object
	ϒcompat_urllib_parse_unquote      λ.Object
	ϒcompat_urllib_parse_unquote_plus λ.Object
	ϒcompat_urllib_parse_urlencode    λ.Object
	ϒcompat_urllib_parse_urlparse     λ.Object
	ϒerror_to_compat_str              λ.Object
	ϒextract_attributes               λ.Object
	ϒfloat_or_none                    λ.Object
	ϒget_element_by_attribute         λ.Object
	ϒget_element_by_id                λ.Object
	ϒint_or_none                      λ.Object
	ϒmimetype2ext                     λ.Object
	ϒorderedSet                       λ.Object
	ϒparse_codecs                     λ.Object
	ϒparse_duration                   λ.Object
	ϒremove_quotes                    λ.Object
	ϒremove_start                     λ.Object
	ϒsmuggle_url                      λ.Object
	ϒstr_or_none                      λ.Object
	ϒstr_to_int                       λ.Object
	ϒtry_get                          λ.Object
	ϒunescapeHTML                     λ.Object
	ϒunified_strdate                  λ.Object
	ϒunsmuggle_url                    λ.Object
	ϒuppercase_escape                 λ.Object
	ϒurl_or_none                      λ.Object
	ϒurlencode_postdata               λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		SearchInfoExtractor = Ωcommon.SearchInfoExtractor
		JSInterpreter = Ωjsinterp.JSInterpreter
		ϒcompat_chr = Ωcompat.ϒcompat_chr
		ϒcompat_HTTPError = Ωcompat.ϒcompat_HTTPError
		ϒcompat_kwargs = Ωcompat.ϒcompat_kwargs
		ϒcompat_parse_qs = Ωcompat.ϒcompat_parse_qs
		ϒcompat_urllib_parse_unquote = Ωcompat.ϒcompat_urllib_parse_unquote
		ϒcompat_urllib_parse_unquote_plus = Ωcompat.ϒcompat_urllib_parse_unquote_plus
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ϒcompat_urllib_parse_urlparse = Ωcompat.ϒcompat_urllib_parse_urlparse
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒbool_or_none = Ωutils.ϒbool_or_none
		ϒclean_html = Ωutils.ϒclean_html
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ϒextract_attributes = Ωutils.ϒextract_attributes
		ExtractorError = Ωutils.ExtractorError
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒget_element_by_attribute = Ωutils.ϒget_element_by_attribute
		ϒget_element_by_id = Ωutils.ϒget_element_by_id
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒmimetype2ext = Ωutils.ϒmimetype2ext
		ϒorderedSet = Ωutils.ϒorderedSet
		ϒparse_codecs = Ωutils.ϒparse_codecs
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒremove_quotes = Ωutils.ϒremove_quotes
		ϒremove_start = Ωutils.ϒremove_start
		ϒsmuggle_url = Ωutils.ϒsmuggle_url
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒstr_to_int = Ωutils.ϒstr_to_int
		ϒtry_get = Ωutils.ϒtry_get
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunsmuggle_url = Ωutils.ϒunsmuggle_url
		ϒuppercase_escape = Ωutils.ϒuppercase_escape
		ϒurl_or_none = Ωutils.ϒurl_or_none
		ϒurlencode_postdata = Ωutils.ϒurlencode_postdata
		YoutubeBaseInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeBaseInfoExtractor"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				YoutubeBaseInfoExtractor__LOGIN_REQUIRED          λ.Object
				YoutubeBaseInfoExtractor__NETRC_MACHINE           λ.Object
				YoutubeBaseInfoExtractor__PLAYLIST_ID_RE          λ.Object
				YoutubeBaseInfoExtractor__download_webpage_handle λ.Object
				YoutubeBaseInfoExtractor__login                   λ.Object
				YoutubeBaseInfoExtractor__real_initialize         λ.Object
				YoutubeBaseInfoExtractor__set_language            λ.Object
			)
			YoutubeBaseInfoExtractor__NETRC_MACHINE = λ.StrLiteral("youtube")
			YoutubeBaseInfoExtractor__LOGIN_REQUIRED = λ.False
			YoutubeBaseInfoExtractor__PLAYLIST_ID_RE = λ.StrLiteral("(?:PL|LL|EC|UU|FL|RD|UL|TL|PU|OLAK5uy_)[0-9A-Za-z-_]{10,}")
			YoutubeBaseInfoExtractor__set_language = λ.NewFunction("_set_language",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.Call(λ.GetAttr(ϒself, "_set_cookie", nil), λ.NewArgs(
						λ.StrLiteral(".youtube.com"),
						λ.StrLiteral("PREF"),
						λ.StrLiteral("f1=50000000&hl=en"),
					), λ.KWArgs{
						{Name: "expire_time", Value: λ.Add(λ.Cal(Ωtime.ϒtime), λ.Mul(λ.Mul(λ.Mul(λ.IntLiteral(2), λ.IntLiteral(30)), λ.IntLiteral(24)), λ.IntLiteral(3600)))},
					})
					return λ.None
				})
			YoutubeBaseInfoExtractor__login = λ.NewFunction("_login",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						CHALLENGES            λ.Object
						ϒchallenge            λ.Object
						ϒchallenge_req        λ.Object
						ϒchallenge_results    λ.Object
						ϒchallenge_str        λ.Object
						ϒcheck_cookie_results λ.Object
						ϒcheck_cookie_url     λ.Object
						ϒlogin_challenge      λ.Object
						ϒlogin_form           λ.Object
						ϒlogin_msg            λ.Object
						ϒlogin_page           λ.Object
						ϒlogin_res            λ.Object
						ϒlookup_req           λ.Object
						ϒlookup_results       λ.Object
						ϒpassword             λ.Object
						ϒreq                  λ.Object
						ϒres                  λ.Object
						ϒself                 = λargs[0]
						ϒstatus               λ.Object
						ϒtfa_code             λ.Object
						ϒtfa_msg              λ.Object
						ϒtfa_req              λ.Object
						ϒtfa_res              λ.Object
						ϒtfa_results          λ.Object
						ϒtl                   λ.Object
						ϒuser_hash            λ.Object
						ϒusername             λ.Object
						ϒwarn                 λ.Object
						τmp0                  λ.Object
					)
					τmp0 = λ.Calm(ϒself, "_get_login_info")
					ϒusername = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒpassword = λ.GetItem(τmp0, λ.IntLiteral(1))
					if ϒusername == λ.None {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetAttr(ϒself, "_LOGIN_REQUIRED", nil); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("cookiefile")) == λ.None)
							}
						}()) {
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.StrLiteral("No login info available, needed for using %s."), λ.GetAttr(ϒself, "IE_NAME", nil))), λ.KWArgs{
								{Name: "expected", Value: λ.True},
							})))
						}
						return λ.True
					}
					ϒlogin_page = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
						λ.GetAttr(ϒself, "_LOGIN_URL", nil),
						λ.None,
					), λ.KWArgs{
						{Name: "note", Value: λ.StrLiteral("Downloading login page")},
						{Name: "errnote", Value: λ.StrLiteral("unable to fetch login page")},
						{Name: "fatal", Value: λ.False},
					})
					if ϒlogin_page == λ.False {
						return λ.None
					}
					ϒlogin_form = λ.Calm(ϒself, "_hidden_inputs", ϒlogin_page)
					ϒreq = λ.NewFunction("req",
						[]λ.Param{
							{Name: "url"},
							{Name: "f_req"},
							{Name: "note"},
							{Name: "errnote"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdata    λ.Object
								ϒerrnote = λargs[3]
								ϒf_req   = λargs[1]
								ϒnote    = λargs[2]
								ϒurl     = λargs[0]
							)
							ϒdata = λ.Calm(ϒlogin_form, "copy")
							λ.Calm(ϒdata, "update", λ.DictLiteral(map[string]λ.Object{
								"pstMsg":          λ.IntLiteral(1),
								"checkConnection": λ.StrLiteral("youtube"),
								"checkedDomains":  λ.StrLiteral("youtube"),
								"hl":              λ.StrLiteral("en"),
								"deviceinfo":      λ.StrLiteral("[null,null,null,[],null,\"US\",null,null,[],\"GlifWebSignIn\",null,[null,null,[]]]"),
								"f.req":           λ.Cal(Ωjson.ϒdumps, ϒf_req),
								"flowName":        λ.StrLiteral("GlifWebSignIn"),
								"flowEntry":       λ.StrLiteral("ServiceLogin"),
								"bgRequest":       λ.StrLiteral("[\"identifier\",\"\"]"),
							}))
							return λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
								ϒurl,
								λ.None,
							), λ.KWArgs{
								{Name: "note", Value: ϒnote},
								{Name: "errnote", Value: ϒerrnote},
								{Name: "transform_source", Value: λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "s"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒs = λargs[0]
										)
										return λ.Cal(Ωre.ϒsub, λ.StrLiteral("^[^[]*"), λ.StrLiteral(""), ϒs)
									})},
								{Name: "fatal", Value: λ.False},
								{Name: "data", Value: λ.Cal(ϒurlencode_postdata, ϒdata)},
								{Name: "headers", Value: λ.DictLiteral(map[string]λ.Object{
									"Content-Type":         λ.StrLiteral("application/x-www-form-urlencoded;charset=utf-8"),
									"Google-Accounts-XSRF": λ.IntLiteral(1),
								})},
							})
						})
					ϒwarn = λ.NewFunction("warn",
						[]λ.Param{
							{Name: "message"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmessage = λargs[0]
							)
							λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", ϒmessage)
							return λ.None
						})
					ϒlookup_req = λ.NewList(
						ϒusername,
						λ.None,
						λ.NewList(),
						λ.None,
						λ.StrLiteral("US"),
						λ.None,
						λ.None,
						λ.IntLiteral(2),
						λ.False,
						λ.True,
						λ.NewList(
							λ.None,
							λ.None,
							λ.NewList(
								λ.IntLiteral(2),
								λ.IntLiteral(1),
								λ.None,
								λ.IntLiteral(1),
								λ.StrLiteral("https://accounts.google.com/ServiceLogin?passive=true&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Fnext%3D%252F%26action_handle_signin%3Dtrue%26hl%3Den%26app%3Ddesktop%26feature%3Dsign_in_button&hl=en&service=youtube&uilel=3&requestPath=%2FServiceLogin&Page=PasswordSeparationSignIn"),
								λ.None,
								λ.NewList(),
								λ.IntLiteral(4),
							),
							λ.IntLiteral(1),
							λ.NewList(
								λ.None,
								λ.None,
								λ.NewList(),
							),
							λ.None,
							λ.None,
							λ.None,
							λ.True,
						),
						ϒusername,
					)
					ϒlookup_results = λ.Cal(ϒreq, λ.GetAttr(ϒself, "_LOOKUP_URL", nil), ϒlookup_req, λ.StrLiteral("Looking up account info"), λ.StrLiteral("Unable to look up account info"))
					if ϒlookup_results == λ.False {
						return λ.False
					}
					ϒuser_hash = λ.Cal(ϒtry_get, ϒlookup_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.IntLiteral(2))
						}), ϒcompat_str)
					if !λ.IsTrue(ϒuser_hash) {
						λ.Cal(ϒwarn, λ.StrLiteral("Unable to extract user hash"))
						return λ.False
					}
					ϒchallenge_req = λ.NewList(
						ϒuser_hash,
						λ.None,
						λ.IntLiteral(1),
						λ.None,
						λ.NewList(
							λ.IntLiteral(1),
							λ.None,
							λ.None,
							λ.None,
							λ.NewList(
								ϒpassword,
								λ.None,
								λ.True,
							),
						),
						λ.NewList(
							λ.None,
							λ.None,
							λ.NewList(
								λ.IntLiteral(2),
								λ.IntLiteral(1),
								λ.None,
								λ.IntLiteral(1),
								λ.StrLiteral("https://accounts.google.com/ServiceLogin?passive=true&continue=https%3A%2F%2Fwww.youtube.com%2Fsignin%3Fnext%3D%252F%26action_handle_signin%3Dtrue%26hl%3Den%26app%3Ddesktop%26feature%3Dsign_in_button&hl=en&service=youtube&uilel=3&requestPath=%2FServiceLogin&Page=PasswordSeparationSignIn"),
								λ.None,
								λ.NewList(),
								λ.IntLiteral(4),
							),
							λ.IntLiteral(1),
							λ.NewList(
								λ.None,
								λ.None,
								λ.NewList(),
							),
							λ.None,
							λ.None,
							λ.None,
							λ.True,
						),
					)
					ϒchallenge_results = λ.Cal(ϒreq, λ.GetAttr(ϒself, "_CHALLENGE_URL", nil), ϒchallenge_req, λ.StrLiteral("Logging in"), λ.StrLiteral("Unable to log in"))
					if ϒchallenge_results == λ.False {
						return λ.None
					}
					ϒlogin_res = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.IntLiteral(5))
						}), λ.ListType)
					if λ.IsTrue(ϒlogin_res) {
						ϒlogin_msg = λ.Cal(ϒtry_get, ϒlogin_res, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.IntLiteral(5))
							}), ϒcompat_str)
						λ.Cal(ϒwarn, func() λ.Object {
							if λ.IsTrue(λ.Eq(ϒlogin_msg, λ.StrLiteral("INCORRECT_ANSWER_ENTERED"))) {
								return λ.Mod(λ.StrLiteral("Unable to login: %s"), λ.StrLiteral("Invalid password"))
							} else {
								return ϒlogin_msg
							}
						}())
						return λ.False
					}
					ϒres = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.Neg(λ.IntLiteral(1)))
						}), λ.ListType)
					if !λ.IsTrue(ϒres) {
						λ.Cal(ϒwarn, λ.StrLiteral("Unable to extract result entry"))
						return λ.False
					}
					ϒlogin_challenge = λ.Cal(ϒtry_get, ϒres, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.IntLiteral(0))
						}), λ.ListType)
					if λ.IsTrue(ϒlogin_challenge) {
						ϒchallenge_str = λ.Cal(ϒtry_get, ϒlogin_challenge, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.IntLiteral(2))
							}), ϒcompat_str)
						if λ.IsTrue(λ.Eq(ϒchallenge_str, λ.StrLiteral("TWO_STEP_VERIFICATION"))) {
							ϒstatus = λ.Cal(ϒtry_get, ϒlogin_challenge, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(ϒx, λ.IntLiteral(5))
								}), ϒcompat_str)
							if λ.IsTrue(λ.Eq(ϒstatus, λ.StrLiteral("QUOTA_EXCEEDED"))) {
								λ.Cal(ϒwarn, λ.StrLiteral("Exceeded the limit of TFA codes, try later"))
								return λ.False
							}
							ϒtl = λ.Cal(ϒtry_get, ϒchallenge_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(1)), λ.IntLiteral(2))
								}), ϒcompat_str)
							if !λ.IsTrue(ϒtl) {
								λ.Cal(ϒwarn, λ.StrLiteral("Unable to extract TL"))
								return λ.False
							}
							ϒtfa_code = λ.Calm(ϒself, "_get_tfa_info", λ.StrLiteral("2-step verification code"))
							if !λ.IsTrue(ϒtfa_code) {
								λ.Cal(ϒwarn, λ.StrLiteral("Two-factor authentication required. Provide it either interactively or with --twofactor <code>(Note that only TOTP (Google Authenticator App) codes work at this time.)"))
								return λ.False
							}
							ϒtfa_code = λ.Cal(ϒremove_start, ϒtfa_code, λ.StrLiteral("G-"))
							ϒtfa_req = λ.NewList(
								ϒuser_hash,
								λ.None,
								λ.IntLiteral(2),
								λ.None,
								λ.NewList(
									λ.IntLiteral(9),
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.None,
									λ.NewList(
										λ.None,
										ϒtfa_code,
										λ.True,
										λ.IntLiteral(2),
									),
								),
							)
							ϒtfa_results = λ.Cal(ϒreq, λ.Calm(λ.GetAttr(ϒself, "_TFA_URL", nil), "format", ϒtl), ϒtfa_req, λ.StrLiteral("Submitting TFA code"), λ.StrLiteral("Unable to submit TFA code"))
							if ϒtfa_results == λ.False {
								return λ.False
							}
							ϒtfa_res = λ.Cal(ϒtry_get, ϒtfa_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.IntLiteral(5))
								}), λ.ListType)
							if λ.IsTrue(ϒtfa_res) {
								ϒtfa_msg = λ.Cal(ϒtry_get, ϒtfa_res, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(ϒx, λ.IntLiteral(5))
									}), ϒcompat_str)
								λ.Cal(ϒwarn, func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒtfa_msg, λ.StrLiteral("INCORRECT_ANSWER_ENTERED"))) {
										return λ.Mod(λ.StrLiteral("Unable to finish TFA: %s"), λ.StrLiteral("Invalid TFA code"))
									} else {
										return ϒtfa_msg
									}
								}())
								return λ.False
							}
							ϒcheck_cookie_url = λ.Cal(ϒtry_get, ϒtfa_results, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.IntLiteral(0)), λ.Neg(λ.IntLiteral(1))), λ.IntLiteral(2))
								}), ϒcompat_str)
						} else {
							CHALLENGES = λ.DictLiteral(map[string]string{
								"LOGIN_CHALLENGE":   "This device isn't recognized. For your security, Google wants to make sure it's really you.",
								"USERNAME_RECOVERY": "Please provide additional information to aid in the recovery process.",
								"REAUTH":            "There is something unusual about your activity. For your security, Google wants to make sure it's really you.",
							})
							ϒchallenge = λ.Calm(CHALLENGES, "get", ϒchallenge_str, λ.Mod(λ.StrLiteral("%s returned error %s."), λ.NewTuple(
								λ.GetAttr(ϒself, "IE_NAME", nil),
								ϒchallenge_str,
							)))
							λ.Cal(ϒwarn, λ.Mod(λ.StrLiteral("%s\nGo to https://accounts.google.com/, login and solve a challenge."), ϒchallenge))
							return λ.False
						}
					} else {
						ϒcheck_cookie_url = λ.Cal(ϒtry_get, ϒres, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.IntLiteral(2))
							}), ϒcompat_str)
					}
					if !λ.IsTrue(ϒcheck_cookie_url) {
						λ.Cal(ϒwarn, λ.StrLiteral("Unable to extract CheckCookie URL"))
						return λ.False
					}
					ϒcheck_cookie_results = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
						ϒcheck_cookie_url,
						λ.None,
						λ.StrLiteral("Checking cookie"),
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					if ϒcheck_cookie_results == λ.False {
						return λ.False
					}
					if !λ.Contains(ϒcheck_cookie_results, λ.StrLiteral("https://myaccount.google.com/")) {
						λ.Cal(ϒwarn, λ.StrLiteral("Unable to log in"))
						return λ.False
					}
					return λ.True
				})
			YoutubeBaseInfoExtractor__download_webpage_handle = λ.NewFunction("_download_webpage_handle",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒquery  λ.Object
						ϒself   = λargs[0]
					)
					ϒquery = λ.Calm(λ.Calm(ϒkwargs, "get", λ.StrLiteral("query"), λ.DictLiteral(map[λ.Object]λ.Object{})), "copy")
					λ.SetItem(ϒquery, λ.StrLiteral("disable_polymer"), λ.StrLiteral("true"))
					λ.SetItem(ϒkwargs, λ.StrLiteral("query"), ϒquery)
					return λ.Call(λ.GetAttr(λ.Cal(λ.SuperType, YoutubeBaseInfoExtractor, ϒself), "_download_webpage_handle", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
						{Name: "", Value: λ.Cal(ϒcompat_kwargs, ϒkwargs)},
					})
				})
			YoutubeBaseInfoExtractor__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					if λ.GetAttr(ϒself, "_downloader", nil) == λ.None {
						return λ.None
					}
					λ.Calm(ϒself, "_set_language")
					if !λ.IsTrue(λ.Calm(ϒself, "_login")) {
						return λ.None
					}
					return λ.None
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_LOGIN_REQUIRED":          YoutubeBaseInfoExtractor__LOGIN_REQUIRED,
				"_NETRC_MACHINE":           YoutubeBaseInfoExtractor__NETRC_MACHINE,
				"_PLAYLIST_ID_RE":          YoutubeBaseInfoExtractor__PLAYLIST_ID_RE,
				"_download_webpage_handle": YoutubeBaseInfoExtractor__download_webpage_handle,
				"_login":                   YoutubeBaseInfoExtractor__login,
				"_real_initialize":         YoutubeBaseInfoExtractor__real_initialize,
				"_set_language":            YoutubeBaseInfoExtractor__set_language,
			})
		}())
		YoutubeEntryListBaseInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeEntryListBaseInfoExtractor"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeEntryListBaseInfoExtractor__entries λ.Object
			)
			YoutubeEntryListBaseInfoExtractor__entries = λ.NewFunction("_entries",
				[]λ.Param{
					{Name: "self"},
					{Name: "page"},
					{Name: "playlist_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
						var (
							ϒcontent_html     λ.Object
							ϒcount            λ.Object
							ϒentry            λ.Object
							ϒmobj             λ.Object
							ϒmore             λ.Object
							ϒmore_widget_html λ.Object
							ϒpage             = λargs[1]
							ϒpage_num         λ.Object
							ϒplaylist_id      = λargs[2]
							ϒretries          λ.Object
							ϒself             = λargs[0]
							τmp0              λ.Object
							τmp1              λ.Object
							τmp2              λ.Object
							τmp3              λ.Object
							τmp4              λ.Object
						)
						_ = τmp3
						τmp0 = ϒpage
						ϒmore_widget_html = τmp0
						ϒcontent_html = τmp0
						τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωitertools.ϒcount, λ.IntLiteral(1)))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒpage_num = τmp1
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒself, "_process_page", ϒcontent_html))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒentry = τmp3
								λgy.Yield(ϒentry)
							}
							ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("data-uix-load-more-href=\"/?(?P<more>[^\"]+)\""), ϒmore_widget_html)
							if !λ.IsTrue(ϒmobj) {
								break
							}
							ϒcount = λ.IntLiteral(0)
							ϒretries = λ.IntLiteral(3)
							for λ.IsTrue(λ.Le(ϒcount, ϒretries)) {
								τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
											var ϒe λ.Object = λex
											if λ.IsTrue(func() λ.Object {
												if λv := λ.Cal(λ.BuiltinIsInstance, λ.GetAttr(ϒe, "cause", nil), ϒcompat_HTTPError); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(λ.Contains(λ.NewTuple(
														λ.IntLiteral(500),
														λ.IntLiteral(503),
													), λ.GetAttr(λ.GetAttr(ϒe, "cause", nil), "code", nil)))
												}
											}()) {
												τmp4 = λ.IAdd(ϒcount, λ.IntLiteral(1))
												ϒcount = τmp4
												if λ.IsTrue(λ.Le(ϒcount, ϒretries)) {
													λexit = λ.BlockExitContinue
													return
												}
											}
											panic(λ.Raise(λex))
										}},
									)
									ϒmore = λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
										λ.Mod(λ.StrLiteral("https://youtube.com/%s"), λ.Calm(ϒmobj, "group", λ.StrLiteral("more"))),
										ϒplaylist_id,
										λ.Mod(λ.StrLiteral("Downloading page #%s%s"), λ.NewTuple(
											ϒpage_num,
											func() λ.Object {
												if λ.IsTrue(ϒcount) {
													return λ.Mod(λ.StrLiteral(" (retry #%d)"), ϒcount)
												} else {
													return λ.StrLiteral("")
												}
											}(),
										)),
									), λ.KWArgs{
										{Name: "transform_source", Value: ϒuppercase_escape},
									})
									λexit = λ.BlockExitBreak
									return
									return λ.BlockExitNormally, nil
								}()
								if τmp2 == λ.BlockExitBreak {
									break
								}
								if τmp2 == λ.BlockExitContinue {
									continue
								}
							}
							ϒcontent_html = λ.GetItem(ϒmore, λ.StrLiteral("content_html"))
							if !λ.IsTrue(λ.Calm(ϒcontent_html, "strip")) {
								break
							}
							ϒmore_widget_html = λ.GetItem(ϒmore, λ.StrLiteral("load_more_widget_html"))
						}
						return λ.None
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_entries": YoutubeEntryListBaseInfoExtractor__entries,
			})
		}())
		YoutubePlaylistBaseInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubePlaylistBaseInfoExtractor"), λ.NewTuple(YoutubeEntryListBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubePlaylistsBaseInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubePlaylistsBaseInfoExtractor"), λ.NewTuple(YoutubeEntryListBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeIE_IE_NAME                     λ.Object
				YoutubeIE__GEO_BYPASS                 λ.Object
				YoutubeIE__NEXT_URL_RE                λ.Object
				YoutubeIE__PLAYER_INFO_RE             λ.Object
				YoutubeIE__VALID_URL                  λ.Object
				YoutubeIE___init__                    λ.Object
				YoutubeIE__decrypt_signature          λ.Object
				YoutubeIE__extract_chapters           λ.Object
				YoutubeIE__extract_player_info        λ.Object
				YoutubeIE__extract_signature_function λ.Object
				YoutubeIE__extract_url                λ.Object
				YoutubeIE__extract_urls               λ.Object
				YoutubeIE__formats                    λ.Object
				YoutubeIE__get_ytplayer_config        λ.Object
				YoutubeIE__parse_sig_js               λ.Object
				YoutubeIE__real_extract               λ.Object
				YoutubeIE__signature_cache_id         λ.Object
				YoutubeIE_extract_id                  λ.Object
			)
			YoutubeIE__VALID_URL = λ.Mod(λ.StrLiteral("(?x)^\n                     (\n                         (?:https?://|//)                                    # http(s):// or protocol-independent URL\n                         (?:(?:(?:(?:\\w+\\.)?[yY][oO][uU][tT][uU][bB][eE](?:-nocookie|kids)?\\.com/|\n                            (?:www\\.)?deturl\\.com/www\\.youtube\\.com/|\n                            (?:www\\.)?pwnyoutube\\.com/|\n                            (?:www\\.)?hooktube\\.com/|\n                            (?:www\\.)?yourepeat\\.com/|\n                            tube\\.majestyc\\.net/|\n                            # Invidious instances taken from https://github.com/omarroth/invidious/wiki/Invidious-Instances\n                            (?:(?:www|dev)\\.)?invidio\\.us/|\n                            (?:(?:www|no)\\.)?invidiou\\.sh/|\n                            (?:(?:www|fi|de)\\.)?invidious\\.snopyta\\.org/|\n                            (?:www\\.)?invidious\\.kabi\\.tk/|\n                            (?:www\\.)?invidious\\.13ad\\.de/|\n                            (?:www\\.)?invidious\\.mastodon\\.host/|\n                            (?:www\\.)?invidious\\.nixnet\\.xyz/|\n                            (?:www\\.)?invidious\\.drycat\\.fr/|\n                            (?:www\\.)?tube\\.poal\\.co/|\n                            (?:www\\.)?vid\\.wxzm\\.sx/|\n                            (?:www\\.)?yt\\.elukerio\\.org/|\n                            (?:www\\.)?yt\\.lelux\\.fi/|\n                            (?:www\\.)?kgg2m7yk5aybusll\\.onion/|\n                            (?:www\\.)?qklhadlycap4cnod\\.onion/|\n                            (?:www\\.)?axqzx4s6s54s32yentfqojs3x5i7faxza6xo3ehd4bzzsg2ii4fv2iid\\.onion/|\n                            (?:www\\.)?c7hqkpkpemu6e7emz5b4vyz7idjgdvgaaa3dyimmeojqbgpea3xqjoid\\.onion/|\n                            (?:www\\.)?fz253lmuao3strwbfbmx46yu7acac2jz27iwtorgmbqlkurlclmancad\\.onion/|\n                            (?:www\\.)?invidious\\.l4qlywnpwqsluw65ts7md3khrivpirse744un3x7mlskqauz5pyuzgqd\\.onion/|\n                            (?:www\\.)?owxfohz4kjyv25fvlqilyxast7inivgiktls3th44jhk3ej3i7ya\\.b32\\.i2p/|\n                            youtube\\.googleapis\\.com/)                        # the various hostnames, with wildcard subdomains\n                         (?:.*?\\#/)?                                          # handle anchor (#/) redirect urls\n                         (?:                                                  # the various things that can precede the ID:\n                             (?:(?:v|embed|e)/(?!videoseries))                # v/ or embed/ or e/\n                             |(?:                                             # or the v= param in all its forms\n                                 (?:(?:watch|movie)(?:_popup)?(?:\\.php)?/?)?  # preceding watch(_popup|.php) or nothing (like /?v=xxxx)\n                                 (?:\\?|\\#!?)                                  # the params delimiter ? or # or #!\n                                 (?:.*?[&;])??                                # any other preceding param (like /?s=tuff&v=xxxx or ?s=tuff&amp;v=V36LpHqtcDY)\n                                 v=\n                             )\n                         ))\n                         |(?:\n                            youtu\\.be|                                        # just youtu.be/xxxx\n                            vid\\.plus|                                        # or vid.plus/xxxx\n                            zwearz\\.com/watch|                                # or zwearz.com/watch/xxxx\n                         )/\n                         |(?:www\\.)?cleanvideosearch\\.com/media/action/yt/watch\\?videoId=\n                         )\n                     )?                                                       # all until now is optional -> you can pass the naked ID\n                     ([0-9A-Za-z_-]{11})                                      # here is it! the YouTube video ID\n                     (?!.*?\\blist=\n                        (?:\n                            %(playlist_id)s|                                  # combined list/video URLs are handled by the playlist IE\n                            WL                                                # WL are handled by the watch later IE\n                        )\n                     )\n                     #(?(1).+)?                                                # if we found the ID, everything can follow\n                     "), λ.DictLiteral(map[string]λ.Object{
				"playlist_id": λ.GetAttr(YoutubeBaseInfoExtractor, "_PLAYLIST_ID_RE", nil),
			}))
			YoutubeIE__NEXT_URL_RE = λ.StrLiteral("[\\?&]next_url=([^&]+)")
			YoutubeIE__PLAYER_INFO_RE = λ.NewTuple(
				λ.StrLiteral("/(?P<id>[a-zA-Z0-9_-]{8,})/player_ias\\.vflset(?:/[a-zA-Z]{2,3}_[a-zA-Z]{2,3})?/base\\.(?P<ext>[a-z]+)$"),
				λ.StrLiteral("\\b(?P<id>vfl[a-zA-Z0-9_-]+)\\b.*?\\.(?P<ext>[a-z]+)$"),
			)
			YoutubeIE__formats = λ.DictLiteral(map[string]λ.Object{
				"5": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("flv"),
					"width":  λ.IntLiteral(400),
					"height": λ.IntLiteral(240),
					"acodec": λ.StrLiteral("mp3"),
					"abr":    λ.IntLiteral(64),
					"vcodec": λ.StrLiteral("h263"),
				}),
				"6": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("flv"),
					"width":  λ.IntLiteral(450),
					"height": λ.IntLiteral(270),
					"acodec": λ.StrLiteral("mp3"),
					"abr":    λ.IntLiteral(64),
					"vcodec": λ.StrLiteral("h263"),
				}),
				"13": λ.DictLiteral(map[string]string{
					"ext":    "3gp",
					"acodec": "aac",
					"vcodec": "mp4v",
				}),
				"17": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("3gp"),
					"width":  λ.IntLiteral(176),
					"height": λ.IntLiteral(144),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(24),
					"vcodec": λ.StrLiteral("mp4v"),
				}),
				"18": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(640),
					"height": λ.IntLiteral(360),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(96),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"22": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(1280),
					"height": λ.IntLiteral(720),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(192),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"34": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("flv"),
					"width":  λ.IntLiteral(640),
					"height": λ.IntLiteral(360),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"35": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("flv"),
					"width":  λ.IntLiteral(854),
					"height": λ.IntLiteral(480),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"36": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("3gp"),
					"width":  λ.IntLiteral(320),
					"acodec": λ.StrLiteral("aac"),
					"vcodec": λ.StrLiteral("mp4v"),
				}),
				"37": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(1920),
					"height": λ.IntLiteral(1080),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(192),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"38": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(4096),
					"height": λ.IntLiteral(3072),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(192),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"43": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("webm"),
					"width":  λ.IntLiteral(640),
					"height": λ.IntLiteral(360),
					"acodec": λ.StrLiteral("vorbis"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("vp8"),
				}),
				"44": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("webm"),
					"width":  λ.IntLiteral(854),
					"height": λ.IntLiteral(480),
					"acodec": λ.StrLiteral("vorbis"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("vp8"),
				}),
				"45": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("webm"),
					"width":  λ.IntLiteral(1280),
					"height": λ.IntLiteral(720),
					"acodec": λ.StrLiteral("vorbis"),
					"abr":    λ.IntLiteral(192),
					"vcodec": λ.StrLiteral("vp8"),
				}),
				"46": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("webm"),
					"width":  λ.IntLiteral(1920),
					"height": λ.IntLiteral(1080),
					"acodec": λ.StrLiteral("vorbis"),
					"abr":    λ.IntLiteral(192),
					"vcodec": λ.StrLiteral("vp8"),
				}),
				"59": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(854),
					"height": λ.IntLiteral(480),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"78": λ.DictLiteral(map[string]λ.Object{
					"ext":    λ.StrLiteral("mp4"),
					"width":  λ.IntLiteral(854),
					"height": λ.IntLiteral(480),
					"acodec": λ.StrLiteral("aac"),
					"abr":    λ.IntLiteral(128),
					"vcodec": λ.StrLiteral("h264"),
				}),
				"82": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(360),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(128),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"83": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(128),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"84": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(192),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"85": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(192),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"100": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(360),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("vorbis"),
					"abr":         λ.IntLiteral(128),
					"vcodec":      λ.StrLiteral("vp8"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"101": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("vorbis"),
					"abr":         λ.IntLiteral(192),
					"vcodec":      λ.StrLiteral("vp8"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"102": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("3D"),
					"acodec":      λ.StrLiteral("vorbis"),
					"abr":         λ.IntLiteral(192),
					"vcodec":      λ.StrLiteral("vp8"),
					"preference":  λ.Neg(λ.IntLiteral(20)),
				}),
				"91": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(144),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(48),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"92": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(240),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(48),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"93": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(360),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(128),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"94": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(128),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"95": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(256),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"96": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(256),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"132": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(240),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(48),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"151": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(72),
					"format_note": λ.StrLiteral("HLS"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(24),
					"vcodec":      λ.StrLiteral("h264"),
					"preference":  λ.Neg(λ.IntLiteral(10)),
				}),
				"133": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(240),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"134": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(360),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"135": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"136": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"137": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"138": λ.DictLiteral(map[string]string{
					"ext":         "mp4",
					"format_note": "DASH video",
					"vcodec":      "h264",
				}),
				"160": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(144),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"212": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"264": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(1440),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"298": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
					"fps":         λ.IntLiteral(60),
				}),
				"299": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
					"fps":         λ.IntLiteral(60),
				}),
				"266": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("mp4"),
					"height":      λ.IntLiteral(2160),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("h264"),
				}),
				"139": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("m4a"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(48),
					"container":   λ.StrLiteral("m4a_dash"),
				}),
				"140": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("m4a"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(128),
					"container":   λ.StrLiteral("m4a_dash"),
				}),
				"141": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("m4a"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("aac"),
					"abr":         λ.IntLiteral(256),
					"container":   λ.StrLiteral("m4a_dash"),
				}),
				"256": λ.DictLiteral(map[string]string{
					"ext":         "m4a",
					"format_note": "DASH audio",
					"acodec":      "aac",
					"container":   "m4a_dash",
				}),
				"258": λ.DictLiteral(map[string]string{
					"ext":         "m4a",
					"format_note": "DASH audio",
					"acodec":      "aac",
					"container":   "m4a_dash",
				}),
				"325": λ.DictLiteral(map[string]string{
					"ext":         "m4a",
					"format_note": "DASH audio",
					"acodec":      "dtse",
					"container":   "m4a_dash",
				}),
				"328": λ.DictLiteral(map[string]string{
					"ext":         "m4a",
					"format_note": "DASH audio",
					"acodec":      "ec-3",
					"container":   "m4a_dash",
				}),
				"167": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(360),
					"width":       λ.IntLiteral(640),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"168": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"width":       λ.IntLiteral(854),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"169": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(720),
					"width":       λ.IntLiteral(1280),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"170": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(1080),
					"width":       λ.IntLiteral(1920),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"218": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"width":       λ.IntLiteral(854),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"219": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"width":       λ.IntLiteral(854),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp8"),
				}),
				"278": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(144),
					"format_note": λ.StrLiteral("DASH video"),
					"container":   λ.StrLiteral("webm"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"242": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(240),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"243": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(360),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"244": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"245": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"246": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(480),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"247": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"248": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"271": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(1440),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"272": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(2160),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"302": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(720),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
					"fps":         λ.IntLiteral(60),
				}),
				"303": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(1080),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
					"fps":         λ.IntLiteral(60),
				}),
				"308": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(1440),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
					"fps":         λ.IntLiteral(60),
				}),
				"313": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(2160),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
				}),
				"315": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"height":      λ.IntLiteral(2160),
					"format_note": λ.StrLiteral("DASH video"),
					"vcodec":      λ.StrLiteral("vp9"),
					"fps":         λ.IntLiteral(60),
				}),
				"171": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"acodec":      λ.StrLiteral("vorbis"),
					"format_note": λ.StrLiteral("DASH audio"),
					"abr":         λ.IntLiteral(128),
				}),
				"172": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"acodec":      λ.StrLiteral("vorbis"),
					"format_note": λ.StrLiteral("DASH audio"),
					"abr":         λ.IntLiteral(256),
				}),
				"249": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("opus"),
					"abr":         λ.IntLiteral(50),
				}),
				"250": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("opus"),
					"abr":         λ.IntLiteral(70),
				}),
				"251": λ.DictLiteral(map[string]λ.Object{
					"ext":         λ.StrLiteral("webm"),
					"format_note": λ.StrLiteral("DASH audio"),
					"acodec":      λ.StrLiteral("opus"),
					"abr":         λ.IntLiteral(160),
				}),
				"_rtmp": λ.DictLiteral(map[string]string{
					"protocol": "rtmp",
				}),
				"394": λ.DictLiteral(map[string]string{
					"acodec": "none",
					"vcodec": "av01.0.05M.08",
				}),
				"395": λ.DictLiteral(map[string]string{
					"acodec": "none",
					"vcodec": "av01.0.05M.08",
				}),
				"396": λ.DictLiteral(map[string]string{
					"acodec": "none",
					"vcodec": "av01.0.05M.08",
				}),
				"397": λ.DictLiteral(map[string]string{
					"acodec": "none",
					"vcodec": "av01.0.05M.08",
				}),
			})
			YoutubeIE__GEO_BYPASS = λ.False
			YoutubeIE_IE_NAME = λ.StrLiteral("youtube")
			YoutubeIE___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒself   = λargs[0]
					)
					λ.Call(λ.GetAttr(λ.Cal(λ.SuperType, YoutubeIE, ϒself), "__init__", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					λ.SetAttr(ϒself, "_player_cache", λ.DictLiteral(map[λ.Object]λ.Object{}))
					return λ.None
				})
			YoutubeIE__signature_cache_id = λ.NewFunction("_signature_cache_id",
				[]λ.Param{
					{Name: "self"},
					{Name: "example_sig"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒexample_sig = λargs[1]
						ϒself        = λargs[0]
					)
					_ = ϒself
					return λ.Calm(λ.StrLiteral("."), "join", λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒpart λ.Object
									τmp0  λ.Object
									τmp1  λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒexample_sig, "split", λ.StrLiteral(".")))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒpart = τmp1
									λgy.Yield(λ.Cal(ϒcompat_str, λ.Cal(λ.BuiltinLen, ϒpart)))
								}
								return λ.None
							})
						})))
				})
			YoutubeIE__extract_player_info = λ.NewFunction("_extract_player_info",
				[]λ.Param{
					{Name: "cls"},
					{Name: "player_url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls        = λargs[0]
						ϒid_m       λ.Object
						ϒplayer_re  λ.Object
						ϒplayer_url = λargs[1]
						τmp0        λ.Object
						τmp1        λ.Object
					)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetAttr(ϒcls, "_PLAYER_INFO_RE", nil))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒplayer_re = τmp1
						ϒid_m = λ.Cal(Ωre.ϒsearch, ϒplayer_re, ϒplayer_url)
						if λ.IsTrue(ϒid_m) {
							break
						}
					}
					if τmp1 == λ.AfterLast {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.StrLiteral("Cannot identify player %r"), ϒplayer_url))))
					}
					return λ.NewTuple(
						λ.Calm(ϒid_m, "group", λ.StrLiteral("ext")),
						λ.Calm(ϒid_m, "group", λ.StrLiteral("id")),
					)
				})
			YoutubeIE__extract_player_info = λ.Cal(λ.ClassMethodType, YoutubeIE__extract_player_info)
			YoutubeIE__extract_signature_function = λ.NewFunction("_extract_signature_function",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
					{Name: "player_url"},
					{Name: "example_sig"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcache_res     λ.Object
						ϒcache_spec    λ.Object
						ϒcode          λ.Object
						ϒdownload_note λ.Object
						ϒexample_sig   = λargs[3]
						ϒfunc_id       λ.Object
						ϒplayer_id     λ.Object
						ϒplayer_type   λ.Object
						ϒplayer_url    = λargs[2]
						ϒres           λ.Object
						ϒself          = λargs[0]
						ϒtest_string   λ.Object
						ϒurlh          λ.Object
						ϒvideo_id      = λargs[1]
						τmp0           λ.Object
					)
					τmp0 = λ.Calm(ϒself, "_extract_player_info", ϒplayer_url)
					ϒplayer_type = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒplayer_id = λ.GetItem(τmp0, λ.IntLiteral(1))
					ϒfunc_id = λ.Mod(λ.StrLiteral("%s_%s_%s"), λ.NewTuple(
						ϒplayer_type,
						ϒplayer_id,
						λ.Calm(ϒself, "_signature_cache_id", ϒexample_sig),
					))
					if !λ.IsTrue(λ.Eq(λ.Cal(Ωpath.ϒbasename, ϒfunc_id), ϒfunc_id)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					ϒcache_spec = λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "cache", nil), "load", λ.StrLiteral("youtube-sigfuncs"), ϒfunc_id)
					if ϒcache_spec != λ.None {
						return λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "s"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒs = λargs[0]
								)
								return λ.Calm(λ.StrLiteral(""), "join", λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒi   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, ϒcache_spec)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒi = τmp1
												λgy.Yield(λ.GetItem(ϒs, ϒi))
											}
											return λ.None
										})
									})))
							})
					}
					ϒdownload_note = func() λ.Object {
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("verbose"))) {
							return λ.Mod(λ.StrLiteral("Downloading player %s"), ϒplayer_url)
						} else {
							return λ.Mod(λ.StrLiteral("Downloading %s player %s"), λ.NewTuple(
								ϒplayer_type,
								ϒplayer_id,
							))
						}
					}()
					if λ.IsTrue(λ.Eq(ϒplayer_type, λ.StrLiteral("js"))) {
						ϒcode = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
							ϒplayer_url,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "note", Value: ϒdownload_note},
							{Name: "errnote", Value: λ.Mod(λ.StrLiteral("Download of %s failed"), ϒplayer_url)},
						})
						ϒres = λ.Calm(ϒself, "_parse_sig_js", ϒcode)
					} else {
						if λ.IsTrue(λ.Eq(ϒplayer_type, λ.StrLiteral("swf"))) {
							ϒurlh = λ.Call(λ.GetAttr(ϒself, "_request_webpage", nil), λ.NewArgs(
								ϒplayer_url,
								ϒvideo_id,
							), λ.KWArgs{
								{Name: "note", Value: ϒdownload_note},
								{Name: "errnote", Value: λ.Mod(λ.StrLiteral("Download of %s failed"), ϒplayer_url)},
							})
							ϒcode = λ.Calm(ϒurlh, "read")
							ϒres = λ.Calm(ϒself, "_parse_sig_swf", ϒcode)
						} else {
							if !λ.IsTrue(λ.False) {
								panic(λ.Raise(λ.Cal(λ.AssertionErrorType, λ.Mod(λ.StrLiteral("Invalid player type %r"), ϒplayer_type))))
							}
						}
					}
					ϒtest_string = λ.Calm(λ.StrLiteral(""), "join", λ.Cal(λ.MapIteratorType, ϒcompat_chr, λ.Cal(λ.RangeType, λ.Cal(λ.BuiltinLen, ϒexample_sig))))
					ϒcache_res = λ.Cal(ϒres, ϒtest_string)
					ϒcache_spec = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒc   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, ϒcache_res)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒc = τmp1
									λgy.Yield(λ.Cal(λ.BuiltinOrd, ϒc))
								}
								return λ.None
							})
						})))
					λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "cache", nil), "store", λ.StrLiteral("youtube-sigfuncs"), ϒfunc_id, ϒcache_spec)
					return ϒres
				})
			YoutubeIE__parse_sig_js = λ.NewFunction("_parse_sig_js",
				[]λ.Param{
					{Name: "self"},
					{Name: "jscode"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfuncname         λ.Object
						ϒinitial_function λ.Object
						ϒjscode           = λargs[1]
						ϒjsi              λ.Object
						ϒself             = λargs[0]
					)
					ϒfuncname = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.NewTuple(
							λ.StrLiteral("\\b[cs]\\s*&&\\s*[adf]\\.set\\([^,]+\\s*,\\s*encodeURIComponent\\s*\\(\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\b[a-zA-Z0-9]+\\s*&&\\s*[a-zA-Z0-9]+\\.set\\([^,]+\\s*,\\s*encodeURIComponent\\s*\\(\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\b(?P<sig>[a-zA-Z0-9$]{2})\\s*=\\s*function\\(\\s*a\\s*\\)\\s*{\\s*a\\s*=\\s*a\\.split\\(\\s*\"\"\\s*\\)"),
							λ.StrLiteral("(?P<sig>[a-zA-Z0-9$]+)\\s*=\\s*function\\(\\s*a\\s*\\)\\s*{\\s*a\\s*=\\s*a\\.split\\(\\s*\"\"\\s*\\)"),
							λ.StrLiteral("([\"\\'])signature\\1\\s*,\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\.sig\\|\\|(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("yt\\.akamaized\\.net/\\)\\s*\\|\\|\\s*.*?\\s*[cs]\\s*&&\\s*[adf]\\.set\\([^,]+\\s*,\\s*(?:encodeURIComponent\\s*\\()?\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\b[cs]\\s*&&\\s*[adf]\\.set\\([^,]+\\s*,\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\b[a-zA-Z0-9]+\\s*&&\\s*[a-zA-Z0-9]+\\.set\\([^,]+\\s*,\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\bc\\s*&&\\s*a\\.set\\([^,]+\\s*,\\s*\\([^)]*\\)\\s*\\(\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\bc\\s*&&\\s*[a-zA-Z0-9]+\\.set\\([^,]+\\s*,\\s*\\([^)]*\\)\\s*\\(\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
							λ.StrLiteral("\\bc\\s*&&\\s*[a-zA-Z0-9]+\\.set\\([^,]+\\s*,\\s*\\([^)]*\\)\\s*\\(\\s*(?P<sig>[a-zA-Z0-9$]+)\\("),
						),
						ϒjscode,
						λ.StrLiteral("Initial JS player signature function name"),
					), λ.KWArgs{
						{Name: "group", Value: λ.StrLiteral("sig")},
					})
					ϒjsi = λ.Cal(JSInterpreter, ϒjscode)
					ϒinitial_function = λ.Calm(ϒjsi, "extract_function", ϒfuncname)
					return λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "s"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒs = λargs[0]
							)
							return λ.Cal(ϒinitial_function, λ.NewList(ϒs))
						})
				})
			YoutubeIE__decrypt_signature = λ.NewFunction("_decrypt_signature",
				[]λ.Param{
					{Name: "self"},
					{Name: "s"},
					{Name: "video_id"},
					{Name: "player_url"},
					{Name: "age_gate", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒage_gate   = λargs[4]
						ϒfunc       λ.Object
						ϒplayer_id  λ.Object
						ϒplayer_url = λargs[3]
						ϒs          = λargs[1]
						ϒself       = λargs[0]
						ϒtb         λ.Object
						ϒvideo_id   = λargs[2]
						τmp0        λ.Object
						τmp1        λ.Object
					)
					_ = ϒage_gate
					if ϒplayer_url == λ.None {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("Cannot decrypt signature without player_url"))))
					}
					if λ.IsTrue(λ.Calm(ϒplayer_url, "startswith", λ.StrLiteral("//"))) {
						ϒplayer_url = λ.Add(λ.StrLiteral("https:"), ϒplayer_url)
					} else {
						if !λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("https?://"), ϒplayer_url)) {
							ϒplayer_url = λ.Cal(Ωparse.ϒurljoin, λ.StrLiteral("https://www.youtube.com"), ϒplayer_url)
						}
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ExceptionType, func(λex λ.BaseException) {
								var ϒe λ.Object = λex
								ϒtb = λ.Calm(λ.None, "format_exc")
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Add(λ.StrLiteral("Signature extraction failed: "), ϒtb)), λ.KWArgs{
									{Name: "cause", Value: ϒe},
								})))
							}},
						)
						ϒplayer_id = λ.NewTuple(
							ϒplayer_url,
							λ.Calm(ϒself, "_signature_cache_id", ϒs),
						)
						if !λ.Contains(λ.GetAttr(ϒself, "_player_cache", nil), ϒplayer_id) {
							ϒfunc = λ.Calm(ϒself, "_extract_signature_function", ϒvideo_id, ϒplayer_url, ϒs)
							λ.SetItem(λ.GetAttr(ϒself, "_player_cache", nil), ϒplayer_id, ϒfunc)
						}
						ϒfunc = λ.GetItem(λ.GetAttr(ϒself, "_player_cache", nil), ϒplayer_id)
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("youtube_print_sig_code"))) {
							λ.Calm(ϒself, "_print_sig_code", ϒfunc, ϒs)
						}
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒfunc, ϒs)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			YoutubeIE__get_ytplayer_config = λ.NewFunction("_get_ytplayer_config",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒconfig   λ.Object
						ϒpatterns λ.Object
						ϒself     = λargs[0]
						ϒvideo_id = λargs[1]
						ϒwebpage  = λargs[2]
					)
					ϒpatterns = λ.NewTuple(
						λ.StrLiteral(";ytplayer\\.config\\s*=\\s*({.+?});ytplayer"),
						λ.StrLiteral(";ytplayer\\.config\\s*=\\s*({.+?});"),
					)
					ϒconfig = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						ϒpatterns,
						ϒwebpage,
						λ.StrLiteral("ytplayer.config"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒconfig) {
						return λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Cal(ϒuppercase_escape, ϒconfig),
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: λ.False},
						})
					}
					return λ.None
				})
			YoutubeIE__extract_urls = λ.NewFunction("_extract_urls",
				[]λ.Param{
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentries λ.Object
						ϒmatches λ.Object
						ϒwebpage = λargs[0]
					)
					ϒentries = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒmobj λ.Object
									τmp0  λ.Object
									τmp1  λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.StrLiteral("(?x)\n            (?:\n                <iframe[^>]+?src=|\n                data-video-url=|\n                <embed[^>]+?src=|\n                embedSWF\\(?:\\s*|\n                <object[^>]+data=|\n                new\\s+SWFObject\\(\n            )\n            ([\"\\'])\n                (?P<url>(?:https?:)?//(?:www\\.)?youtube(?:-nocookie)?\\.com/\n                (?:embed|v|p)/[0-9A-Za-z_-]{11}.*?)\n            \\1"), ϒwebpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒmobj = τmp1
									λgy.Yield(λ.Cal(ϒunescapeHTML, λ.Calm(ϒmobj, "group", λ.StrLiteral("url"))))
								}
								return λ.None
							})
						})))
					λ.Calm(ϒentries, "extend", λ.Cal(λ.ListType, λ.Cal(λ.MapIteratorType, ϒunescapeHTML, λ.Cal(Ωre.ϒfindall, λ.StrLiteral("class=\"lazyYT\" data-youtube-id=\"([^\"]+)\""), ϒwebpage))))
					ϒmatches = λ.Cal(Ωre.ϒfindall, λ.StrLiteral("(?x)<div[^>]+\n            class=(?P<q1>[\\'\"])[^\\'\"]*\\byvii_single_video_player\\b[^\\'\"]*(?P=q1)[^>]+\n            data-video_id=(?P<q2>[\\'\"])([^\\'\"]+)(?P=q2)"), ϒwebpage)
					λ.Calm(ϒentries, "extend", λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒm   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, ϒmatches)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒm = τmp1
									λgy.Yield(λ.GetItem(ϒm, λ.Neg(λ.IntLiteral(1))))
								}
								return λ.None
							})
						})))
					return ϒentries
				})
			YoutubeIE__extract_urls = λ.Cal(λ.StaticMethodType, YoutubeIE__extract_urls)
			YoutubeIE__extract_url = λ.NewFunction("_extract_url",
				[]λ.Param{
					{Name: "webpage"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒurls    λ.Object
						ϒwebpage = λargs[0]
					)
					ϒurls = λ.Calm(YoutubeIE, "_extract_urls", ϒwebpage)
					return func() λ.Object {
						if λ.IsTrue(ϒurls) {
							return λ.GetItem(ϒurls, λ.IntLiteral(0))
						} else {
							return λ.None
						}
					}()
				})
			YoutubeIE__extract_url = λ.Cal(λ.StaticMethodType, YoutubeIE__extract_url)
			YoutubeIE_extract_id = λ.NewFunction("extract_id",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls      = λargs[0]
						ϒmobj     λ.Object
						ϒurl      = λargs[1]
						ϒvideo_id λ.Object
					)
					ϒmobj = λ.Cal(Ωre.ϒmatch, λ.GetAttr(ϒcls, "_VALID_URL", nil), ϒurl, Ωre.VERBOSE)
					if ϒmobj == λ.None {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.StrLiteral("Invalid URL: %s"), ϒurl))))
					}
					ϒvideo_id = λ.Calm(ϒmobj, "group", λ.IntLiteral(2))
					return ϒvideo_id
				})
			YoutubeIE_extract_id = λ.Cal(λ.ClassMethodType, YoutubeIE_extract_id)
			YoutubeIE__extract_chapters = λ.NewFunction("_extract_chapters",
				[]λ.Param{
					{Name: "description"},
					{Name: "duration"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒchapter_line  λ.Object
						ϒchapter_lines λ.Object
						ϒchapter_title λ.Object
						ϒchapters      λ.Object
						ϒdescription   = λargs[0]
						ϒduration      = λargs[1]
						ϒend_time      λ.Object
						ϒnext_num      λ.Object
						ϒstart_time    λ.Object
						ϒtime_point    λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
						τmp2           λ.Object
						τmp3           λ.Object
					)
					if !λ.IsTrue(ϒdescription) {
						return λ.None
					}
					ϒchapter_lines = λ.Cal(Ωre.ϒfindall, λ.StrLiteral("(?:^|<br\\s*/>)([^<]*<a[^>]+onclick=[\"\\']yt\\.www\\.watch\\.player\\.seekTo[^>]+>(\\d{1,2}:\\d{1,2}(?::\\d{1,2})?)</a>[^>]*)(?=$|<br\\s*/>)"), ϒdescription)
					if !λ.IsTrue(ϒchapter_lines) {
						return λ.None
					}
					ϒchapters = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Call(λ.EnumerateIteratorType, λ.NewArgs(ϒchapter_lines), λ.KWArgs{
						{Name: "start", Value: λ.IntLiteral(1)},
					}))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒnext_num = λ.GetItem(τmp2, λ.IntLiteral(0))
						τmp3 = λ.GetItem(τmp2, λ.IntLiteral(1))
						ϒchapter_line = λ.GetItem(τmp3, λ.IntLiteral(0))
						ϒtime_point = λ.GetItem(τmp3, λ.IntLiteral(1))
						ϒstart_time = λ.Cal(ϒparse_duration, ϒtime_point)
						if ϒstart_time == λ.None {
							continue
						}
						if λ.IsTrue(λ.Gt(ϒstart_time, ϒduration)) {
							break
						}
						ϒend_time = func() λ.Object {
							if λ.IsTrue(λ.Eq(ϒnext_num, λ.Cal(λ.BuiltinLen, ϒchapter_lines))) {
								return ϒduration
							} else {
								return λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒchapter_lines, ϒnext_num), λ.IntLiteral(1)))
							}
						}()
						if ϒend_time == λ.None {
							continue
						}
						if λ.IsTrue(λ.Gt(ϒend_time, ϒduration)) {
							ϒend_time = ϒduration
						}
						if λ.IsTrue(λ.Gt(ϒstart_time, ϒend_time)) {
							break
						}
						ϒchapter_title = λ.Calm(λ.Cal(Ωre.ϒsub, λ.StrLiteral("<a[^>]+>[^<]+</a>"), λ.StrLiteral(""), ϒchapter_line), "strip", λ.StrLiteral(" \t-"))
						ϒchapter_title = λ.Cal(Ωre.ϒsub, λ.StrLiteral("\\s+"), λ.StrLiteral(" "), ϒchapter_title)
						λ.Calm(ϒchapters, "append", λ.DictLiteral(map[string]λ.Object{
							"start_time": ϒstart_time,
							"end_time":   ϒend_time,
							"title":      ϒchapter_title,
						}))
					}
					return ϒchapters
				})
			YoutubeIE__extract_chapters = λ.Cal(λ.StaticMethodType, YoutubeIE__extract_chapters)
			YoutubeIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ASSETS_RE                    λ.Object
						ϒ_extract_count              λ.Object
						ϒ_extract_filesize           λ.Object
						ϒa_format                    λ.Object
						ϒadd_dash_mpd                λ.Object
						ϒadd_dash_mpd_pr             λ.Object
						ϒage_gate                    λ.Object
						ϒalbum                       λ.Object
						ϒargs                        λ.Object
						ϒartist                      λ.Object
						ϒautomatic_captions          λ.Object
						ϒaverage_rating              λ.Object
						ϒcategory                    λ.Object
						ϒchannel_id                  λ.Object
						ϒchannel_url                 λ.Object
						ϒchapters                    λ.Object
						ϒcipher                      λ.Object
						ϒcodecs                      λ.Object
						ϒcomponent                   λ.Object
						ϒcountries                   λ.Object
						ϒdash_formats                λ.Object
						ϒdash_mpd_fatal              λ.Object
						ϒdash_mpds                   λ.Object
						ϒdata                        λ.Object
						ϒdct                         λ.Object
						ϒdecrypt_sig                 λ.Object
						ϒdescription_original        λ.Object
						ϒdf                          λ.Object
						ϒdislike_count               λ.Object
						ϒembed_url                   λ.Object
						ϒembed_webpage               λ.Object
						ϒencoded_url_map             λ.Object
						ϒencrypted_sig               λ.Object
						ϒend_time                    λ.Object
						ϒentries                     λ.Object
						ϒepisode_number              λ.Object
						ϒerror_message               λ.Object
						ϒextract_meta                λ.Object
						ϒextract_player_response     λ.Object
						ϒextract_unavailable_message λ.Object
						ϒextract_view_count          λ.Object
						ϒf                           λ.Object
						ϒfeed                        λ.Object
						ϒfeed_data                   λ.Object
						ϒfeed_entry                  λ.Object
						ϒfeed_id                     λ.Object
						ϒfeed_ids                    λ.Object
						ϒfeed_title                  λ.Object
						ϒfilesize                    λ.Object
						ϒfmt                         λ.Object
						ϒfmt_list                    λ.Object
						ϒformat_id                   λ.Object
						ϒformats                     λ.Object
						ϒformats_spec                λ.Object
						ϒfps                         λ.Object
						ϒh                           λ.Object
						ϒheight                      λ.Object
						ϒinvideo_url                 λ.Object
						ϒis_live                     λ.Object
						ϒitag                        λ.Object
						ϒjsplayer_url_json           λ.Object
						ϒkey                         λ.Object
						ϒkind                        λ.Object
						ϒkind_ext                    λ.Object
						ϒlike_count                  λ.Object
						ϒm3u8_formats                λ.Object
						ϒm_cat_container             λ.Object
						ϒm_episode                   λ.Object
						ϒm_music                     λ.Object
						ϒm_thumb                     λ.Object
						ϒmanifest_url                λ.Object
						ϒmobj                        λ.Object
						ϒmore_fields                 λ.Object
						ϒmpd_url                     λ.Object
						ϒmultifeed_metadata_list     λ.Object
						ϒparsed_url                  λ.Object
						ϒparts_sizes                 λ.Object
						ϒpl_response                 λ.Object
						ϒplayer_desc                 λ.Object
						ϒplayer_response             λ.Object
						ϒplayer_type                 λ.Object
						ϒplayer_url                  λ.Object
						ϒplayer_url_json             λ.Object
						ϒplayer_version              λ.Object
						ϒproto                       λ.Object
						ϒqs                          λ.Object
						ϒquality                     λ.Object
						ϒquality_label               λ.Object
						ϒquery                       λ.Object
						ϒratio                       λ.Object
						ϒreason                      λ.Object
						ϒregions_allowed             λ.Object
						ϒrelease_date                λ.Object
						ϒrelease_year                λ.Object
						ϒreplace_url                 λ.Object
						ϒseason_number               λ.Object
						ϒself                        = λargs[0]
						ϒseries                      λ.Object
						ϒsignature                   λ.Object
						ϒsmuggled_data               λ.Object
						ϒsp                          λ.Object
						ϒspec                        λ.Object
						ϒstart_time                  λ.Object
						ϒstream_type                 λ.Object
						ϒstreaming_formats           λ.Object
						ϒstretched_m                 λ.Object
						ϒtbr                         λ.Object
						ϒtitle                       λ.Object
						ϒtrack                       λ.Object
						ϒtype_                       λ.Object
						ϒtype_split                  λ.Object
						ϒunavailable_message         λ.Object
						ϒupload_date                 λ.Object
						ϒurl                         = λargs[1]
						ϒurl_data                    λ.Object
						ϒurlh                        λ.Object
						ϒvalue                       λ.Object
						ϒvideo_alt_title             λ.Object
						ϒvideo_annotations           λ.Object
						ϒvideo_categories            λ.Object
						ϒvideo_creator               λ.Object
						ϒvideo_description           λ.Object
						ϒvideo_details               λ.Object
						ϒvideo_duration              λ.Object
						ϒvideo_id                    λ.Object
						ϒvideo_info                  λ.Object
						ϒvideo_info_url              λ.Object
						ϒvideo_info_webpage          λ.Object
						ϒvideo_license               λ.Object
						ϒvideo_subtitles             λ.Object
						ϒvideo_tags                  λ.Object
						ϒvideo_thumbnail             λ.Object
						ϒvideo_title                 λ.Object
						ϒvideo_uploader              λ.Object
						ϒvideo_uploader_id           λ.Object
						ϒvideo_uploader_url          λ.Object
						ϒvideo_webpage               λ.Object
						ϒview_count                  λ.Object
						ϒw                           λ.Object
						ϒwidth                       λ.Object
						ϒwidth_height                λ.Object
						ϒxsrf_field_name             λ.Object
						ϒxsrf_token                  λ.Object
						ϒytplayer_config             λ.Object
						τmp0                         λ.Object
						τmp1                         λ.Object
						τmp2                         λ.Object
						τmp3                         λ.Object
						τmp4                         λ.Object
						τmp5                         λ.Object
					)
					_ = τmp2
					_ = τmp3
					τmp0 = λ.Cal(ϒunsmuggle_url, ϒurl, λ.DictLiteral(map[λ.Object]λ.Object{}))
					ϒurl = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒsmuggled_data = λ.GetItem(τmp0, λ.IntLiteral(1))
					ϒproto = func() λ.Object {
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("prefer_insecure"), λ.False)) {
							return λ.StrLiteral("http")
						} else {
							return λ.StrLiteral("https")
						}
					}()
					ϒstart_time = λ.None
					ϒend_time = λ.None
					ϒparsed_url = λ.Cal(ϒcompat_urllib_parse_urlparse, ϒurl)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewList(
						λ.GetAttr(ϒparsed_url, "fragment", nil),
						λ.GetAttr(ϒparsed_url, "query", nil),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒcomponent = τmp1
						ϒquery = λ.Cal(ϒcompat_parse_qs, ϒcomponent)
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒstart_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.StrLiteral("t")))
							}
						}()) {
							ϒstart_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.StrLiteral("t")), λ.IntLiteral(0)))
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒstart_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.StrLiteral("start")))
							}
						}()) {
							ϒstart_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.StrLiteral("start")), λ.IntLiteral(0)))
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒend_time == λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒquery, λ.StrLiteral("end")))
							}
						}()) {
							ϒend_time = λ.Cal(ϒparse_duration, λ.GetItem(λ.GetItem(ϒquery, λ.StrLiteral("end")), λ.IntLiteral(0)))
						}
					}
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.GetAttr(ϒself, "_NEXT_URL_RE", nil), ϒurl)
					if λ.IsTrue(ϒmobj) {
						ϒurl = λ.Add(λ.Add(ϒproto, λ.StrLiteral("://www.youtube.com/")), λ.Calm(λ.Cal(ϒcompat_urllib_parse_unquote, λ.Calm(ϒmobj, "group", λ.IntLiteral(1))), "lstrip", λ.StrLiteral("/")))
					}
					ϒvideo_id = λ.Calm(ϒself, "extract_id", ϒurl)
					ϒurl = λ.Add(ϒproto, λ.Mod(λ.StrLiteral("://www.youtube.com/watch?v=%s&gl=US&hl=en&has_verified=1&bpctr=9999999999"), ϒvideo_id))
					τmp0 = λ.Calm(ϒself, "_download_webpage_handle", ϒurl, ϒvideo_id)
					ϒvideo_webpage = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					ϒqs = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(λ.Cal(ϒcompat_urllib_parse_urlparse, λ.Calm(ϒurlh, "geturl")), "query", nil))
					ϒvideo_id = func() λ.Object {
						if λv := λ.GetItem(λ.Calm(ϒqs, "get", λ.StrLiteral("v"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
							return λv
						} else {
							return ϒvideo_id
						}
					}()
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("swfConfig.*?\"(https?:\\\\/\\\\/.*?watch.*?-.*?\\.swf)\""), ϒvideo_webpage)
					if ϒmobj != λ.None {
						ϒplayer_url = λ.Cal(Ωre.ϒsub, λ.StrLiteral("\\\\(.)"), λ.StrLiteral("\\1"), λ.Calm(ϒmobj, "group", λ.IntLiteral(1)))
					} else {
						ϒplayer_url = λ.None
					}
					ϒdash_mpds = λ.NewList()
					ϒadd_dash_mpd = λ.NewFunction("add_dash_mpd",
						[]λ.Param{
							{Name: "video_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdash_mpd   λ.Object
								ϒvideo_info = λargs[0]
							)
							ϒdash_mpd = λ.Calm(ϒvideo_info, "get", λ.StrLiteral("dashmpd"))
							if λ.IsTrue(func() λ.Object {
								if λv := ϒdash_mpd; !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.Contains(ϒdash_mpds, λ.GetItem(ϒdash_mpd, λ.IntLiteral(0))))
								}
							}()) {
								λ.Calm(ϒdash_mpds, "append", λ.GetItem(ϒdash_mpd, λ.IntLiteral(0)))
							}
							return λ.None
						})
					ϒadd_dash_mpd_pr = λ.NewFunction("add_dash_mpd_pr",
						[]λ.Param{
							{Name: "pl_response"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒdash_mpd    λ.Object
								ϒpl_response = λargs[0]
							)
							ϒdash_mpd = λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒpl_response, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("streamingData")), λ.StrLiteral("dashManifestUrl"))
								}), ϒcompat_str))
							if λ.IsTrue(func() λ.Object {
								if λv := ϒdash_mpd; !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.Contains(ϒdash_mpds, ϒdash_mpd))
								}
							}()) {
								λ.Calm(ϒdash_mpds, "append", ϒdash_mpd)
							}
							return λ.None
						})
					ϒis_live = λ.None
					ϒview_count = λ.None
					ϒextract_view_count = λ.NewFunction("extract_view_count",
						[]λ.Param{
							{Name: "v_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒv_info = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.Cal(ϒtry_get, ϒv_info, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("view_count")), λ.IntLiteral(0))
								})))
						})
					ϒextract_player_response = λ.NewFunction("extract_player_response",
						[]λ.Param{
							{Name: "player_response"},
							{Name: "video_id"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒpl_response     λ.Object
								ϒplayer_response = λargs[0]
								ϒvideo_id        = λargs[1]
							)
							ϒpl_response = λ.Cal(ϒstr_or_none, ϒplayer_response)
							if !λ.IsTrue(ϒpl_response) {
								return λ.None
							}
							ϒpl_response = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
								ϒpl_response,
								ϒvideo_id,
							), λ.KWArgs{
								{Name: "fatal", Value: λ.False},
							})
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpl_response, λ.DictType)) {
								λ.Cal(ϒadd_dash_mpd_pr, ϒpl_response)
								return ϒpl_response
							}
							return λ.None
						})
					ϒplayer_response = λ.DictLiteral(map[λ.Object]λ.Object{})
					ϒvideo_info = λ.DictLiteral(map[λ.Object]λ.Object{})
					ϒembed_webpage = λ.None
					if λ.Cal(Ωre.ϒsearch, λ.StrLiteral("player-age-gate-content\">"), ϒvideo_webpage) != λ.None {
						ϒage_gate = λ.True
						ϒurl = λ.Add(ϒproto, λ.Mod(λ.StrLiteral("://www.youtube.com/embed/%s"), ϒvideo_id))
						ϒembed_webpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒvideo_id, λ.StrLiteral("Downloading embed webpage"))
						ϒdata = λ.Cal(ϒcompat_urllib_parse_urlencode, λ.DictLiteral(map[string]λ.Object{
							"video_id": ϒvideo_id,
							"eurl":     λ.Add(λ.StrLiteral("https://youtube.googleapis.com/v/"), ϒvideo_id),
							"sts": λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("\"sts\"\\s*:\\s*(\\d+)"),
								ϒembed_webpage,
								λ.StrLiteral("sts"),
							), λ.KWArgs{
								{Name: "default", Value: λ.StrLiteral("")},
							}),
						}))
						ϒvideo_info_url = λ.Add(λ.Add(ϒproto, λ.StrLiteral("://www.youtube.com/get_video_info?")), ϒdata)
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
									ϒvideo_info_webpage = λ.None
								}},
							)
							ϒvideo_info_webpage = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
								ϒvideo_info_url,
								ϒvideo_id,
							), λ.KWArgs{
								{Name: "note", Value: λ.StrLiteral("Refetching age-gated info webpage")},
								{Name: "errnote", Value: λ.StrLiteral("unable to download video info webpage")},
							})
							return λ.BlockExitNormally, nil
						}()
						if λ.IsTrue(ϒvideo_info_webpage) {
							ϒvideo_info = λ.Cal(ϒcompat_parse_qs, ϒvideo_info_webpage)
							ϒpl_response = λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("player_response"), λ.NewList(λ.None)), λ.IntLiteral(0))
							ϒplayer_response = λ.Cal(ϒextract_player_response, ϒpl_response, ϒvideo_id)
							λ.Cal(ϒadd_dash_mpd, ϒvideo_info)
							ϒview_count = λ.Cal(ϒextract_view_count, ϒvideo_info)
						}
					} else {
						ϒage_gate = λ.False
						ϒytplayer_config = λ.Calm(ϒself, "_get_ytplayer_config", ϒvideo_id, ϒvideo_webpage)
						if λ.IsTrue(ϒytplayer_config) {
							ϒargs = λ.GetItem(ϒytplayer_config, λ.StrLiteral("args"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(ϒargs, "get", λ.StrLiteral("url_encoded_fmt_stream_map")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒargs, "get", λ.StrLiteral("hlsvp"))
								}
							}()) {
								ϒvideo_info = λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒk   λ.Object
												ϒv   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
												τmp2 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒargs, "items"))
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												τmp2 = τmp1
												ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
												ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
												λgy.Yield(λ.NewTuple(
													ϒk,
													λ.NewList(ϒv),
												))
											}
											return λ.None
										})
									})))
								λ.Cal(ϒadd_dash_mpd, ϒvideo_info)
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(!λ.IsTrue(ϒvideo_info)); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒargs, "get", λ.StrLiteral("ypc_vid"))
								}
							}()) {
								return λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(
									λ.GetItem(ϒargs, λ.StrLiteral("ypc_vid")),
									λ.Calm(YoutubeIE, "ie_key"),
								), λ.KWArgs{
									{Name: "video_id", Value: λ.GetItem(ϒargs, λ.StrLiteral("ypc_vid"))},
								})
							}
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(λ.Calm(ϒargs, "get", λ.StrLiteral("livestream")), λ.StrLiteral("1")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Calm(ϒargs, "get", λ.StrLiteral("live_playback")), λ.IntLiteral(1))
								}
							}()) {
								ϒis_live = λ.True
							}
							if !λ.IsTrue(ϒplayer_response) {
								ϒplayer_response = λ.Cal(ϒextract_player_response, λ.Calm(ϒargs, "get", λ.StrLiteral("player_response")), ϒvideo_id)
							}
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒvideo_info)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("youtube_include_dash_manifest"), λ.True)
							}
						}()) {
							λ.Cal(ϒadd_dash_mpd_pr, ϒplayer_response)
						}
					}
					ϒextract_unavailable_message = λ.NewFunction("extract_unavailable_message",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒkind     λ.Object
								ϒmessages λ.Object
								ϒmsg      λ.Object
								ϒtag      λ.Object
								τmp0      λ.Object
								τmp1      λ.Object
								τmp2      λ.Object
							)
							ϒmessages = λ.NewList()
							τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
								λ.NewTuple(
									λ.StrLiteral("h1"),
									λ.StrLiteral("message"),
								),
								λ.NewTuple(
									λ.StrLiteral("div"),
									λ.StrLiteral("submessage"),
								),
							))
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								τmp2 = τmp1
								ϒtag = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒkind = λ.GetItem(τmp2, λ.IntLiteral(1))
								ϒmsg = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
									λ.Call(λ.GetAttr(λ.StrLiteral("(?s)<{tag}[^>]+id=[\"\\']unavailable-{kind}[\"\\'][^>]*>(.+?)</{tag}>"), "format", nil), nil, λ.KWArgs{
										{Name: "tag", Value: ϒtag},
										{Name: "kind", Value: ϒkind},
									}),
									ϒvideo_webpage,
									λ.Mod(λ.StrLiteral("unavailable %s"), ϒkind),
								), λ.KWArgs{
									{Name: "default", Value: λ.None},
								})
								if λ.IsTrue(ϒmsg) {
									λ.Calm(ϒmessages, "append", ϒmsg)
								}
							}
							if λ.IsTrue(ϒmessages) {
								return λ.Calm(λ.StrLiteral("\n"), "join", ϒmessages)
							}
							return λ.None
						})
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(ϒvideo_info)); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒplayer_response))
						}
					}()) {
						ϒunavailable_message = λ.Cal(ϒextract_unavailable_message)
						if !λ.IsTrue(ϒunavailable_message) {
							ϒunavailable_message = λ.StrLiteral("Unable to extract video data")
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.StrLiteral("YouTube said: %s"), ϒunavailable_message)), λ.KWArgs{
							{Name: "expected", Value: λ.True},
							{Name: "video_id", Value: ϒvideo_id},
						})))
					}
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒvideo_info, λ.DictType)) {
						ϒvideo_info = λ.DictLiteral(map[λ.Object]λ.Object{})
					}
					ϒvideo_details = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.StrLiteral("videoDetails"))
							}), λ.DictType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}()
					ϒvideo_title = func() λ.Object {
						if λv := λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("title"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒvideo_details, "get", λ.StrLiteral("title"))
						}
					}()
					if !λ.IsTrue(ϒvideo_title) {
						λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.StrLiteral("Unable to extract video title"))
						ϒvideo_title = λ.StrLiteral("_")
					}
					τmp1 = λ.Cal(ϒget_element_by_id, λ.StrLiteral("eow-description"), ϒvideo_webpage)
					ϒdescription_original = τmp1
					ϒvideo_description = τmp1
					if λ.IsTrue(ϒvideo_description) {
						ϒreplace_url = λ.NewFunction("replace_url",
							[]λ.Param{
								{Name: "m"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒm                = λargs[0]
									ϒparsed_redir_url λ.Object
									ϒq                λ.Object
									ϒqs               λ.Object
									ϒredir_url        λ.Object
								)
								ϒredir_url = λ.Cal(Ωparse.ϒurljoin, ϒurl, λ.Calm(ϒm, "group", λ.IntLiteral(1)))
								ϒparsed_redir_url = λ.Cal(ϒcompat_urllib_parse_urlparse, ϒredir_url)
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(Ωre.ϒsearch, λ.StrLiteral("^(?:www\\.)?(?:youtube(?:-nocookie)?\\.com|youtu\\.be)$"), λ.GetAttr(ϒparsed_redir_url, "netloc", nil)); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Eq(λ.GetAttr(ϒparsed_redir_url, "path", nil), λ.StrLiteral("/redirect"))
									}
								}()) {
									ϒqs = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(ϒparsed_redir_url, "query", nil))
									ϒq = λ.Calm(ϒqs, "get", λ.StrLiteral("q"))
									if λ.IsTrue(func() λ.Object {
										if λv := ϒq; !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.GetItem(ϒq, λ.IntLiteral(0))
										}
									}()) {
										return λ.GetItem(ϒq, λ.IntLiteral(0))
									}
								}
								return ϒredir_url
							})
						τmp1 = λ.Cal(Ωre.ϒsub, λ.StrLiteral("(?x)\n                <a\\s+\n                    (?:[a-zA-Z-]+=\"[^\"]*\"\\s+)*?\n                    (?:title|href)=\"([^\"]+)\"\\s+\n                    (?:[a-zA-Z-]+=\"[^\"]*\"\\s+)*?\n                    class=\"[^\"]*\"[^>]*>\n                [^<]+\\.{3}\\s*\n                </a>\n            "), ϒreplace_url, ϒvideo_description)
						ϒdescription_original = τmp1
						ϒvideo_description = τmp1
						ϒvideo_description = λ.Cal(ϒclean_html, ϒvideo_description)
					} else {
						ϒvideo_description = func() λ.Object {
							if λv := λ.Calm(ϒself, "_html_search_meta", λ.StrLiteral("description"), ϒvideo_webpage); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒvideo_details, "get", λ.StrLiteral("shortDescription"))
							}
						}()
					}
					if !λ.IsTrue(λ.Calm(ϒsmuggled_data, "get", λ.StrLiteral("force_singlefeed"), λ.False)) {
						if !λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("noplaylist"))) {
							ϒmultifeed_metadata_list = func() λ.Object {
								if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("multicamera")), λ.StrLiteral("playerLegacyMulticameraRenderer")), λ.StrLiteral("metadataList"))
									}), ϒcompat_str); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("multifeed_metadata_list")), λ.IntLiteral(0))
										}), ϒcompat_str)
								}
							}()
							if λ.IsTrue(ϒmultifeed_metadata_list) {
								ϒentries = λ.NewList()
								ϒfeed_ids = λ.NewList()
								τmp1 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒmultifeed_metadata_list, "split", λ.StrLiteral(",")))
								for {
									if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
										break
									}
									ϒfeed = τmp0
									ϒfeed_data = λ.Cal(ϒcompat_parse_qs, λ.Cal(ϒcompat_urllib_parse_unquote_plus, ϒfeed))
									ϒfeed_entry = λ.NewFunction("feed_entry",
										[]λ.Param{
											{Name: "name"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒname = λargs[0]
											)
											return λ.Cal(ϒtry_get, ϒfeed_data, λ.NewFunction("<lambda>",
												[]λ.Param{
													{Name: "x"},
												},
												0, false, false,
												func(λargs []λ.Object) λ.Object {
													var (
														ϒx = λargs[0]
													)
													return λ.GetItem(λ.GetItem(ϒx, ϒname), λ.IntLiteral(0))
												}), ϒcompat_str)
										})
									ϒfeed_id = λ.Cal(ϒfeed_entry, λ.StrLiteral("id"))
									if !λ.IsTrue(ϒfeed_id) {
										continue
									}
									ϒfeed_title = λ.Cal(ϒfeed_entry, λ.StrLiteral("title"))
									ϒtitle = ϒvideo_title
									if λ.IsTrue(ϒfeed_title) {
										τmp2 = λ.IAdd(ϒtitle, λ.Mod(λ.StrLiteral(" (%s)"), ϒfeed_title))
										ϒtitle = τmp2
									}
									λ.Calm(ϒentries, "append", λ.DictLiteral(map[string]λ.Object{
										"_type":  λ.StrLiteral("url_transparent"),
										"ie_key": λ.StrLiteral("Youtube"),
										"url": λ.Cal(ϒsmuggle_url, λ.Mod(λ.StrLiteral("%s://www.youtube.com/watch?v=%s"), λ.NewTuple(
											ϒproto,
											λ.GetItem(λ.GetItem(ϒfeed_data, λ.StrLiteral("id")), λ.IntLiteral(0)),
										)), λ.DictLiteral(map[string]λ.Object{
											"force_singlefeed": λ.True,
										})),
										"title": ϒtitle,
									}))
									λ.Calm(ϒfeed_ids, "append", ϒfeed_id)
								}
								λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading multifeed video (%s) - add --no-playlist to just download video %s"), λ.NewTuple(
									λ.Calm(λ.StrLiteral(", "), "join", ϒfeed_ids),
									ϒvideo_id,
								)))
								return λ.Calm(ϒself, "playlist_result", ϒentries, ϒvideo_id, ϒvideo_title, ϒvideo_description)
							}
						} else {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading just video %s because of --no-playlist"), ϒvideo_id))
						}
					}
					if ϒview_count == λ.None {
						ϒview_count = λ.Cal(ϒextract_view_count, ϒvideo_info)
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒview_count == λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return ϒvideo_details
						}
					}()) {
						ϒview_count = λ.Cal(ϒint_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("viewCount")))
					}
					if ϒis_live == λ.None {
						ϒis_live = λ.Cal(ϒbool_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("isLive")))
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒvideo_info, λ.StrLiteral("ypc_video_rental_bar_text"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.Contains(ϒvideo_info, λ.StrLiteral("author")))
						}
					}()) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("\"rental\" videos not supported. See https://github.com/ytdl-org/youtube-dl/issues/359 for more information.")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					ϒ_extract_filesize = λ.NewFunction("_extract_filesize",
						[]λ.Param{
							{Name: "media_url"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒmedia_url = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("\\bclen[=/](\\d+)"),
								ϒmedia_url,
								λ.StrLiteral("filesize"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						})
					ϒstreaming_formats = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("streamingData")), λ.StrLiteral("formats"))
							}), λ.ListType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}()
					λ.Calm(ϒstreaming_formats, "extend", func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("streamingData")), λ.StrLiteral("adaptiveFormats"))
							}), λ.ListType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}())
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒvideo_info, λ.StrLiteral("conn"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.GetItem(λ.GetItem(ϒvideo_info, λ.StrLiteral("conn")), λ.IntLiteral(0)), "startswith", λ.StrLiteral("rtmp"))
						}
					}()) {
						λ.Calm(ϒself, "report_rtmp_download")
						ϒformats = λ.NewList(λ.DictLiteral(map[string]λ.Object{
							"format_id":  λ.StrLiteral("_rtmp"),
							"protocol":   λ.StrLiteral("rtmp"),
							"url":        λ.GetItem(λ.GetItem(ϒvideo_info, λ.StrLiteral("conn")), λ.IntLiteral(0)),
							"player_url": ϒplayer_url,
						}))
					} else {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒis_live)); !λ.IsTrue(λv) {
								return λv
							} else {
								return func() λ.Object {
									if λv := ϒstreaming_formats; λ.IsTrue(λv) {
										return λv
									} else if λv := λ.Ge(λ.Cal(λ.BuiltinLen, λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("url_encoded_fmt_stream_map"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0))), λ.IntLiteral(1)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Ge(λ.Cal(λ.BuiltinLen, λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("adaptive_fmts"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0))), λ.IntLiteral(1))
									}
								}()
							}
						}()) {
							ϒencoded_url_map = λ.Add(λ.Add(λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("url_encoded_fmt_stream_map"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0)), λ.StrLiteral(",")), λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("adaptive_fmts"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0)))
							if λ.Contains(ϒencoded_url_map, λ.StrLiteral("rtmpe%3Dyes")) {
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("rtmpe downloads are not supported, see https://github.com/ytdl-org/youtube-dl/issues/343 for more information.")), λ.KWArgs{
									{Name: "expected", Value: λ.True},
								})))
							}
							ϒformats = λ.NewList()
							ϒformats_spec = λ.DictLiteral(map[λ.Object]λ.Object{})
							ϒfmt_list = λ.GetItem(λ.Calm(ϒvideo_info, "get", λ.StrLiteral("fmt_list"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0))
							if λ.IsTrue(ϒfmt_list) {
								τmp1 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒfmt_list, "split", λ.StrLiteral(",")))
								for {
									if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
										break
									}
									ϒfmt = τmp0
									ϒspec = λ.Calm(ϒfmt, "split", λ.StrLiteral("/"))
									if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒspec), λ.IntLiteral(1))) {
										ϒwidth_height = λ.Calm(λ.GetItem(ϒspec, λ.IntLiteral(1)), "split", λ.StrLiteral("x"))
										if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒwidth_height), λ.IntLiteral(2))) {
											λ.SetItem(ϒformats_spec, λ.GetItem(ϒspec, λ.IntLiteral(0)), λ.DictLiteral(map[string]λ.Object{
												"resolution": λ.GetItem(ϒspec, λ.IntLiteral(1)),
												"width":      λ.Cal(ϒint_or_none, λ.GetItem(ϒwidth_height, λ.IntLiteral(0))),
												"height":     λ.Cal(ϒint_or_none, λ.GetItem(ϒwidth_height, λ.IntLiteral(1))),
											}))
										}
									}
								}
							}
							τmp1 = λ.Cal(λ.BuiltinIter, ϒstreaming_formats)
							for {
								if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
									break
								}
								ϒfmt = τmp0
								ϒitag = λ.Cal(ϒstr_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("itag")))
								if !λ.IsTrue(ϒitag) {
									continue
								}
								ϒquality = λ.Calm(ϒfmt, "get", λ.StrLiteral("quality"))
								ϒquality_label = func() λ.Object {
									if λv := λ.Calm(ϒfmt, "get", λ.StrLiteral("qualityLabel")); λ.IsTrue(λv) {
										return λv
									} else {
										return ϒquality
									}
								}()
								λ.SetItem(ϒformats_spec, ϒitag, λ.DictLiteral(map[string]λ.Object{
									"asr":         λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("audioSampleRate"))),
									"filesize":    λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("contentLength"))),
									"format_note": ϒquality_label,
									"fps":         λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("fps"))),
									"height":      λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("height"))),
									"tbr": func() λ.Object {
										if λ.IsTrue(λ.Ne(ϒitag, λ.StrLiteral("43"))) {
											return λ.Cal(ϒfloat_or_none, func() λ.Object {
												if λv := λ.Calm(ϒfmt, "get", λ.StrLiteral("averageBitrate")); λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Calm(ϒfmt, "get", λ.StrLiteral("bitrate"))
												}
											}(), λ.IntLiteral(1000))
										} else {
											return λ.None
										}
									}(),
									"width": λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("width"))),
								}))
							}
							τmp1 = λ.Cal(λ.BuiltinIter, ϒstreaming_formats)
							for {
								if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
									break
								}
								ϒfmt = τmp0
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Calm(ϒfmt, "get", λ.StrLiteral("drmFamilies")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒfmt, "get", λ.StrLiteral("drm_families"))
									}
								}()) {
									continue
								}
								ϒurl = λ.Cal(ϒurl_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("url")))
								if !λ.IsTrue(ϒurl) {
									ϒcipher = λ.Calm(ϒfmt, "get", λ.StrLiteral("cipher"))
									if !λ.IsTrue(ϒcipher) {
										continue
									}
									ϒurl_data = λ.Cal(ϒcompat_parse_qs, ϒcipher)
									ϒurl = λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒurl_data, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("url")), λ.IntLiteral(0))
										}), ϒcompat_str))
									if !λ.IsTrue(ϒurl) {
										continue
									}
								} else {
									ϒcipher = λ.None
									ϒurl_data = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(λ.Cal(ϒcompat_urllib_parse_urlparse, ϒurl), "query", nil))
								}
								ϒstream_type = λ.Cal(ϒint_or_none, λ.Cal(ϒtry_get, ϒurl_data, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("stream_type")), λ.IntLiteral(0))
									})))
								if λ.IsTrue(λ.Eq(ϒstream_type, λ.IntLiteral(3))) {
									continue
								}
								ϒformat_id = func() λ.Object {
									if λv := λ.Calm(ϒfmt, "get", λ.StrLiteral("itag")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.GetItem(λ.GetItem(ϒurl_data, λ.StrLiteral("itag")), λ.IntLiteral(0))
									}
								}()
								if !λ.IsTrue(ϒformat_id) {
									continue
								}
								ϒformat_id = λ.Cal(ϒcompat_str, ϒformat_id)
								if λ.IsTrue(ϒcipher) {
									if λ.IsTrue(func() λ.Object {
										if λv := λ.NewBool(λ.Contains(ϒurl_data, λ.StrLiteral("s"))); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("youtube_include_dash_manifest"), λ.True)
										}
									}()) {
										ASSETS_RE = λ.StrLiteral("\"assets\":.+?\"js\":\\s*(\"[^\"]+\")")
										ϒjsplayer_url_json = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
											ASSETS_RE,
											func() λ.Object {
												if λ.IsTrue(ϒage_gate) {
													return ϒembed_webpage
												} else {
													return ϒvideo_webpage
												}
											}(),
											λ.StrLiteral("JS player URL (1)"),
										), λ.KWArgs{
											{Name: "default", Value: λ.None},
										})
										if λ.IsTrue(func() λ.Object {
											if λv := λ.NewBool(!λ.IsTrue(ϒjsplayer_url_json)); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(!λ.IsTrue(ϒage_gate))
											}
										}()) {
											if ϒembed_webpage == λ.None {
												ϒembed_url = λ.Add(ϒproto, λ.Mod(λ.StrLiteral("://www.youtube.com/embed/%s"), ϒvideo_id))
												ϒembed_webpage = λ.Calm(ϒself, "_download_webpage", ϒembed_url, ϒvideo_id, λ.StrLiteral("Downloading embed webpage"))
											}
											ϒjsplayer_url_json = λ.Calm(ϒself, "_search_regex", ASSETS_RE, ϒembed_webpage, λ.StrLiteral("JS player URL"))
										}
										ϒplayer_url = λ.Cal(Ωjson.ϒloads, ϒjsplayer_url_json)
										if ϒplayer_url == λ.None {
											ϒplayer_url_json = λ.Calm(ϒself, "_search_regex", λ.StrLiteral("ytplayer\\.config.*?\"url\"\\s*:\\s*(\"[^\"]+\")"), ϒvideo_webpage, λ.StrLiteral("age gate player URL"))
											ϒplayer_url = λ.Cal(Ωjson.ϒloads, ϒplayer_url_json)
										}
									}
									if λ.Contains(ϒurl_data, λ.StrLiteral("sig")) {
										τmp2 = λ.IAdd(ϒurl, λ.Add(λ.StrLiteral("&signature="), λ.GetItem(λ.GetItem(ϒurl_data, λ.StrLiteral("sig")), λ.IntLiteral(0))))
										ϒurl = τmp2
									} else {
										if λ.Contains(ϒurl_data, λ.StrLiteral("s")) {
											ϒencrypted_sig = λ.GetItem(λ.GetItem(ϒurl_data, λ.StrLiteral("s")), λ.IntLiteral(0))
											if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("verbose"))) {
												if ϒplayer_url == λ.None {
													ϒplayer_desc = λ.StrLiteral("unknown")
												} else {
													τmp2 = λ.Calm(ϒself, "_extract_player_info", ϒplayer_url)
													ϒplayer_type = λ.GetItem(τmp2, λ.IntLiteral(0))
													ϒplayer_version = λ.GetItem(τmp2, λ.IntLiteral(1))
													ϒplayer_desc = λ.Mod(λ.StrLiteral("%s player %s"), λ.NewTuple(
														func() λ.Object {
															if λ.IsTrue(λ.Eq(ϒplayer_type, λ.StrLiteral("swf"))) {
																return λ.StrLiteral("flash")
															} else {
																return λ.StrLiteral("html5")
															}
														}(),
														ϒplayer_version,
													))
												}
												ϒparts_sizes = λ.Calm(ϒself, "_signature_cache_id", ϒencrypted_sig)
												λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("{%s} signature length %s, %s"), λ.NewTuple(
													ϒformat_id,
													ϒparts_sizes,
													ϒplayer_desc,
												)))
											}
											ϒsignature = λ.Calm(ϒself, "_decrypt_signature", ϒencrypted_sig, ϒvideo_id, ϒplayer_url, ϒage_gate)
											ϒsp = func() λ.Object {
												if λv := λ.Cal(ϒtry_get, ϒurl_data, λ.NewFunction("<lambda>",
													[]λ.Param{
														{Name: "x"},
													},
													0, false, false,
													func(λargs []λ.Object) λ.Object {
														var (
															ϒx = λargs[0]
														)
														return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("sp")), λ.IntLiteral(0))
													}), ϒcompat_str); λ.IsTrue(λv) {
													return λv
												} else {
													return λ.StrLiteral("signature")
												}
											}()
											τmp2 = λ.IAdd(ϒurl, λ.Mod(λ.StrLiteral("&%s=%s"), λ.NewTuple(
												ϒsp,
												ϒsignature,
											)))
											ϒurl = τmp2
										}
									}
								}
								if !λ.Contains(ϒurl, λ.StrLiteral("ratebypass")) {
									τmp2 = λ.IAdd(ϒurl, λ.StrLiteral("&ratebypass=yes"))
									ϒurl = τmp2
								}
								ϒdct = λ.DictLiteral(map[string]λ.Object{
									"format_id":  ϒformat_id,
									"url":        ϒurl,
									"player_url": ϒplayer_url,
								})
								if λ.Contains(λ.GetAttr(ϒself, "_formats", nil), ϒformat_id) {
									λ.Calm(ϒdct, "update", λ.GetItem(λ.GetAttr(ϒself, "_formats", nil), ϒformat_id))
								}
								if λ.Contains(ϒformats_spec, ϒformat_id) {
									λ.Calm(ϒdct, "update", λ.GetItem(ϒformats_spec, ϒformat_id))
								}
								ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("^(?P<width>\\d+)[xX](?P<height>\\d+)$"), λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("size"), λ.NewList(λ.StrLiteral(""))), λ.IntLiteral(0)))
								τmp2 = func() λ.Object {
									if λ.IsTrue(ϒmobj) {
										return λ.NewTuple(
											λ.Cal(λ.IntType, λ.Calm(ϒmobj, "group", λ.StrLiteral("width"))),
											λ.Cal(λ.IntType, λ.Calm(ϒmobj, "group", λ.StrLiteral("height"))),
										)
									} else {
										return λ.NewTuple(
											λ.None,
											λ.None,
										)
									}
								}()
								ϒwidth = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒheight = λ.GetItem(τmp2, λ.IntLiteral(1))
								if ϒwidth == λ.None {
									ϒwidth = λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("width")))
								}
								if ϒheight == λ.None {
									ϒheight = λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("height")))
								}
								ϒfilesize = func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("clen"), λ.NewList(λ.None)), λ.IntLiteral(0))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(ϒ_extract_filesize, ϒurl)
									}
								}()
								ϒquality = func() λ.Object {
									if λv := λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("quality"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒfmt, "get", λ.StrLiteral("quality"))
									}
								}()
								ϒquality_label = func() λ.Object {
									if λv := λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("quality_label"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒfmt, "get", λ.StrLiteral("qualityLabel"))
									}
								}()
								ϒtbr = func() λ.Object {
									if λ.IsTrue(λ.Ne(ϒformat_id, λ.StrLiteral("43"))) {
										return func() λ.Object {
											if λv := λ.Cal(ϒfloat_or_none, λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("bitrate"), λ.NewList(λ.None)), λ.IntLiteral(0)), λ.IntLiteral(1000)); λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Cal(ϒfloat_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("bitrate")), λ.IntLiteral(1000))
											}
										}()
									} else {
										return λ.None
									}
								}()
								ϒfps = func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("fps"), λ.NewList(λ.None)), λ.IntLiteral(0))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Cal(ϒint_or_none, λ.Calm(ϒfmt, "get", λ.StrLiteral("fps")))
									}
								}()
								ϒmore_fields = λ.DictLiteral(map[string]λ.Object{
									"filesize": ϒfilesize,
									"tbr":      ϒtbr,
									"width":    ϒwidth,
									"height":   ϒheight,
									"fps":      ϒfps,
									"format_note": func() λ.Object {
										if λv := ϒquality_label; λ.IsTrue(λv) {
											return λv
										} else {
											return ϒquality
										}
									}(),
								})
								τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒmore_fields, "items"))
								for {
									if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
										break
									}
									τmp4 = τmp3
									ϒkey = λ.GetItem(τmp4, λ.IntLiteral(0))
									ϒvalue = λ.GetItem(τmp4, λ.IntLiteral(1))
									if λ.IsTrue(ϒvalue) {
										λ.SetItem(ϒdct, ϒkey, ϒvalue)
									}
								}
								ϒtype_ = func() λ.Object {
									if λv := λ.GetItem(λ.Calm(ϒurl_data, "get", λ.StrLiteral("type"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒfmt, "get", λ.StrLiteral("mimeType"))
									}
								}()
								if λ.IsTrue(ϒtype_) {
									ϒtype_split = λ.Calm(ϒtype_, "split", λ.StrLiteral(";"))
									ϒkind_ext = λ.Calm(λ.GetItem(ϒtype_split, λ.IntLiteral(0)), "split", λ.StrLiteral("/"))
									if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒkind_ext), λ.IntLiteral(2))) {
										τmp2 = ϒkind_ext
										ϒkind = λ.GetItem(τmp2, λ.IntLiteral(0))
										_ = λ.GetItem(τmp2, λ.IntLiteral(1))
										λ.SetItem(ϒdct, λ.StrLiteral("ext"), λ.Cal(ϒmimetype2ext, λ.GetItem(ϒtype_split, λ.IntLiteral(0))))
										if λ.Contains(λ.NewTuple(
											λ.StrLiteral("audio"),
											λ.StrLiteral("video"),
										), ϒkind) {
											ϒcodecs = λ.None
											τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.StrLiteral("(?P<key>[a-zA-Z_-]+)=(?P<quote>[\"\\']?)(?P<val>.+?)(?P=quote)(?:;|$)"), ϒtype_))
											for {
												if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
													break
												}
												ϒmobj = τmp3
												if λ.IsTrue(λ.Eq(λ.Calm(ϒmobj, "group", λ.StrLiteral("key")), λ.StrLiteral("codecs"))) {
													ϒcodecs = λ.Calm(ϒmobj, "group", λ.StrLiteral("val"))
													break
												}
											}
											if λ.IsTrue(ϒcodecs) {
												λ.Calm(ϒdct, "update", λ.Cal(ϒparse_codecs, ϒcodecs))
											}
										}
									}
								}
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Eq(λ.Calm(ϒdct, "get", λ.StrLiteral("acodec")), λ.StrLiteral("none")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Eq(λ.Calm(ϒdct, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none"))
									}
								}()) {
									λ.SetItem(ϒdct, λ.StrLiteral("downloader_options"), λ.DictLiteral(map[string]int{
										"http_chunk_size": 10485760,
									}))
								}
								λ.Calm(ϒformats, "append", ϒdct)
							}
						} else {
							ϒmanifest_url = func() λ.Object {
								if λv := λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("streamingData")), λ.StrLiteral("hlsManifestUrl"))
									}), ϒcompat_str)); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒurl_or_none, λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("hlsvp")), λ.IntLiteral(0))
										}), ϒcompat_str))
								}
							}()
							if λ.IsTrue(ϒmanifest_url) {
								ϒformats = λ.NewList()
								ϒm3u8_formats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
									ϒmanifest_url,
									ϒvideo_id,
									λ.StrLiteral("mp4"),
								), λ.KWArgs{
									{Name: "fatal", Value: λ.False},
								})
								τmp1 = λ.Cal(λ.BuiltinIter, ϒm3u8_formats)
								for {
									if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
										break
									}
									ϒa_format = τmp0
									ϒitag = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
										λ.StrLiteral("/itag/(\\d+)/"),
										λ.GetItem(ϒa_format, λ.StrLiteral("url")),
										λ.StrLiteral("itag"),
									), λ.KWArgs{
										{Name: "default", Value: λ.None},
									})
									if λ.IsTrue(ϒitag) {
										λ.SetItem(ϒa_format, λ.StrLiteral("format_id"), ϒitag)
										if λ.Contains(λ.GetAttr(ϒself, "_formats", nil), ϒitag) {
											ϒdct = λ.Calm(λ.GetItem(λ.GetAttr(ϒself, "_formats", nil), ϒitag), "copy")
											λ.Calm(ϒdct, "update", ϒa_format)
											ϒa_format = ϒdct
										}
									}
									λ.SetItem(ϒa_format, λ.StrLiteral("player_url"), ϒplayer_url)
									λ.SetItem(λ.Calm(ϒa_format, "setdefault", λ.StrLiteral("http_headers"), λ.DictLiteral(map[λ.Object]λ.Object{})), λ.StrLiteral("Youtubedl-no-compression"), λ.StrLiteral("True"))
									λ.Calm(ϒformats, "append", ϒa_format)
								}
							} else {
								ϒerror_message = λ.Cal(ϒextract_unavailable_message)
								if !λ.IsTrue(ϒerror_message) {
									ϒerror_message = λ.Cal(ϒclean_html, λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("playabilityStatus")), λ.StrLiteral("reason"))
										}), ϒcompat_str))
								}
								if !λ.IsTrue(ϒerror_message) {
									ϒerror_message = λ.Cal(ϒclean_html, λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
										[]λ.Param{
											{Name: "x"},
										},
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											var (
												ϒx = λargs[0]
											)
											return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("reason")), λ.IntLiteral(0))
										}), ϒcompat_str))
								}
								if λ.IsTrue(ϒerror_message) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerror_message), λ.KWArgs{
										{Name: "expected", Value: λ.True},
									})))
								}
								panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("no conn, hlsvp, hlsManifestUrl or url_encoded_fmt_stream_map information found in video info"))))
							}
						}
					}
					ϒvideo_uploader = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("author")), λ.IntLiteral(0))
							}), ϒcompat_str); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒstr_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("author")))
						}
					}()
					if λ.IsTrue(ϒvideo_uploader) {
						ϒvideo_uploader = λ.Cal(ϒcompat_urllib_parse_unquote_plus, ϒvideo_uploader)
					} else {
						λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.StrLiteral("unable to extract uploader name"))
					}
					ϒvideo_uploader_id = λ.None
					ϒvideo_uploader_url = λ.None
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("<link itemprop=\"url\" href=\"(?P<uploader_url>https?://www\\.youtube\\.com/(?:user|channel)/(?P<uploader_id>[^\"]+))\">"), ϒvideo_webpage)
					if ϒmobj != λ.None {
						ϒvideo_uploader_id = λ.Calm(ϒmobj, "group", λ.StrLiteral("uploader_id"))
						ϒvideo_uploader_url = λ.Calm(ϒmobj, "group", λ.StrLiteral("uploader_url"))
					} else {
						λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.StrLiteral("unable to extract uploader nickname"))
					}
					ϒchannel_id = func() λ.Object {
						if λv := λ.Cal(ϒstr_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("channelId"))); λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
							λ.StrLiteral("channelId"),
							ϒvideo_webpage,
							λ.StrLiteral("channel id"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("data-channel-external-id=([\"\\'])(?P<id>(?:(?!\\1).)+)\\1"),
								ϒvideo_webpage,
								λ.StrLiteral("channel id"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
								{Name: "group", Value: λ.StrLiteral("id")},
							})
						}
					}()
					ϒchannel_url = func() λ.Object {
						if λ.IsTrue(ϒchannel_id) {
							return λ.Mod(λ.StrLiteral("http://www.youtube.com/channel/%s"), ϒchannel_id)
						} else {
							return λ.None
						}
					}()
					ϒm_thumb = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("<span itemprop=\"thumbnail\".*?href=\"(.*?)\">"), ϒvideo_webpage, Ωre.DOTALL)
					if ϒm_thumb != λ.None {
						ϒvideo_thumbnail = λ.Calm(ϒm_thumb, "group", λ.IntLiteral(1))
					} else {
						if !λ.Contains(ϒvideo_info, λ.StrLiteral("thumbnail_url")) {
							λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.StrLiteral("unable to extract video thumbnail"))
							ϒvideo_thumbnail = λ.None
						} else {
							ϒvideo_thumbnail = λ.Cal(ϒcompat_urllib_parse_unquote_plus, λ.GetItem(λ.GetItem(ϒvideo_info, λ.StrLiteral("thumbnail_url")), λ.IntLiteral(0)))
						}
					}
					ϒupload_date = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
						λ.StrLiteral("datePublished"),
						ϒvideo_webpage,
						λ.StrLiteral("upload date"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if !λ.IsTrue(ϒupload_date) {
						ϒupload_date = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.NewList(
								λ.StrLiteral("(?s)id=\"eow-date.*?>(.*?)</span>"),
								λ.StrLiteral("(?:id=\"watch-uploader-info\".*?>.*?|[\"\\']simpleText[\"\\']\\s*:\\s*[\"\\'])(?:Published|Uploaded|Streamed live|Started) on (.+?)[<\"\\']"),
							),
							ϒvideo_webpage,
							λ.StrLiteral("upload date"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
					}
					ϒupload_date = λ.Cal(ϒunified_strdate, ϒupload_date)
					ϒvideo_license = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("<h4[^>]+class=\"title\"[^>]*>\\s*License\\s*</h4>\\s*<ul[^>]*>\\s*<li>(.+?)</li"),
						ϒvideo_webpage,
						λ.StrLiteral("license"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒm_music = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("(?x)\n                <h4[^>]+class=\"title\"[^>]*>\\s*Music\\s*</h4>\\s*\n                <ul[^>]*>\\s*\n                <li>(?P<title>.+?)\n                by (?P<creator>.+?)\n                (?:\n                    \\(.+?\\)|\n                    <a[^>]*\n                        (?:\n                            \\bhref=[\"\\']/red[^>]*>|             # drop possible\n                            >\\s*Listen ad-free with YouTube Red # YouTube Red ad\n                        )\n                    .*?\n                )?</li\n            "), ϒvideo_webpage)
					if λ.IsTrue(ϒm_music) {
						ϒvideo_alt_title = λ.Cal(ϒremove_quotes, λ.Cal(ϒunescapeHTML, λ.Calm(ϒm_music, "group", λ.StrLiteral("title"))))
						ϒvideo_creator = λ.Cal(ϒclean_html, λ.Calm(ϒm_music, "group", λ.StrLiteral("creator")))
					} else {
						τmp1 = λ.None
						ϒvideo_alt_title = τmp1
						ϒvideo_creator = τmp1
					}
					ϒextract_meta = λ.NewFunction("extract_meta",
						[]λ.Param{
							{Name: "field"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒfield = λargs[0]
							)
							return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.StrLiteral("<h4[^>]+class=\"title\"[^>]*>\\s*%s\\s*</h4>\\s*<ul[^>]*>\\s*<li>(.+?)</li>\\s*"), ϒfield),
								ϒvideo_webpage,
								ϒfield,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})
						})
					ϒtrack = λ.Cal(ϒextract_meta, λ.StrLiteral("Song"))
					ϒartist = λ.Cal(ϒextract_meta, λ.StrLiteral("Artist"))
					ϒalbum = λ.Cal(ϒextract_meta, λ.StrLiteral("Album"))
					τmp1 = λ.None
					ϒrelease_date = τmp1
					ϒrelease_year = τmp1
					if λ.IsTrue(ϒvideo_description) {
						ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("(?s)Provided to YouTube by [^\\n]+\\n+(?P<track>[^·]+)·(?P<artist>[^\\n]+)\\n+(?P<album>[^\\n]+)(?:.+?℗\\s*(?P<release_year>\\d{4})(?!\\d))?(?:.+?Released on\\s*:\\s*(?P<release_date>\\d{4}-\\d{2}-\\d{2}))?(.+?\\nArtist\\s*:\\s*(?P<clean_artist>[^\\n]+))?"), ϒvideo_description)
						if λ.IsTrue(ϒmobj) {
							if !λ.IsTrue(ϒtrack) {
								ϒtrack = λ.Calm(λ.Calm(ϒmobj, "group", λ.StrLiteral("track")), "strip")
							}
							if !λ.IsTrue(ϒartist) {
								ϒartist = func() λ.Object {
									if λv := λ.Calm(ϒmobj, "group", λ.StrLiteral("clean_artist")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(λ.StrLiteral(", "), "join", λ.Cal(λ.NewFunction("<generator>",
											nil,
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
													var (
														ϒa   λ.Object
														τmp0 λ.Object
														τmp1 λ.Object
													)
													τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(λ.Calm(ϒmobj, "group", λ.StrLiteral("artist")), "split", λ.StrLiteral("·")))
													for {
														if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
															break
														}
														ϒa = τmp1
														λgy.Yield(λ.Calm(ϒa, "strip"))
													}
													return λ.None
												})
											})))
									}
								}()
							}
							if !λ.IsTrue(ϒalbum) {
								ϒalbum = λ.Calm(ϒmobj, "group", λ.Calm(λ.StrLiteral("album"), "strip"))
							}
							ϒrelease_year = λ.Calm(ϒmobj, "group", λ.StrLiteral("release_year"))
							ϒrelease_date = λ.Calm(ϒmobj, "group", λ.StrLiteral("release_date"))
							if λ.IsTrue(ϒrelease_date) {
								ϒrelease_date = λ.Calm(ϒrelease_date, "replace", λ.StrLiteral("-"), λ.StrLiteral(""))
								if !λ.IsTrue(ϒrelease_year) {
									ϒrelease_year = λ.Cal(λ.IntType, λ.GetItem(ϒrelease_date, λ.NewSlice(λ.None, λ.IntLiteral(4), λ.None)))
								}
							}
							if λ.IsTrue(ϒrelease_year) {
								ϒrelease_year = λ.Cal(λ.IntType, ϒrelease_year)
							}
						}
					}
					ϒm_episode = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("<div[^>]+id=\"watch7-headline\"[^>]*>\\s*<span[^>]*>.*?>(?P<series>[^<]+)</a></b>\\s*S(?P<season>\\d+)\\s*•\\s*E(?P<episode>\\d+)</span>"), ϒvideo_webpage)
					if λ.IsTrue(ϒm_episode) {
						ϒseries = λ.Cal(ϒunescapeHTML, λ.Calm(ϒm_episode, "group", λ.StrLiteral("series")))
						ϒseason_number = λ.Cal(λ.IntType, λ.Calm(ϒm_episode, "group", λ.StrLiteral("season")))
						ϒepisode_number = λ.Cal(λ.IntType, λ.Calm(ϒm_episode, "group", λ.StrLiteral("episode")))
					} else {
						τmp1 = λ.None
						ϒseries = τmp1
						ϒseason_number = τmp1
						ϒepisode_number = τmp1
					}
					ϒm_cat_container = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?s)<h4[^>]*>\\s*Category\\s*</h4>\\s*<ul[^>]*>(.*?)</ul>"),
						ϒvideo_webpage,
						λ.StrLiteral("categories"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(ϒm_cat_container) {
						ϒcategory = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("(?s)<a[^<]+>(.*?)</a>"),
							ϒm_cat_container,
							λ.StrLiteral("category"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						ϒvideo_categories = func() λ.Object {
							if ϒcategory == λ.None {
								return λ.None
							} else {
								return λ.NewList(ϒcategory)
							}
						}()
					} else {
						ϒvideo_categories = λ.None
					}
					ϒvideo_tags = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒm   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfinditer, λ.Calm(ϒself, "_meta_regex", λ.StrLiteral("og:video:tag")), ϒvideo_webpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒm = τmp1
									λgy.Yield(λ.Cal(ϒunescapeHTML, λ.Calm(ϒm, "group", λ.StrLiteral("content"))))
								}
								return λ.None
							})
						})))
					ϒ_extract_count = λ.NewFunction("_extract_count",
						[]λ.Param{
							{Name: "count_name"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcount_name = λargs[0]
							)
							return λ.Cal(ϒstr_to_int, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.Mod(λ.StrLiteral("-%s-button[^>]+><span[^>]+class=\"yt-uix-button-content\"[^>]*>([\\d,]+)</span>"), λ.Cal(Ωre.ϒescape, ϒcount_name)),
								ϒvideo_webpage,
								ϒcount_name,
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						})
					ϒlike_count = λ.Cal(ϒ_extract_count, λ.StrLiteral("like"))
					ϒdislike_count = λ.Cal(ϒ_extract_count, λ.StrLiteral("dislike"))
					if ϒview_count == λ.None {
						ϒview_count = λ.Cal(ϒstr_to_int, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("<[^>]+class=[\"\\']watch-view-count[^>]+>\\s*([\\d,\\s]+)"),
							ϒvideo_webpage,
							λ.StrLiteral("view count"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						}))
					}
					ϒaverage_rating = func() λ.Object {
						if λv := λ.Cal(ϒfloat_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("averageRating"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
								[]λ.Param{
									{Name: "x"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒx = λargs[0]
									)
									return λ.Cal(ϒfloat_or_none, λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("avg_rating")), λ.IntLiteral(0)))
								}))
						}
					}()
					ϒvideo_subtitles = λ.Calm(ϒself, "extract_subtitles", ϒvideo_id, ϒvideo_webpage)
					ϒautomatic_captions = λ.Calm(ϒself, "extract_automatic_captions", ϒvideo_id, ϒvideo_webpage)
					ϒvideo_duration = λ.Cal(ϒtry_get, ϒvideo_info, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.Cal(ϒint_or_none, λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("length_seconds")), λ.IntLiteral(0)))
						}))
					if !λ.IsTrue(ϒvideo_duration) {
						ϒvideo_duration = λ.Cal(ϒint_or_none, λ.Calm(ϒvideo_details, "get", λ.StrLiteral("lengthSeconds")))
					}
					if !λ.IsTrue(ϒvideo_duration) {
						ϒvideo_duration = λ.Cal(ϒparse_duration, λ.Calm(ϒself, "_html_search_meta", λ.StrLiteral("duration"), ϒvideo_webpage, λ.StrLiteral("video duration")))
					}
					ϒvideo_annotations = λ.None
					if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("writeannotations"), λ.False)) {
						ϒxsrf_token = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("([\\'\"])XSRF_TOKEN\\1\\s*:\\s*([\\'\"])(?P<xsrf_token>[A-Za-z0-9+/=]+)\\2"),
							ϒvideo_webpage,
							λ.StrLiteral("xsrf token"),
						), λ.KWArgs{
							{Name: "group", Value: λ.StrLiteral("xsrf_token")},
							{Name: "fatal", Value: λ.False},
						})
						ϒinvideo_url = λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("annotations")), λ.IntLiteral(0)), λ.StrLiteral("playerAnnotationsUrlsRenderer")), λ.StrLiteral("invideoUrl"))
							}), ϒcompat_str)
						if λ.IsTrue(func() λ.Object {
							if λv := ϒxsrf_token; !λ.IsTrue(λv) {
								return λv
							} else {
								return ϒinvideo_url
							}
						}()) {
							ϒxsrf_field_name = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("([\\'\"])XSRF_FIELD_NAME\\1\\s*:\\s*([\\'\"])(?P<xsrf_field_name>\\w+)\\2"),
								ϒvideo_webpage,
								λ.StrLiteral("xsrf field name"),
							), λ.KWArgs{
								{Name: "group", Value: λ.StrLiteral("xsrf_field_name")},
								{Name: "default", Value: λ.StrLiteral("session_token")},
							})
							ϒvideo_annotations = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
								λ.Calm(ϒself, "_proto_relative_url", ϒinvideo_url),
								ϒvideo_id,
							), λ.KWArgs{
								{Name: "note", Value: λ.StrLiteral("Downloading annotations")},
								{Name: "errnote", Value: λ.StrLiteral("Unable to download video annotations")},
								{Name: "fatal", Value: λ.False},
								{Name: "data", Value: λ.Cal(ϒurlencode_postdata, λ.DictLiteral(map[λ.Object]λ.Object{
									ϒxsrf_field_name: ϒxsrf_token,
								}))},
							})
						}
					}
					ϒchapters = λ.Calm(ϒself, "_extract_chapters", ϒdescription_original, ϒvideo_duration)
					if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("youtube_include_dash_manifest"), λ.True)) {
						ϒdash_mpd_fatal = λ.True
						τmp1 = λ.Cal(λ.BuiltinIter, ϒdash_mpds)
						for {
							if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
								break
							}
							ϒmpd_url = τmp0
							ϒdash_formats = λ.DictLiteral(map[λ.Object]λ.Object{})
							τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{λ.NewTuple(
										ExtractorError,
										λ.KeyErrorType,
									), func(λex λ.BaseException) {
										var ϒe λ.Object = λex
										λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("Skipping DASH manifest: %r"), ϒe), ϒvideo_id)
									}},
								)
								ϒdecrypt_sig = λ.NewFunction("decrypt_sig",
									[]λ.Param{
										{Name: "mobj"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒdec_s λ.Object
											ϒmobj  = λargs[0]
											ϒs     λ.Object
										)
										ϒs = λ.Calm(ϒmobj, "group", λ.IntLiteral(1))
										ϒdec_s = λ.Calm(ϒself, "_decrypt_signature", ϒs, ϒvideo_id, ϒplayer_url, ϒage_gate)
										return λ.Mod(λ.StrLiteral("/signature/%s"), ϒdec_s)
									})
								ϒmpd_url = λ.Cal(Ωre.ϒsub, λ.StrLiteral("/s/([a-fA-F0-9\\.]+)"), ϒdecrypt_sig, ϒmpd_url)
								τmp4 = λ.Cal(λ.BuiltinIter, λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
									ϒmpd_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "fatal", Value: ϒdash_mpd_fatal},
									{Name: "formats_dict", Value: λ.GetAttr(ϒself, "_formats", nil)},
								}))
								for {
									if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
										break
									}
									ϒdf = τmp5
									if !λ.IsTrue(λ.Calm(ϒdf, "get", λ.StrLiteral("filesize"))) {
										λ.SetItem(ϒdf, λ.StrLiteral("filesize"), λ.Cal(ϒ_extract_filesize, λ.GetItem(ϒdf, λ.StrLiteral("url"))))
									}
									if !λ.Contains(ϒdash_formats, λ.GetItem(ϒdf, λ.StrLiteral("format_id"))) {
										λ.SetItem(ϒdash_formats, λ.GetItem(ϒdf, λ.StrLiteral("format_id")), ϒdf)
									}
									ϒdash_mpd_fatal = λ.False
								}
								return λ.BlockExitNormally, nil
							}()
							if λ.IsTrue(ϒdash_formats) {
								ϒformats = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒf   λ.Object
												τmp0 λ.Object
												τmp1 λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒf = τmp1
												if !λ.Contains(λ.Calm(ϒdash_formats, "keys"), λ.GetItem(ϒf, λ.StrLiteral("format_id"))) {
													λgy.Yield(ϒf)
												}
											}
											return λ.None
										})
									})))
								λ.Calm(ϒformats, "extend", λ.Calm(ϒdash_formats, "values"))
							}
						}
					}
					ϒstretched_m = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("<meta\\s+property=\"og:video:tag\".*?content=\"yt:stretch=(?P<w>[0-9]+):(?P<h>[0-9]+)\">"), ϒvideo_webpage)
					if λ.IsTrue(ϒstretched_m) {
						ϒw = λ.Cal(λ.FloatType, λ.Calm(ϒstretched_m, "group", λ.StrLiteral("w")))
						ϒh = λ.Cal(λ.FloatType, λ.Calm(ϒstretched_m, "group", λ.StrLiteral("h")))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Gt(ϒw, λ.IntLiteral(0)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Gt(ϒh, λ.IntLiteral(0))
							}
						}()) {
							ϒratio = λ.TrueDiv(ϒw, ϒh)
							τmp1 = λ.Cal(λ.BuiltinIter, ϒformats)
							for {
								if τmp0 = λ.NextDefault(τmp1, λ.AfterLast); τmp0 == λ.AfterLast {
									break
								}
								ϒf = τmp0
								if λ.IsTrue(λ.Ne(λ.Calm(ϒf, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none"))) {
									λ.SetItem(ϒf, λ.StrLiteral("stretched_ratio"), ϒratio)
								}
							}
						}
					}
					if !λ.IsTrue(ϒformats) {
						if λ.Contains(ϒvideo_info, λ.StrLiteral("reason")) {
							if λ.Contains(λ.GetItem(ϒvideo_info, λ.StrLiteral("reason")), λ.StrLiteral("The uploader has not made this video available in your country.")) {
								ϒregions_allowed = λ.Call(λ.GetAttr(ϒself, "_html_search_meta", nil), λ.NewArgs(
									λ.StrLiteral("regionsAllowed"),
									ϒvideo_webpage,
								), λ.KWArgs{
									{Name: "default", Value: λ.None},
								})
								ϒcountries = func() λ.Object {
									if λ.IsTrue(ϒregions_allowed) {
										return λ.Calm(ϒregions_allowed, "split", λ.StrLiteral(","))
									} else {
										return λ.None
									}
								}()
								λ.Call(λ.GetAttr(ϒself, "raise_geo_restricted", nil), nil, λ.KWArgs{
									{Name: "msg", Value: λ.GetItem(λ.GetItem(ϒvideo_info, λ.StrLiteral("reason")), λ.IntLiteral(0))},
									{Name: "countries", Value: ϒcountries},
								})
							}
							ϒreason = λ.GetItem(λ.GetItem(ϒvideo_info, λ.StrLiteral("reason")), λ.IntLiteral(0))
							if λ.Contains(ϒreason, λ.StrLiteral("Invalid parameters")) {
								ϒunavailable_message = λ.Cal(ϒextract_unavailable_message)
								if λ.IsTrue(ϒunavailable_message) {
									ϒreason = ϒunavailable_message
								}
							}
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.Mod(λ.StrLiteral("YouTube said: %s"), ϒreason)), λ.KWArgs{
								{Name: "expected", Value: λ.True},
								{Name: "video_id", Value: ϒvideo_id},
							})))
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(ϒvideo_info, "get", λ.StrLiteral("license_info")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(ϒtry_get, ϒplayer_response, λ.NewFunction("<lambda>",
									[]λ.Param{
										{Name: "x"},
									},
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										var (
											ϒx = λargs[0]
										)
										return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("streamingData")), λ.StrLiteral("licenseInfos"))
									}))
							}
						}()) {
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("This video is DRM protected.")), λ.KWArgs{
								{Name: "expected", Value: λ.True},
							})))
						}
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					λ.Calm(ϒself, "mark_watched", ϒvideo_id, ϒvideo_info, ϒplayer_response)
					return λ.DictLiteral(map[string]λ.Object{
						"id":           ϒvideo_id,
						"uploader":     ϒvideo_uploader,
						"uploader_id":  ϒvideo_uploader_id,
						"uploader_url": ϒvideo_uploader_url,
						"channel_id":   ϒchannel_id,
						"channel_url":  ϒchannel_url,
						"upload_date":  ϒupload_date,
						"license":      ϒvideo_license,
						"creator": func() λ.Object {
							if λv := ϒvideo_creator; λ.IsTrue(λv) {
								return λv
							} else {
								return ϒartist
							}
						}(),
						"title": ϒvideo_title,
						"alt_title": func() λ.Object {
							if λv := ϒvideo_alt_title; λ.IsTrue(λv) {
								return λv
							} else {
								return ϒtrack
							}
						}(),
						"thumbnail":          ϒvideo_thumbnail,
						"description":        ϒvideo_description,
						"categories":         ϒvideo_categories,
						"tags":               ϒvideo_tags,
						"subtitles":          ϒvideo_subtitles,
						"automatic_captions": ϒautomatic_captions,
						"duration":           ϒvideo_duration,
						"age_limit": func() λ.Object {
							if λ.IsTrue(ϒage_gate) {
								return λ.IntLiteral(18)
							} else {
								return λ.IntLiteral(0)
							}
						}(),
						"annotations":    ϒvideo_annotations,
						"chapters":       ϒchapters,
						"webpage_url":    λ.Add(ϒproto, λ.Mod(λ.StrLiteral("://www.youtube.com/watch?v=%s"), ϒvideo_id)),
						"view_count":     ϒview_count,
						"like_count":     ϒlike_count,
						"dislike_count":  ϒdislike_count,
						"average_rating": ϒaverage_rating,
						"formats":        ϒformats,
						"is_live":        ϒis_live,
						"start_time":     ϒstart_time,
						"end_time":       ϒend_time,
						"series":         ϒseries,
						"season_number":  ϒseason_number,
						"episode_number": ϒepisode_number,
						"track":          ϒtrack,
						"artist":         ϒartist,
						"album":          ϒalbum,
						"release_date":   ϒrelease_date,
						"release_year":   ϒrelease_year,
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":                     YoutubeIE_IE_NAME,
				"_GEO_BYPASS":                 YoutubeIE__GEO_BYPASS,
				"_NEXT_URL_RE":                YoutubeIE__NEXT_URL_RE,
				"_PLAYER_INFO_RE":             YoutubeIE__PLAYER_INFO_RE,
				"_VALID_URL":                  YoutubeIE__VALID_URL,
				"__init__":                    YoutubeIE___init__,
				"_decrypt_signature":          YoutubeIE__decrypt_signature,
				"_extract_chapters":           YoutubeIE__extract_chapters,
				"_extract_player_info":        YoutubeIE__extract_player_info,
				"_extract_signature_function": YoutubeIE__extract_signature_function,
				"_extract_url":                YoutubeIE__extract_url,
				"_extract_urls":               YoutubeIE__extract_urls,
				"_formats":                    YoutubeIE__formats,
				"_get_ytplayer_config":        YoutubeIE__get_ytplayer_config,
				"_parse_sig_js":               YoutubeIE__parse_sig_js,
				"_real_extract":               YoutubeIE__real_extract,
				"_signature_cache_id":         YoutubeIE__signature_cache_id,
				"extract_id":                  YoutubeIE_extract_id,
			})
		}())
		YoutubePlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubePlaylistIE"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubePlaylistIE_IE_NAME                    λ.Object
				YoutubePlaylistIE__TEMPLATE_URL              λ.Object
				YoutubePlaylistIE__VALID_URL                 λ.Object
				YoutubePlaylistIE__VIDEO_RE_TPL              λ.Object
				YoutubePlaylistIE__check_download_just_video λ.Object
				YoutubePlaylistIE__extract_playlist          λ.Object
				YoutubePlaylistIE__real_extract              λ.Object
				YoutubePlaylistIE__real_initialize           λ.Object
			)
			YoutubePlaylistIE__VALID_URL = λ.Mod(λ.StrLiteral("(?x)(?:\n                        (?:https?://)?\n                        (?:\\w+\\.)?\n                        (?:\n                            (?:\n                                youtube(?:kids)?\\.com|\n                                invidio\\.us\n                            )\n                            /\n                            (?:\n                               (?:course|view_play_list|my_playlists|artist|playlist|watch|embed/(?:videoseries|[0-9A-Za-z_-]{11}))\n                               \\? (?:.*?[&;])*? (?:p|a|list)=\n                            |  p/\n                            )|\n                            youtu\\.be/[0-9A-Za-z_-]{11}\\?.*?\\blist=\n                        )\n                        (\n                            (?:PL|LL|EC|UU|FL|RD|UL|TL|PU|OLAK5uy_)?[0-9A-Za-z-_]{10,}\n                            # Top tracks, they can also include dots\n                            |(?:MC)[\\w\\.]*\n                        )\n                        .*\n                     |\n                        (%(playlist_id)s)\n                     )"), λ.DictLiteral(map[string]λ.Object{
				"playlist_id": λ.GetAttr(YoutubeBaseInfoExtractor, "_PLAYLIST_ID_RE", nil),
			}))
			YoutubePlaylistIE__TEMPLATE_URL = λ.StrLiteral("https://www.youtube.com/playlist?list=%s")
			YoutubePlaylistIE__VIDEO_RE_TPL = λ.StrLiteral("href=\"\\s*/watch\\?v=%s(?:&amp;(?:[^\"]*?index=(?P<index>\\d+))?(?:[^>]+>(?P<title>[^<]+))?)?")
			YoutubePlaylistIE_IE_NAME = λ.StrLiteral("youtube:playlist")
			YoutubePlaylistIE__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.Calm(ϒself, "_login")
					return λ.None
				})
			YoutubePlaylistIE__extract_playlist = λ.NewFunction("_extract_playlist",
				[]λ.Param{
					{Name: "self"},
					{Name: "playlist_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_UPLOADER_BASE λ.Object
						ϒhas_videos     λ.Object
						ϒmatch          λ.Object
						ϒmessage        λ.Object
						ϒmobj           λ.Object
						ϒpage           λ.Object
						ϒplaylist       λ.Object
						ϒplaylist_id    = λargs[1]
						ϒplaylist_title λ.Object
						ϒreason         λ.Object
						ϒself           = λargs[0]
						ϒuploader       λ.Object
						ϒuploader_id    λ.Object
						ϒuploader_url   λ.Object
						ϒurl            λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
					)
					_ = τmp0
					_ = τmp1
					ϒurl = λ.Mod(λ.GetAttr(ϒself, "_TEMPLATE_URL", nil), ϒplaylist_id)
					ϒpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒplaylist_id)
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.StrLiteral("<div class=\"yt-alert-message\"[^>]*>([^<]+)</div>"), ϒpage))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmatch = τmp1
						ϒmatch = λ.Calm(ϒmatch, "strip")
						ϒmobj = λ.Cal(Ωre.ϒmatch, λ.StrLiteral("[^<]*(?:The|This) playlist (?P<reason>does not exist|is private)[^<]*"), ϒmatch)
						if λ.IsTrue(ϒmobj) {
							ϒreason = λ.Calm(ϒmobj, "group", λ.StrLiteral("reason"))
							ϒmessage = λ.Mod(λ.StrLiteral("This playlist %s"), ϒreason)
							if λ.Contains(ϒreason, λ.StrLiteral("private")) {
								τmp2 = λ.IAdd(ϒmessage, λ.StrLiteral(", use --username or --netrc to access it"))
								ϒmessage = τmp2
							}
							τmp2 = λ.IAdd(ϒmessage, λ.StrLiteral("."))
							ϒmessage = τmp2
							panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmessage), λ.KWArgs{
								{Name: "expected", Value: λ.True},
							})))
						} else {
							if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("[^<]*Invalid parameters[^<]*"), ϒmatch)) {
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("Invalid parameters. Maybe URL is incorrect.")), λ.KWArgs{
									{Name: "expected", Value: λ.True},
								})))
							} else {
								if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("[^<]*Choose your language[^<]*"), ϒmatch)) {
									continue
								} else {
									λ.Calm(ϒself, "report_warning", λ.Add(λ.StrLiteral("Youtube gives an alert message: "), ϒmatch))
								}
							}
						}
					}
					ϒplaylist_title = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?s)<h1 class=\"pl-header-title[^\"]*\"[^>]*>\\s*(.*?)\\s*</h1>"),
						ϒpage,
						λ.StrLiteral("title"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒ_UPLOADER_BASE = λ.StrLiteral("class=[\"\\']pl-header-details[^>]+>\\s*<li>\\s*<a[^>]+\\bhref=")
					ϒuploader = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.Mod(λ.StrLiteral("%s[\"\\']/(?:user|channel)/[^>]+>([^<]+)"), ϒ_UPLOADER_BASE),
						ϒpage,
						λ.StrLiteral("uploader"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒmobj = λ.Cal(Ωre.ϒsearch, λ.Mod(λ.StrLiteral("%s([\"\\'])(?P<path>/(?:user|channel)/(?P<uploader_id>.+?))\\1"), ϒ_UPLOADER_BASE), ϒpage)
					if λ.IsTrue(ϒmobj) {
						ϒuploader_id = λ.Calm(ϒmobj, "group", λ.StrLiteral("uploader_id"))
						ϒuploader_url = λ.Cal(Ωparse.ϒurljoin, ϒurl, λ.Calm(ϒmobj, "group", λ.StrLiteral("path")))
					} else {
						τmp0 = λ.None
						ϒuploader_id = τmp0
						ϒuploader_url = τmp0
					}
					ϒhas_videos = λ.True
					if !λ.IsTrue(ϒplaylist_title) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.StopIterationType, func(λex λ.BaseException) {
									ϒhas_videos = λ.False
								}},
							)
							λ.Cal(λ.BuiltinNext, λ.Calm(ϒself, "_entries", ϒpage, ϒplaylist_id))
							return λ.BlockExitNormally, nil
						}()
					}
					ϒplaylist = λ.Calm(ϒself, "playlist_result", λ.Calm(ϒself, "_entries", ϒpage, ϒplaylist_id), ϒplaylist_id, ϒplaylist_title)
					λ.Calm(ϒplaylist, "update", λ.DictLiteral(map[string]λ.Object{
						"uploader":     ϒuploader,
						"uploader_id":  ϒuploader_id,
						"uploader_url": ϒuploader_url,
					}))
					return λ.NewTuple(
						ϒhas_videos,
						ϒplaylist,
					)
				})
			YoutubePlaylistIE__check_download_just_video = λ.NewFunction("_check_download_just_video",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "playlist_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒplaylist_id = λargs[2]
						ϒquery_dict  λ.Object
						ϒself        = λargs[0]
						ϒurl         = λargs[1]
						ϒvideo_id    λ.Object
					)
					ϒquery_dict = λ.Cal(Ωparse.ϒparse_qs, λ.GetAttr(λ.Cal(Ωparse.ϒurlparse, ϒurl), "query", nil))
					ϒvideo_id = func() λ.Object {
						if λv := λ.GetItem(λ.Calm(ϒquery_dict, "get", λ.StrLiteral("v"), λ.NewList(λ.None)), λ.IntLiteral(0)); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("(?:(?:^|//)youtu\\.be/|youtube\\.com/embed/(?!videoseries))([0-9A-Za-z_-]{11})"),
								ϒurl,
								λ.StrLiteral("video id"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							})
						}
					}()
					if λ.IsTrue(ϒvideo_id) {
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("noplaylist"))) {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading just video %s because of --no-playlist"), ϒvideo_id))
							return λ.NewTuple(
								ϒvideo_id,
								λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(
									ϒvideo_id,
									λ.StrLiteral("Youtube"),
								), λ.KWArgs{
									{Name: "video_id", Value: ϒvideo_id},
								}),
							)
						} else {
							λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("Downloading playlist %s - add --no-playlist to just download video %s"), λ.NewTuple(
								ϒplaylist_id,
								ϒvideo_id,
							)))
							return λ.NewTuple(
								ϒvideo_id,
								λ.None,
							)
						}
					}
					return λ.NewTuple(
						λ.None,
						λ.None,
					)
				})
			YoutubePlaylistIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhas_videos  λ.Object
						ϒmobj        λ.Object
						ϒplaylist    λ.Object
						ϒplaylist_id λ.Object
						ϒself        = λargs[0]
						ϒurl         = λargs[1]
						ϒvideo       λ.Object
						ϒvideo_id    λ.Object
						τmp0         λ.Object
					)
					ϒmobj = λ.Cal(Ωre.ϒmatch, λ.GetAttr(ϒself, "_VALID_URL", nil), ϒurl)
					if ϒmobj == λ.None {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.Mod(λ.StrLiteral("Invalid URL: %s"), ϒurl))))
					}
					ϒplaylist_id = func() λ.Object {
						if λv := λ.Calm(ϒmobj, "group", λ.IntLiteral(1)); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒmobj, "group", λ.IntLiteral(2))
						}
					}()
					τmp0 = λ.Calm(ϒself, "_check_download_just_video", ϒurl, ϒplaylist_id)
					ϒvideo_id = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒvideo = λ.GetItem(τmp0, λ.IntLiteral(1))
					if λ.IsTrue(ϒvideo) {
						return ϒvideo
					}
					if λ.IsTrue(λ.Calm(ϒplaylist_id, "startswith", λ.NewTuple(
						λ.StrLiteral("RD"),
						λ.StrLiteral("UL"),
						λ.StrLiteral("PU"),
					))) {
						return λ.Calm(ϒself, "_extract_mix", ϒplaylist_id)
					}
					τmp0 = λ.Calm(ϒself, "_extract_playlist", ϒplaylist_id)
					ϒhas_videos = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒplaylist = λ.GetItem(τmp0, λ.IntLiteral(1))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒhas_videos; λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒvideo_id))
						}
					}()) {
						return ϒplaylist
					}
					return λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(
						ϒvideo_id,
						λ.StrLiteral("Youtube"),
					), λ.KWArgs{
						{Name: "video_id", Value: ϒvideo_id},
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":                    YoutubePlaylistIE_IE_NAME,
				"_TEMPLATE_URL":              YoutubePlaylistIE__TEMPLATE_URL,
				"_VALID_URL":                 YoutubePlaylistIE__VALID_URL,
				"_VIDEO_RE_TPL":              YoutubePlaylistIE__VIDEO_RE_TPL,
				"_check_download_just_video": YoutubePlaylistIE__check_download_just_video,
				"_extract_playlist":          YoutubePlaylistIE__extract_playlist,
				"_real_extract":              YoutubePlaylistIE__real_extract,
				"_real_initialize":           YoutubePlaylistIE__real_initialize,
			})
		}())
		YoutubeChannelIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeChannelIE"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeChannelIE__VALID_URL λ.Object
				YoutubeChannelIE_suitable   λ.Object
			)
			YoutubeChannelIE__VALID_URL = λ.StrLiteral("https?://(?:youtu\\.be|(?:\\w+\\.)?youtube(?:-nocookie|kids)?\\.com|(?:www\\.)?invidio\\.us)/channel/(?P<id>[0-9A-Za-z_-]+)")
			YoutubeChannelIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(YoutubePlaylistsIE, "suitable", ϒurl); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(YoutubeLiveIE, "suitable", ϒurl)
							}
						}()) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, YoutubeChannelIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			YoutubeChannelIE_suitable = λ.Cal(λ.ClassMethodType, YoutubeChannelIE_suitable)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": YoutubeChannelIE__VALID_URL,
				"suitable":   YoutubeChannelIE_suitable,
			})
		}())
		YoutubeUserIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeUserIE"), λ.NewTuple(YoutubeChannelIE), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeLiveIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeLiveIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeLiveIE__VALID_URL λ.Object
			)
			YoutubeLiveIE__VALID_URL = λ.StrLiteral("(?P<base_url>https?://(?:\\w+\\.)?youtube\\.com/(?:(?:user|channel|c)/)?(?P<id>[^/]+))/live")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": YoutubeLiveIE__VALID_URL,
			})
		}())
		YoutubePlaylistsIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubePlaylistsIE"), λ.NewTuple(YoutubePlaylistsBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubePlaylistsIE__VALID_URL λ.Object
			)
			YoutubePlaylistsIE__VALID_URL = λ.StrLiteral("https?://(?:\\w+\\.)?youtube\\.com/(?:user|channel)/(?P<id>[^/]+)/playlists")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": YoutubePlaylistsIE__VALID_URL,
			})
		}())
		YoutubeSearchBaseInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeSearchBaseInfoExtractor"), λ.NewTuple(YoutubePlaylistBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeSearchIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeSearchIE"), λ.NewTuple(
			SearchInfoExtractor,
			YoutubeSearchBaseInfoExtractor,
		), func() λ.Dict {
			var (
				YoutubeSearchIE_IE_NAME λ.Object
			)
			YoutubeSearchIE_IE_NAME = λ.StrLiteral("youtube:search")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME": YoutubeSearchIE_IE_NAME,
			})
		}())
		YoutubeSearchURLIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeSearchURLIE"), λ.NewTuple(YoutubeSearchBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeShowIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeShowIE"), λ.NewTuple(YoutubePlaylistsBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeFeedsInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeFeedsInfoExtractor"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeWatchLaterIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeWatchLaterIE"), λ.NewTuple(YoutubePlaylistIE), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeFavouritesIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeFavouritesIE"), λ.NewTuple(YoutubeBaseInfoExtractor), func() λ.Dict {
			var (
				YoutubeFavouritesIE__VALID_URL λ.Object
			)
			YoutubeFavouritesIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?youtube\\.com/my_favorites|:ytfav(?:ou?rites)?")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": YoutubeFavouritesIE__VALID_URL,
			})
		}())
		YoutubeRecommendedIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeRecommendedIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeSubscriptionsIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeSubscriptionsIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeHistoryIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeHistoryIE"), λ.NewTuple(YoutubeFeedsInfoExtractor), func() λ.Dict {
			var (
				YoutubeHistoryIE__VALID_URL λ.Object
			)
			YoutubeHistoryIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?youtube\\.com/feed/history|:ythistory")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": YoutubeHistoryIE__VALID_URL,
			})
		}())
		YoutubeTruncatedURLIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeTruncatedURLIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		YoutubeTruncatedIDIE = λ.Cal(λ.TypeType, λ.StrLiteral("YoutubeTruncatedIDIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
	})
}
