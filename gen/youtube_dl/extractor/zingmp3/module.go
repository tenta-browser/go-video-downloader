// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * zingmp3/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/zingmp3.py
 */

package zingmp3

import (
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError λ.Object
	InfoExtractor  λ.Object
	ZingMp3AlbumIE λ.Object
	ZingMp3BaseIE  λ.Object
	ZingMp3IE      λ.Object
	ϒint_or_none   λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ExtractorError = Ωutils.ExtractorError
		ϒint_or_none = Ωutils.ϒint_or_none
		ZingMp3BaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("ZingMp3BaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				ZingMp3BaseIE__GEO_COUNTRIES  λ.Object
				ZingMp3BaseIE__VALID_URL_TMPL λ.Object
				ZingMp3BaseIE__extract_item   λ.Object
				ZingMp3BaseIE__real_extract   λ.Object
			)
			ZingMp3BaseIE__VALID_URL_TMPL = λ.StrLiteral("https?://(?:mp3\\.zing|zingmp3)\\.vn/(?:%s)/[^/]+/(?P<id>\\w+)\\.html")
			ZingMp3BaseIE__GEO_COUNTRIES = λ.NewList(λ.StrLiteral("VN"))
			ZingMp3BaseIE__extract_item = λ.NewFunction("_extract_item",
				[]λ.Param{
					{Name: "self"},
					{Name: "item"},
					{Name: "fatal"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒalbum     λ.Object
						ϒfatal     = λargs[2]
						ϒformats   λ.Object
						ϒitem      = λargs[1]
						ϒitem_id   λ.Object
						ϒk         λ.Object
						ϒlyric     λ.Object
						ϒmsg       λ.Object
						ϒres       λ.Object
						ϒself      = λargs[0]
						ϒsubtitles λ.Object
						ϒtitle     λ.Object
						ϒv         λ.Object
						ϒvideo_url λ.Object
						τmp0       λ.Object
						τmp1       λ.Object
						τmp2       λ.Object
						τmp3       λ.Object
						τmp4       λ.Object
					)
					ϒitem_id = λ.GetItem(ϒitem, λ.StrLiteral("id"))
					ϒtitle = func() λ.Object {
						if λv := λ.Calm(ϒitem, "get", λ.StrLiteral("name")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.GetItem(ϒitem, λ.StrLiteral("title"))
						}
					}()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(func() λ.Object {
						if λv := λ.Calm(ϒitem, "get", λ.StrLiteral("source")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}(), "items"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = λ.UnpackIterable(τmp1, 2)
						ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
						if !λ.IsTrue(ϒv) {
							continue
						}
						if λ.Contains(λ.NewTuple(
							λ.StrLiteral("mp4"),
							λ.StrLiteral("hls"),
						), ϒk) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒv, "items"))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								τmp4 = λ.UnpackIterable(τmp3, 2)
								ϒres = λ.GetItem(τmp4, λ.IntLiteral(0))
								ϒvideo_url = λ.GetItem(τmp4, λ.IntLiteral(1))
								if !λ.IsTrue(ϒvideo_url) {
									continue
								}
								if λ.IsTrue(λ.Eq(ϒk, λ.StrLiteral("hls"))) {
									λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
										ϒvideo_url,
										ϒitem_id,
										λ.StrLiteral("mp4"),
										λ.StrLiteral("m3u8_native"),
									), λ.KWArgs{
										{Name: "m3u8_id", Value: ϒk},
										{Name: "fatal", Value: λ.False},
									}))
								} else {
									if λ.IsTrue(λ.Eq(ϒk, λ.StrLiteral("mp4"))) {
										λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
											"format_id": λ.Add(λ.StrLiteral("mp4-"), ϒres),
											"url":       ϒvideo_url,
											"height": λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
												λ.StrLiteral("^(\\d+)p"),
												ϒres,
												λ.StrLiteral("resolution"),
											), λ.KWArgs{
												{Name: "default", Value: λ.None},
											})),
										}))
									}
								}
							}
						} else {
							λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
								"ext":       λ.StrLiteral("mp3"),
								"format_id": ϒk,
								"tbr":       λ.Cal(ϒint_or_none, ϒk),
								"url":       λ.Calm(ϒself, "_proto_relative_url", ϒv),
								"vcodec":    λ.StrLiteral("none"),
							}))
						}
					}
					if !λ.IsTrue(ϒformats) {
						if !λ.IsTrue(ϒfatal) {
							return λ.None
						}
						ϒmsg = λ.GetItem(ϒitem, λ.StrLiteral("msg"))
						if λ.IsTrue(λ.Eq(ϒmsg, λ.StrLiteral("Sorry, this content is not available in your country."))) {
							λ.Call(λ.GetAttr(ϒself, "raise_geo_restricted", nil), nil, λ.KWArgs{
								{Name: "countries", Value: λ.GetAttr(ϒself, "_GEO_COUNTRIES", nil)},
							})
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmsg), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒsubtitles = λ.None
					ϒlyric = λ.Calm(ϒitem, "get", λ.StrLiteral("lyric"))
					if λ.IsTrue(ϒlyric) {
						ϒsubtitles = λ.DictLiteral(map[string]λ.Object{
							"origin": λ.NewList(λ.DictLiteral(map[string]λ.Object{
								"url": ϒlyric,
							})),
						})
					}
					ϒalbum = func() λ.Object {
						if λv := λ.Calm(ϒitem, "get", λ.StrLiteral("album")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}()
					return λ.DictLiteral(map[string]λ.Object{
						"id":        ϒitem_id,
						"title":     ϒtitle,
						"formats":   ϒformats,
						"thumbnail": λ.Calm(ϒitem, "get", λ.StrLiteral("thumbnail")),
						"subtitles": ϒsubtitles,
						"duration":  λ.Cal(ϒint_or_none, λ.Calm(ϒitem, "get", λ.StrLiteral("duration"))),
						"track":     ϒtitle,
						"artist":    λ.Calm(ϒitem, "get", λ.StrLiteral("artists_names")),
						"album": func() λ.Object {
							if λv := λ.Calm(ϒalbum, "get", λ.StrLiteral("name")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒalbum, "get", λ.StrLiteral("title"))
							}
						}(),
						"album_artist": λ.Calm(ϒalbum, "get", λ.StrLiteral("artists_names")),
					})
				})
			ZingMp3BaseIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata_path λ.Object
						ϒpage_id   λ.Object
						ϒself      = λargs[0]
						ϒurl       = λargs[1]
						ϒwebpage   λ.Object
					)
					ϒpage_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Call(λ.GetAttr(ϒself, "_download_webpage", nil), λ.NewArgs(
						λ.Calm(ϒurl, "replace", λ.StrLiteral("://zingmp3.vn/"), λ.StrLiteral("://mp3.zing.vn/")),
						ϒpage_id,
					), λ.KWArgs{
						{Name: "query", Value: λ.DictLiteral(map[string]int{
							"play_song": 1,
						})},
					})
					ϒdata_path = λ.Calm(ϒself, "_search_regex", λ.StrLiteral("data-xml=\"([^\"]+)"), ϒwebpage, λ.StrLiteral("data path"))
					return λ.Calm(ϒself, "_process_data", λ.GetItem(λ.Calm(ϒself, "_download_json", λ.Add(λ.StrLiteral("https://mp3.zing.vn/xhr"), ϒdata_path), ϒpage_id), λ.StrLiteral("data")))
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_GEO_COUNTRIES":  ZingMp3BaseIE__GEO_COUNTRIES,
				"_VALID_URL_TMPL": ZingMp3BaseIE__VALID_URL_TMPL,
				"_extract_item":   ZingMp3BaseIE__extract_item,
				"_real_extract":   ZingMp3BaseIE__real_extract,
			})
		}())
		ZingMp3IE = λ.Cal(λ.TypeType, λ.StrLiteral("ZingMp3IE"), λ.NewTuple(ZingMp3BaseIE), func() λ.Dict {
			var (
				ZingMp3IE_IE_NAME       λ.Object
				ZingMp3IE__VALID_URL    λ.Object
				ZingMp3IE__process_data λ.Object
			)
			ZingMp3IE__VALID_URL = λ.Mod(λ.GetAttr(ZingMp3BaseIE, "_VALID_URL_TMPL", nil), λ.StrLiteral("bai-hat|video-clip"))
			ZingMp3IE_IE_NAME = λ.StrLiteral("zingmp3")
			ZingMp3IE__process_data = λ.NewFunction("_process_data",
				[]λ.Param{
					{Name: "self"},
					{Name: "data"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata = λargs[1]
						ϒself = λargs[0]
					)
					return λ.Calm(ϒself, "_extract_item", ϒdata, λ.True)
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":       ZingMp3IE_IE_NAME,
				"_VALID_URL":    ZingMp3IE__VALID_URL,
				"_process_data": ZingMp3IE__process_data,
			})
		}())
		ZingMp3AlbumIE = λ.Cal(λ.TypeType, λ.StrLiteral("ZingMp3AlbumIE"), λ.NewTuple(ZingMp3BaseIE), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
	})
}
