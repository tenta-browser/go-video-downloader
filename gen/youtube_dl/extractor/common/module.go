// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * common/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/common.py
 */

package common

import (
	Ωbase64 "github.com/tenta-browser/go-video-downloader/gen/base64"
	Ωcookies "github.com/tenta-browser/go-video-downloader/gen/http/cookies"
	Ωjson "github.com/tenta-browser/go-video-downloader/gen/json"
	Ωmath "github.com/tenta-browser/go-video-downloader/gen/math"
	Ωrandom "github.com/tenta-browser/go-video-downloader/gen/random"
	Ωre "github.com/tenta-browser/go-video-downloader/gen/re"
	Ωsocket "github.com/tenta-browser/go-video-downloader/gen/socket"
	Ωsys "github.com/tenta-browser/go-video-downloader/gen/sys"
	Ωerror "github.com/tenta-browser/go-video-downloader/gen/urllib/error"
	Ωparse "github.com/tenta-browser/go-video-downloader/gen/urllib/parse"
	Ωrequest "github.com/tenta-browser/go-video-downloader/gen/urllib/request"
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωf4m "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/downloader/f4m"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError                 λ.Object
	GeoRestrictedError             λ.Object
	GeoUtils                       λ.Object
	InfoExtractor                  λ.Object
	JSON_LD_RE                     λ.Object
	NO_DEFAULT                     λ.Object
	RegexNotFoundError             λ.Object
	SearchInfoExtractor            λ.Object
	ϒage_restricted                λ.Object
	ϒbase_url                      λ.Object
	ϒbug_reports_message           λ.Object
	ϒclean_html                    λ.Object
	ϒcompat_cookiejar_Cookie       λ.Object
	ϒcompat_etree_Element          λ.Object
	ϒcompat_etree_fromstring       λ.Object
	ϒcompat_http_client            λ.Object
	ϒcompat_integer_types          λ.Object
	ϒcompat_str                    λ.Object
	ϒcompat_urllib_parse_unquote   λ.Object
	ϒcompat_urllib_parse_urlencode λ.Object
	ϒcompat_xml_parse_error        λ.Object
	ϒcompiled_regex_type           λ.Object
	ϒdetermine_ext                 λ.Object
	ϒdetermine_protocol            λ.Object
	ϒdict_get                      λ.Object
	ϒerror_to_compat_str           λ.Object
	ϒextract_attributes            λ.Object
	ϒfix_xml_ampersands            λ.Object
	ϒfloat_or_none                 λ.Object
	ϒget_base_url                  λ.Object
	ϒint_or_none                   λ.Object
	ϒjs_to_json                    λ.Object
	ϒmimetype2ext                  λ.Object
	ϒorderedSet                    λ.Object
	ϒparse_bitrate                 λ.Object
	ϒparse_codecs                  λ.Object
	ϒparse_duration                λ.Object
	ϒparse_iso8601                 λ.Object
	ϒparse_m3u8_attributes         λ.Object
	ϒparse_resolution              λ.Object
	ϒremove_encrypted_media        λ.Object
	ϒsanitize_filename             λ.Object
	ϒsanitized_Request             λ.Object
	ϒstr_or_none                   λ.Object
	ϒstr_to_int                    λ.Object
	ϒstrip_or_none                 λ.Object
	ϒunescapeHTML                  λ.Object
	ϒunified_strdate               λ.Object
	ϒunified_timestamp             λ.Object
	ϒupdate_Request                λ.Object
	ϒupdate_url_query              λ.Object
	ϒurl_basename                  λ.Object
	ϒurl_or_none                   λ.Object
	ϒurljoin                       λ.Object
	ϒxpath_element                 λ.Object
	ϒxpath_text                    λ.Object
	ϒxpath_with_ns                 λ.Object
)

func init() {
	λ.InitModule(func() {
		ϒcompat_cookiejar_Cookie = Ωcompat.ϒcompat_cookiejar_Cookie
		ϒcompat_etree_Element = Ωcompat.ϒcompat_etree_Element
		ϒcompat_etree_fromstring = Ωcompat.ϒcompat_etree_fromstring
		ϒcompat_integer_types = Ωcompat.ϒcompat_integer_types
		ϒcompat_http_client = Ωcompat.ϒcompat_http_client
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒcompat_urllib_parse_unquote = Ωcompat.ϒcompat_urllib_parse_unquote
		ϒcompat_urllib_parse_urlencode = Ωcompat.ϒcompat_urllib_parse_urlencode
		ϒcompat_xml_parse_error = Ωcompat.ϒcompat_xml_parse_error
		ϒget_base_url = Ωf4m.ϒget_base_url
		ϒremove_encrypted_media = Ωf4m.ϒremove_encrypted_media
		NO_DEFAULT = Ωutils.NO_DEFAULT
		ϒage_restricted = Ωutils.ϒage_restricted
		ϒbase_url = Ωutils.ϒbase_url
		ϒbug_reports_message = Ωutils.ϒbug_reports_message
		ϒclean_html = Ωutils.ϒclean_html
		ϒcompiled_regex_type = Ωutils.ϒcompiled_regex_type
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ϒdetermine_protocol = Ωutils.ϒdetermine_protocol
		ϒdict_get = Ωutils.ϒdict_get
		ϒerror_to_compat_str = Ωutils.ϒerror_to_compat_str
		ExtractorError = Ωutils.ExtractorError
		ϒextract_attributes = Ωutils.ϒextract_attributes
		ϒfix_xml_ampersands = Ωutils.ϒfix_xml_ampersands
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		GeoRestrictedError = Ωutils.GeoRestrictedError
		GeoUtils = Ωutils.GeoUtils
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒjs_to_json = Ωutils.ϒjs_to_json
		JSON_LD_RE = Ωutils.JSON_LD_RE
		ϒmimetype2ext = Ωutils.ϒmimetype2ext
		ϒorderedSet = Ωutils.ϒorderedSet
		ϒparse_bitrate = Ωutils.ϒparse_bitrate
		ϒparse_codecs = Ωutils.ϒparse_codecs
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒparse_iso8601 = Ωutils.ϒparse_iso8601
		ϒparse_m3u8_attributes = Ωutils.ϒparse_m3u8_attributes
		ϒparse_resolution = Ωutils.ϒparse_resolution
		RegexNotFoundError = Ωutils.RegexNotFoundError
		ϒsanitized_Request = Ωutils.ϒsanitized_Request
		ϒsanitize_filename = Ωutils.ϒsanitize_filename
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒstr_to_int = Ωutils.ϒstr_to_int
		ϒstrip_or_none = Ωutils.ϒstrip_or_none
		ϒunescapeHTML = Ωutils.ϒunescapeHTML
		ϒunified_strdate = Ωutils.ϒunified_strdate
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ϒupdate_Request = Ωutils.ϒupdate_Request
		ϒupdate_url_query = Ωutils.ϒupdate_url_query
		ϒurljoin = Ωutils.ϒurljoin
		ϒurl_basename = Ωutils.ϒurl_basename
		ϒurl_or_none = Ωutils.ϒurl_or_none
		ϒxpath_element = Ωutils.ϒxpath_element
		ϒxpath_text = Ωutils.ϒxpath_text
		ϒxpath_with_ns = Ωutils.ϒxpath_with_ns
		InfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("InfoExtractor"), λ.NewTuple(λ.ObjectType), func() λ.Dict {
			var (
				InfoExtractor_IE_NAME                      λ.Object
				InfoExtractor__GEO_BYPASS                  λ.Object
				InfoExtractor__GEO_COUNTRIES               λ.Object
				InfoExtractor__GEO_IP_BLOCKS               λ.Object
				InfoExtractor__WORKING                     λ.Object
				InfoExtractor___can_accept_status_code     λ.Object
				InfoExtractor___check_blocked              λ.Object
				InfoExtractor___init__                     λ.Object
				InfoExtractor___maybe_fake_ip_and_retry    λ.Object
				InfoExtractor__check_formats               λ.Object
				InfoExtractor__download_json               λ.Object
				InfoExtractor__download_json_handle        λ.Object
				InfoExtractor__download_smil               λ.Object
				InfoExtractor__download_webpage            λ.Object
				InfoExtractor__download_webpage_handle     λ.Object
				InfoExtractor__download_xml                λ.Object
				InfoExtractor__download_xml_handle         λ.Object
				InfoExtractor__downloader                  λ.Object
				InfoExtractor__extract_akamai_formats      λ.Object
				InfoExtractor__extract_f4m_formats         λ.Object
				InfoExtractor__extract_ism_formats         λ.Object
				InfoExtractor__extract_m3u8_formats        λ.Object
				InfoExtractor__extract_mpd_formats         λ.Object
				InfoExtractor__extract_smil_formats        λ.Object
				InfoExtractor__float                       λ.Object
				InfoExtractor__form_hidden_inputs          λ.Object
				InfoExtractor__get_cookies                 λ.Object
				InfoExtractor__get_login_info              λ.Object
				InfoExtractor__get_netrc_login_info        λ.Object
				InfoExtractor__guess_encoding_from_content λ.Object
				InfoExtractor__hidden_inputs               λ.Object
				InfoExtractor__html_search_meta            λ.Object
				InfoExtractor__html_search_regex           λ.Object
				InfoExtractor__initialize_geo_bypass       λ.Object
				InfoExtractor__int                         λ.Object
				InfoExtractor__is_valid_url                λ.Object
				InfoExtractor__json_ld                     λ.Object
				InfoExtractor__live_title                  λ.Object
				InfoExtractor__match_id                    λ.Object
				InfoExtractor__media_rating_search         λ.Object
				InfoExtractor__merge_subtitle_items        λ.Object
				InfoExtractor__merge_subtitles             λ.Object
				InfoExtractor__meta_regex                  λ.Object
				InfoExtractor__og_regexes                  λ.Object
				InfoExtractor__og_search_description       λ.Object
				InfoExtractor__og_search_property          λ.Object
				InfoExtractor__og_search_thumbnail         λ.Object
				InfoExtractor__og_search_title             λ.Object
				InfoExtractor__og_search_url               λ.Object
				InfoExtractor__og_search_video_url         λ.Object
				InfoExtractor__parse_f4m_formats           λ.Object
				InfoExtractor__parse_html5_media_entries   λ.Object
				InfoExtractor__parse_ism_formats           λ.Object
				InfoExtractor__parse_json                  λ.Object
				InfoExtractor__parse_jwplayer_data         λ.Object
				InfoExtractor__parse_jwplayer_formats      λ.Object
				InfoExtractor__parse_m3u8_formats          λ.Object
				InfoExtractor__parse_mpd_formats           λ.Object
				InfoExtractor__parse_smil_formats          λ.Object
				InfoExtractor__parse_smil_namespace        λ.Object
				InfoExtractor__parse_smil_subtitles        λ.Object
				InfoExtractor__parse_xml                   λ.Object
				InfoExtractor__proto_relative_url          λ.Object
				InfoExtractor__ready                       λ.Object
				InfoExtractor__real_initialize             λ.Object
				InfoExtractor__remove_duplicate_formats    λ.Object
				InfoExtractor__request_webpage             λ.Object
				InfoExtractor__rta_search                  λ.Object
				InfoExtractor__search_json_ld              λ.Object
				InfoExtractor__search_regex                λ.Object
				InfoExtractor__set_cookie                  λ.Object
				InfoExtractor__sort_formats                λ.Object
				InfoExtractor__webpage_read_content        λ.Object
				InfoExtractor__x_forwarded_for_ip          λ.Object
				InfoExtractor__xpath_ns                    λ.Object
				InfoExtractor_extract                      λ.Object
				InfoExtractor_extract_automatic_captions   λ.Object
				InfoExtractor_extract_subtitles            λ.Object
				InfoExtractor_geo_verification_headers     λ.Object
				InfoExtractor_http_scheme                  λ.Object
				InfoExtractor_ie_key                       λ.Object
				InfoExtractor_initialize                   λ.Object
				InfoExtractor_mark_watched                 λ.Object
				InfoExtractor_playlist_result              λ.Object
				InfoExtractor_raise_geo_restricted         λ.Object
				InfoExtractor_report_download_webpage      λ.Object
				InfoExtractor_report_extraction            λ.Object
				InfoExtractor_report_warning               λ.Object
				InfoExtractor_set_downloader               λ.Object
				InfoExtractor_suitable                     λ.Object
				InfoExtractor_to_screen                    λ.Object
				InfoExtractor_url_result                   λ.Object
				InfoExtractor_working                      λ.Object
			)
			InfoExtractor__ready = λ.False
			InfoExtractor__downloader = λ.None
			InfoExtractor__x_forwarded_for_ip = λ.None
			InfoExtractor__GEO_BYPASS = λ.True
			InfoExtractor__GEO_COUNTRIES = λ.None
			InfoExtractor__GEO_IP_BLOCKS = λ.None
			InfoExtractor__WORKING = λ.True
			InfoExtractor___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "downloader", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader = λargs[1]
						ϒself       = λargs[0]
					)
					λ.SetAttr(ϒself, "_ready", λ.False)
					λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.None)
					λ.Calm(ϒself, "set_downloader", ϒdownloader)
					return λ.None
				})
			InfoExtractor_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					if !λ.Contains(λ.GetAttr(ϒcls, "__dict__", nil), λ.StrLiteral("_VALID_URL_RE")) {
						λ.SetAttr(ϒcls, "_VALID_URL_RE", λ.Cal(Ωre.ϒcompile, λ.GetAttr(ϒcls, "_VALID_URL", nil)))
					}
					return λ.NewBool(λ.Calm(λ.GetAttr(ϒcls, "_VALID_URL_RE", nil), "match", ϒurl) != λ.None)
				})
			InfoExtractor_suitable = λ.Cal(λ.ClassMethodType, InfoExtractor_suitable)
			InfoExtractor__match_id = λ.NewFunction("_match_id",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒm   λ.Object
						ϒurl = λargs[1]
					)
					if !λ.Contains(λ.GetAttr(ϒcls, "__dict__", nil), λ.StrLiteral("_VALID_URL_RE")) {
						λ.SetAttr(ϒcls, "_VALID_URL_RE", λ.Cal(Ωre.ϒcompile, λ.GetAttr(ϒcls, "_VALID_URL", nil)))
					}
					ϒm = λ.Calm(λ.GetAttr(ϒcls, "_VALID_URL_RE", nil), "match", ϒurl)
					if !λ.IsTrue(ϒm) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					return λ.Cal(ϒcompat_str, λ.Calm(ϒm, "group", λ.StrLiteral("id")))
				})
			InfoExtractor__match_id = λ.Cal(λ.ClassMethodType, InfoExtractor__match_id)
			InfoExtractor_working = λ.NewFunction("working",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					return λ.GetAttr(ϒcls, "_WORKING", nil)
				})
			InfoExtractor_working = λ.Cal(λ.ClassMethodType, InfoExtractor_working)
			InfoExtractor_initialize = λ.NewFunction("initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					λ.Calm(ϒself, "_initialize_geo_bypass", λ.DictLiteral(map[string]λ.Object{
						"countries": λ.GetAttr(ϒself, "_GEO_COUNTRIES", nil),
						"ip_blocks": λ.GetAttr(ϒself, "_GEO_IP_BLOCKS", nil),
					}))
					if !λ.IsTrue(λ.GetAttr(ϒself, "_ready", nil)) {
						λ.Calm(ϒself, "_real_initialize")
						λ.SetAttr(ϒself, "_ready", λ.True)
					}
					return λ.None
				})
			InfoExtractor__initialize_geo_bypass = λ.NewFunction("_initialize_geo_bypass",
				[]λ.Param{
					{Name: "self"},
					{Name: "geo_bypass_context"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcountries          λ.Object
						ϒcountry            λ.Object
						ϒgeo_bypass_context = λargs[1]
						ϒip_block           λ.Object
						ϒip_blocks          λ.Object
						ϒself               = λargs[0]
					)
					if !λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
						if !λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_bypass"), λ.True)) {
							return λ.None
						}
						if !λ.IsTrue(ϒgeo_bypass_context) {
							ϒgeo_bypass_context = λ.DictLiteral(map[λ.Object]λ.Object{})
						}
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒgeo_bypass_context, λ.NewTuple(
							λ.ListType,
							λ.TupleType,
						))) {
							ϒgeo_bypass_context = λ.DictLiteral(map[string]λ.Object{
								"countries": ϒgeo_bypass_context,
							})
						}
						ϒip_block = λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_bypass_ip_block"), λ.None)
						if !λ.IsTrue(ϒip_block) {
							ϒip_blocks = λ.Calm(ϒgeo_bypass_context, "get", λ.StrLiteral("ip_blocks"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.GetAttr(ϒself, "_GEO_BYPASS", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒip_blocks
								}
							}()) {
								ϒip_block = λ.Cal(Ωrandom.ϒchoice, ϒip_blocks)
							}
						}
						if λ.IsTrue(ϒip_block) {
							λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.Calm(GeoUtils, "random_ipv4", ϒip_block))
							if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("verbose"), λ.False)) {
								λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", λ.Mod(λ.StrLiteral("[debug] Using fake IP %s as X-Forwarded-For."), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)))
							}
							return λ.None
						}
						ϒcountry = λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_bypass_country"), λ.None)
						if !λ.IsTrue(ϒcountry) {
							ϒcountries = λ.Calm(ϒgeo_bypass_context, "get", λ.StrLiteral("countries"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.GetAttr(ϒself, "_GEO_BYPASS", nil); !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒcountries
								}
							}()) {
								ϒcountry = λ.Cal(Ωrandom.ϒchoice, ϒcountries)
							}
						}
						if λ.IsTrue(ϒcountry) {
							λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.Calm(GeoUtils, "random_ipv4", ϒcountry))
							if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("verbose"), λ.False)) {
								λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", λ.Mod(λ.StrLiteral("[debug] Using fake IP %s (%s) as X-Forwarded-For."), λ.NewTuple(
									λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil),
									λ.Calm(ϒcountry, "upper"),
								)))
							}
						}
					}
					return λ.None
				})
			InfoExtractor_extract = λ.NewFunction("extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie_result λ.Object
						ϒself      = λargs[0]
						ϒurl       = λargs[1]
						τmp0       λ.Object
						τmp1       λ.Object
						τmp2       λ.Object
						τmp3       λ.Object
						τmp4       λ.Object
						τmp5       λ.Object
					)
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
								panic(λ.Raise(λex))
							}},
							&λ.Catcher{λ.GetAttr(ϒcompat_http_client, "IncompleteRead", nil), func(λex λ.BaseException) {
								var ϒe λ.Object = λex
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("A network error has occurred.")), λ.KWArgs{
									{Name: "cause", Value: ϒe},
									{Name: "expected", Value: λ.True},
								})))
							}},
							&λ.Catcher{λ.NewTuple(
								λ.KeyErrorType,
								λ.StopIterationType,
							), func(λex λ.BaseException) {
								var ϒe λ.Object = λex
								panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("An extractor error has occurred.")), λ.KWArgs{
									{Name: "cause", Value: ϒe},
								})))
							}},
						)
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.IntLiteral(2)))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							_ = τmp3
							τmp4, τmp5 = func() (λexit λ.Object, λret λ.Object) {
								defer λ.CatchMulti(
									nil,
									&λ.Catcher{GeoRestrictedError, func(λex λ.BaseException) {
										var ϒe λ.Object = λex
										if λ.IsTrue(λ.Calm(ϒself, "__maybe_fake_ip_and_retry", λ.GetAttr(ϒe, "countries", nil))) {
											λexit = λ.BlockExitContinue
											return
										}
										panic(λ.Raise(λex))
									}},
								)
								λ.Calm(ϒself, "initialize")
								ϒie_result = λ.Calm(ϒself, "_real_extract", ϒurl)
								if λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
									λ.SetItem(ϒie_result, λ.StrLiteral("__x_forwarded_for_ip"), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil))
								}
								λexit, λret = λ.BlockExitReturn, ϒie_result
								return
								return λ.BlockExitNormally, nil
							}()
							if τmp4 == λ.BlockExitReturn {
								λexit, λret = λ.BlockExitReturn, τmp5
								return
							}
							if τmp4 == λ.BlockExitContinue {
								continue
							}
						}
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor___maybe_fake_ip_and_retry = λ.NewFunction("__maybe_fake_ip_and_retry",
				[]λ.Param{
					{Name: "self"},
					{Name: "countries"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcountries    = λargs[1]
						ϒcountry_code λ.Object
						ϒself         = λargs[0]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_bypass_country"), λ.None))); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.GetAttr(ϒself, "_GEO_BYPASS", nil); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_bypass"), λ.True); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.NewBool(!λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil))); !λ.IsTrue(λv) {
							return λv
						} else {
							return ϒcountries
						}
					}()) {
						ϒcountry_code = λ.Cal(Ωrandom.ϒchoice, ϒcountries)
						λ.SetAttr(ϒself, "_x_forwarded_for_ip", λ.Calm(GeoUtils, "random_ipv4", ϒcountry_code))
						if λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
							λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("Video is geo restricted. Retrying extraction with fake IP %s (%s) as X-Forwarded-For."), λ.NewTuple(
								λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil),
								λ.Calm(ϒcountry_code, "upper"),
							)))
							return λ.True
						}
					}
					return λ.False
				})
			InfoExtractor_set_downloader = λ.NewFunction("set_downloader",
				[]λ.Param{
					{Name: "self"},
					{Name: "downloader"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader = λargs[1]
						ϒself       = λargs[0]
					)
					λ.SetAttr(ϒself, "_downloader", ϒdownloader)
					return λ.None
				})
			InfoExtractor__real_initialize = λ.NewFunction("_real_initialize",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					_ = ϒself
					// pass
					return λ.None
				})
			InfoExtractor_ie_key = λ.NewFunction("ie_key",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					return λ.Cal(ϒcompat_str, λ.GetItem(λ.GetAttr(ϒcls, "__name__", nil), λ.NewSlice(λ.None, λ.Neg(λ.IntLiteral(2)), λ.None)))
				})
			InfoExtractor_ie_key = λ.Cal(λ.ClassMethodType, InfoExtractor_ie_key)
			InfoExtractor_IE_NAME = λ.NewFunction("IE_NAME",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					return λ.Cal(ϒcompat_str, λ.GetItem(λ.GetAttr(λ.Cal(λ.TypeType, ϒself), "__name__", nil), λ.NewSlice(λ.None, λ.Neg(λ.IntLiteral(2)), λ.None)))
				})
			InfoExtractor_IE_NAME = λ.Cal(λ.PropertyType, InfoExtractor_IE_NAME)
			InfoExtractor___can_accept_status_code = λ.NewFunction("__can_accept_status_code",
				[]λ.Param{
					{Name: "err"},
					{Name: "expected_status"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerr             = λargs[0]
						ϒexpected_status = λargs[1]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒerr, Ωerror.HTTPError)) {
						panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
					}
					if ϒexpected_status == λ.None {
						return λ.False
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒexpected_status, ϒcompat_integer_types)) {
						return λ.Eq(λ.GetAttr(ϒerr, "code", nil), ϒexpected_status)
					} else {
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒexpected_status, λ.NewTuple(
							λ.ListType,
							λ.TupleType,
						))) {
							return λ.NewBool(λ.Contains(ϒexpected_status, λ.GetAttr(ϒerr, "code", nil)))
						} else {
							if λ.IsTrue(λ.Cal(λ.BuiltinCallable, ϒexpected_status)) {
								return λ.NewBool(λ.Cal(ϒexpected_status, λ.GetAttr(ϒerr, "code", nil)) == λ.True)
							} else {
								if !λ.IsTrue(λ.False) {
									panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
								}
							}
						}
					}
					return λ.None
				})
			InfoExtractor___can_accept_status_code = λ.Cal(λ.StaticMethodType, InfoExtractor___can_accept_status_code)
			InfoExtractor__request_webpage = λ.NewFunction("_request_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata            = λargs[6]
						ϒerrmsg          λ.Object
						ϒerrnote         = λargs[4]
						ϒexceptions      λ.Object
						ϒexpected_status = λargs[9]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[7]
						ϒnote            = λargs[3]
						ϒquery           = λargs[8]
						ϒself            = λargs[0]
						ϒurl_or_request  = λargs[1]
						ϒvideo_id        = λargs[2]
						τmp0             λ.Object
						τmp1             λ.Object
					)
					if ϒnote == λ.None {
						λ.Calm(ϒself, "report_download_webpage", ϒvideo_id)
					} else {
						if ϒnote != λ.False {
							if ϒvideo_id == λ.None {
								λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("%s"), λ.NewTuple(ϒnote)))
							} else {
								λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("%s: %s"), λ.NewTuple(
									ϒvideo_id,
									ϒnote,
								)))
							}
						}
					}
					if λ.IsTrue(λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil)) {
						if !λ.Contains(ϒheaders, λ.StrLiteral("X-Forwarded-For")) {
							λ.SetItem(ϒheaders, λ.StrLiteral("X-Forwarded-For"), λ.GetAttr(ϒself, "_x_forwarded_for_ip", nil))
						}
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl_or_request, Ωrequest.Request)) {
						ϒurl_or_request = λ.Call(ϒupdate_Request, λ.NewArgs(ϒurl_or_request), λ.KWArgs{
							{Name: "data", Value: ϒdata},
							{Name: "headers", Value: ϒheaders},
							{Name: "query", Value: ϒquery},
						})
					} else {
						if λ.IsTrue(ϒquery) {
							ϒurl_or_request = λ.Cal(ϒupdate_url_query, ϒurl_or_request, ϒquery)
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(ϒdata != λ.None); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒheaders
							}
						}()) {
							ϒurl_or_request = λ.Cal(ϒsanitized_Request, ϒurl_or_request, ϒdata, ϒheaders)
						}
					}
					ϒexceptions = λ.NewList(
						Ωerror.URLError,
						λ.GetAttr(ϒcompat_http_client, "HTTPException", nil),
						Ωsocket.ϒerror,
					)
					if λ.IsTrue(λ.Cal(λ.BuiltinHasAttr, λ.None, λ.StrLiteral("CertificateError"))) {
						λ.Calm(ϒexceptions, "append", λ.GetAttr(λ.None, "CertificateError", nil))
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.Cal(λ.TupleType, ϒexceptions), func(λex λ.BaseException) {
								var ϒerr λ.Object = λex
								if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒerr, Ωerror.HTTPError)) {
									if λ.IsTrue(λ.Calm(ϒself, "__can_accept_status_code", ϒerr, ϒexpected_status)) {
										λ.SetAttr(λ.GetAttr(ϒerr, "fp", nil), "_error", ϒerr)
										λexit, λret = λ.BlockExitReturn, λ.GetAttr(ϒerr, "fp", nil)
										return
									}
								}
								if ϒerrnote == λ.False {
									λexit, λret = λ.BlockExitReturn, λ.False
									return
								}
								if ϒerrnote == λ.None {
									ϒerrnote = λ.StrLiteral("Unable to download webpage")
								}
								ϒerrmsg = λ.Mod(λ.StrLiteral("%s: %s"), λ.NewTuple(
									ϒerrnote,
									λ.Cal(ϒerror_to_compat_str, ϒerr),
								))
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(
										ϒerrmsg,
										λ.GetItem(λ.Cal(Ωsys.ϒexc_info), λ.IntLiteral(2)),
									), λ.KWArgs{
										{Name: "cause", Value: ϒerr},
									})))
								} else {
									λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", ϒerrmsg)
									λexit, λret = λ.BlockExitReturn, λ.False
									return
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "urlopen", ϒurl_or_request)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor__download_webpage_handle = λ.NewFunction("_download_webpage_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent         λ.Object
						ϒdata            = λargs[7]
						ϒencoding        = λargs[6]
						ϒerrnote         = λargs[4]
						ϒexpected_status = λargs[10]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[8]
						ϒnote            = λargs[3]
						ϒquery           = λargs[9]
						ϒself            = λargs[0]
						ϒurl_or_request  = λargs[1]
						ϒurlh            λ.Object
						ϒvideo_id        = λargs[2]
					)
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒurl_or_request, λ.NewTuple(
						ϒcompat_str,
						λ.StrType,
					))) {
						ϒurl_or_request = λ.GetItem(λ.Calm(ϒurl_or_request, "partition", λ.StrLiteral("#")), λ.IntLiteral(0))
					}
					ϒurlh = λ.Call(λ.GetAttr(ϒself, "_request_webpage", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
						ϒfatal,
					), λ.KWArgs{
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if ϒurlh == λ.False {
						if !!λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
						}
						return λ.False
					}
					ϒcontent = λ.Call(λ.GetAttr(ϒself, "_webpage_read_content", nil), λ.NewArgs(
						ϒurlh,
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
						ϒfatal,
					), λ.KWArgs{
						{Name: "encoding", Value: ϒencoding},
					})
					return λ.NewTuple(
						ϒcontent,
						ϒurlh,
					)
				})
			InfoExtractor__guess_encoding_from_content = λ.NewFunction("_guess_encoding_from_content",
				[]λ.Param{
					{Name: "content_type"},
					{Name: "webpage_bytes"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_type  = λargs[0]
						ϒencoding      λ.Object
						ϒm             λ.Object
						ϒwebpage_bytes = λargs[1]
					)
					ϒm = λ.Cal(Ωre.ϒmatch, λ.StrLiteral("[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+\\s*;\\s*charset=(.+)"), ϒcontent_type)
					if λ.IsTrue(ϒm) {
						ϒencoding = λ.Calm(ϒm, "group", λ.IntLiteral(1))
					} else {
						ϒm = λ.Cal(Ωre.ϒsearch, λ.NewBytes(0x3c, 0x6d, 0x65, 0x74, 0x61, 0x5b, 0x5e, 0x3e, 0x5d, 0x2b, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x5b, 0x5c, 0x27, 0x22, 0x5d, 0x3f, 0x28, 0x5b, 0x5e, 0x5c, 0x27, 0x22, 0x29, 0x5d, 0x2b, 0x29, 0x5b, 0x20, 0x2f, 0x5c, 0x27, 0x22, 0x3e, 0x5d), λ.GetItem(ϒwebpage_bytes, λ.NewSlice(λ.None, λ.IntLiteral(1024), λ.None)))
						if λ.IsTrue(ϒm) {
							ϒencoding = λ.Calm(λ.Calm(ϒm, "group", λ.IntLiteral(1)), "decode", λ.StrLiteral("ascii"))
						} else {
							if λ.IsTrue(λ.Calm(ϒwebpage_bytes, "startswith", λ.NewBytes(0xff, 0xfe))) {
								ϒencoding = λ.StrLiteral("utf-16")
							} else {
								ϒencoding = λ.StrLiteral("utf-8")
							}
						}
					}
					return ϒencoding
				})
			InfoExtractor__guess_encoding_from_content = λ.Cal(λ.StaticMethodType, InfoExtractor__guess_encoding_from_content)
			InfoExtractor___check_blocked = λ.NewFunction("__check_blocked",
				[]λ.Param{
					{Name: "self"},
					{Name: "content"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒblock_msg      λ.Object
						ϒblocked_iframe λ.Object
						ϒcontent        = λargs[1]
						ϒfirst_block    λ.Object
						ϒmsg            λ.Object
						ϒself           = λargs[0]
						τmp0            λ.Object
					)
					ϒfirst_block = λ.GetItem(ϒcontent, λ.NewSlice(λ.None, λ.IntLiteral(512), λ.None))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒcontent, λ.StrLiteral("<title>Access to this site is blocked</title>"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒfirst_block, λ.StrLiteral("Websense")))
						}
					}()) {
						ϒmsg = λ.StrLiteral("Access to this webpage has been blocked by Websense filtering software in your network.")
						ϒblocked_iframe = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("<iframe src=\"([^\"]+)\""),
							ϒcontent,
							λ.StrLiteral("Websense information URL"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if λ.IsTrue(ϒblocked_iframe) {
							τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.StrLiteral(" Visit %s for more details"), ϒblocked_iframe))
							ϒmsg = τmp0
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmsg), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.Contains(ϒfirst_block, λ.StrLiteral("<title>The URL you requested has been blocked</title>")) {
						ϒmsg = λ.StrLiteral("Access to this webpage has been blocked by Indian censorship. Use a VPN or proxy server (with --proxy) to route around it.")
						ϒblock_msg = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
							λ.StrLiteral("</h1><p>(.*?)</p>"),
							ϒcontent,
							λ.StrLiteral("block message"),
						), λ.KWArgs{
							{Name: "default", Value: λ.None},
						})
						if λ.IsTrue(ϒblock_msg) {
							τmp0 = λ.IAdd(ϒmsg, λ.Mod(λ.StrLiteral(" (Message: \"%s\")"), λ.Calm(ϒblock_msg, "replace", λ.StrLiteral("\n"), λ.StrLiteral(" "))))
							ϒmsg = τmp0
						}
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒmsg), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(λ.Contains(ϒcontent, λ.StrLiteral("<title>TTK :: Доступ к ресурсу ограничен</title>"))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(ϒcontent, λ.StrLiteral("blocklist.rkn.gov.ru")))
						}
					}()) {
						panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(λ.StrLiteral("Access to this webpage has been blocked by decision of the Russian government. Visit http://blocklist.rkn.gov.ru/ for a block reason.")), λ.KWArgs{
							{Name: "expected", Value: λ.True},
						})))
					}
					return λ.None
				})
			InfoExtractor__webpage_read_content = λ.NewFunction("_webpage_read_content",
				[]λ.Param{
					{Name: "self"},
					{Name: "urlh"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "prefix", Def: λ.None},
					{Name: "encoding", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabsfilepath    λ.Object
						ϒbasen          λ.Object
						ϒcontent        λ.Object
						ϒcontent_type   λ.Object
						ϒdump           λ.Object
						ϒencoding       = λargs[8]
						ϒerrnote        = λargs[5]
						ϒfatal          = λargs[6]
						ϒfilename       λ.Object
						ϒh              λ.Object
						ϒnote           = λargs[4]
						ϒoutf           λ.Object
						ϒprefix         = λargs[7]
						ϒraw_filename   λ.Object
						ϒself           = λargs[0]
						ϒurl_or_request = λargs[2]
						ϒurlh           = λargs[1]
						ϒvideo_id       = λargs[3]
						ϒwebpage_bytes  λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
						τmp3            λ.Object
					)
					_ = ϒerrnote
					_ = ϒfatal
					_ = ϒnote
					_ = ϒurl_or_request
					_ = τmp0
					_ = τmp1
					_ = τmp2
					_ = τmp3
					ϒcontent_type = λ.Calm(λ.GetAttr(ϒurlh, "headers", nil), "get", λ.StrLiteral("Content-Type"), λ.StrLiteral(""))
					ϒwebpage_bytes = λ.Calm(ϒurlh, "read")
					if ϒprefix != λ.None {
						ϒwebpage_bytes = λ.Add(ϒprefix, ϒwebpage_bytes)
					}
					if !λ.IsTrue(ϒencoding) {
						ϒencoding = λ.Calm(ϒself, "_guess_encoding_from_content", ϒcontent_type, ϒwebpage_bytes)
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("dump_intermediate_pages"), λ.False)) {
						λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("Dumping request to "), λ.Calm(ϒurlh, "geturl")))
						ϒdump = λ.Calm(λ.Cal(Ωbase64.ϒb64encode, ϒwebpage_bytes), "decode", λ.StrLiteral("ascii"))
						λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", ϒdump)
					}
					if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("write_pages"), λ.False)) {
						ϒbasen = λ.Mod(λ.StrLiteral("%s_%s"), λ.NewTuple(
							ϒvideo_id,
							λ.Calm(ϒurlh, "geturl"),
						))
						if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒbasen), λ.IntLiteral(240))) {
							ϒh = λ.Add(λ.StrLiteral("___"), λ.Calm(λ.Calm(λ.None, "md5", λ.Calm(ϒbasen, "encode", λ.StrLiteral("utf-8"))), "hexdigest"))
							ϒbasen = λ.Add(λ.GetItem(ϒbasen, λ.NewSlice(λ.None, λ.Sub(λ.IntLiteral(240), λ.Cal(λ.BuiltinLen, ϒh)), λ.None)), ϒh)
						}
						ϒraw_filename = λ.Add(ϒbasen, λ.StrLiteral(".dump"))
						ϒfilename = λ.Call(ϒsanitize_filename, λ.NewArgs(ϒraw_filename), λ.KWArgs{
							{Name: "restricted", Value: λ.True},
						})
						λ.Calm(ϒself, "to_screen", λ.Add(λ.StrLiteral("Saving request to "), ϒfilename))
						if λ.IsTrue(λ.Eq(λ.None, λ.StrLiteral("nt"))) {
							ϒabsfilepath = λ.Cal(λ.None, ϒfilename)
							if λ.IsTrue(λ.Gt(λ.Cal(λ.BuiltinLen, ϒabsfilepath), λ.IntLiteral(259))) {
								ϒfilename = λ.Add(λ.StrLiteral("\\\\?\\"), ϒabsfilepath)
							}
						}
						τmp0 = λ.Cal(λ.BuiltinOpen, ϒfilename, λ.StrLiteral("wb"))
						τmp1 = λ.GetAttr(τmp0, "__exit__", nil)
						ϒoutf = λ.Calm(τmp0, "__enter__")
						τmp2, τmp3 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.Catch(λ.BaseExceptionType, func(λex λ.BaseException) {
								if ret := λ.Cal(τmp1, λex.Type(), λex, λ.StrLiteral("..todo..traceback..")); λ.IsTrue(ret) {
									panic(λ.Raise(λex))
								}
							}, func() {
								λ.Cal(τmp1, λ.None, λ.None, λ.None)
							})
							λ.Calm(ϒoutf, "write", ϒwebpage_bytes)
							return λ.BlockExitNormally, nil
						}()
					}
					τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.LookupErrorType, func(λex λ.BaseException) {
								ϒcontent = λ.Calm(ϒwebpage_bytes, "decode", λ.StrLiteral("utf-8"), λ.StrLiteral("replace"))
							}},
						)
						ϒcontent = λ.Calm(ϒwebpage_bytes, "decode", ϒencoding, λ.StrLiteral("replace"))
						return λ.BlockExitNormally, nil
					}()
					λ.Calm(ϒself, "__check_blocked", ϒcontent)
					return ϒcontent
				})
			InfoExtractor__download_webpage = λ.NewFunction("_download_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "tries", Def: λ.IntLiteral(1)},
					{Name: "timeout", Def: λ.IntLiteral(5)},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent         λ.Object
						ϒdata            = λargs[9]
						ϒencoding        = λargs[8]
						ϒerrnote         = λargs[4]
						ϒexpected_status = λargs[12]
						ϒfatal           = λargs[5]
						ϒheaders         = λargs[10]
						ϒnote            = λargs[3]
						ϒquery           = λargs[11]
						ϒres             λ.Object
						ϒself            = λargs[0]
						ϒsuccess         λ.Object
						ϒtimeout         = λargs[7]
						ϒtries           = λargs[6]
						ϒtry_count       λ.Object
						ϒurl_or_request  = λargs[1]
						ϒvideo_id        = λargs[2]
						τmp0             λ.Object
						τmp1             λ.Object
						τmp2             λ.Object
					)
					_ = τmp0
					ϒsuccess = λ.False
					ϒtry_count = λ.IntLiteral(0)
					for ϒsuccess == λ.False {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.GetAttr(ϒcompat_http_client, "IncompleteRead", nil), func(λex λ.BaseException) {
									var ϒe λ.Object = λex
									τmp2 = λ.IAdd(ϒtry_count, λ.IntLiteral(1))
									ϒtry_count = τmp2
									if λ.IsTrue(λ.Ge(ϒtry_count, ϒtries)) {
										panic(λ.Raise(ϒe))
									}
									λ.Calm(ϒself, "_sleep", ϒtimeout, ϒvideo_id)
								}},
							)
							ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
								ϒurl_or_request,
								ϒvideo_id,
								ϒnote,
								ϒerrnote,
								ϒfatal,
							), λ.KWArgs{
								{Name: "encoding", Value: ϒencoding},
								{Name: "data", Value: ϒdata},
								{Name: "headers", Value: ϒheaders},
								{Name: "query", Value: ϒquery},
								{Name: "expected_status", Value: ϒexpected_status},
							})
							ϒsuccess = λ.True
							return λ.BlockExitNormally, nil
						}()
					}
					if ϒres == λ.False {
						return ϒres
					} else {
						τmp1 = ϒres
						ϒcontent = λ.GetItem(τmp1, λ.IntLiteral(0))
						_ = λ.GetItem(τmp1, λ.IntLiteral(1))
						return ϒcontent
					}
					return λ.None
				})
			InfoExtractor__download_xml_handle = λ.NewFunction("_download_xml_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.StrLiteral("Downloading XML")},
					{Name: "errnote", Def: λ.StrLiteral("Unable to download XML")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒurlh             λ.Object
						ϒvideo_id         = λargs[2]
						ϒxml_string       λ.Object
						τmp0              λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if ϒres == λ.False {
						return ϒres
					}
					τmp0 = ϒres
					ϒxml_string = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					return λ.NewTuple(
						λ.Call(λ.GetAttr(ϒself, "_parse_xml", nil), λ.NewArgs(
							ϒxml_string,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒtransform_source},
							{Name: "fatal", Value: ϒfatal},
						}),
						ϒurlh,
					)
				})
			InfoExtractor__download_xml = λ.NewFunction("_download_xml",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.StrLiteral("Downloading XML")},
					{Name: "errnote", Def: λ.StrLiteral("Unable to download XML")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒvideo_id         = λargs[2]
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: ϒnote},
						{Name: "errnote", Value: ϒerrnote},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					return func() λ.Object {
						if ϒres == λ.False {
							return ϒres
						} else {
							return λ.GetItem(ϒres, λ.IntLiteral(0))
						}
					}()
				})
			InfoExtractor__parse_xml = λ.NewFunction("_parse_xml",
				[]λ.Param{
					{Name: "self"},
					{Name: "xml_string"},
					{Name: "video_id"},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrmsg           λ.Object
						ϒfatal            = λargs[4]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[3]
						ϒvideo_id         = λargs[2]
						ϒxml_string       = λargs[1]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if λ.IsTrue(ϒtransform_source) {
						ϒxml_string = λ.Cal(ϒtransform_source, ϒxml_string)
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ϒcompat_xml_parse_error, func(λex λ.BaseException) {
								var ϒve λ.Object = λex
								ϒerrmsg = λ.Mod(λ.StrLiteral("%s: Failed to parse XML "), ϒvideo_id)
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerrmsg), λ.KWArgs{
										{Name: "cause", Value: ϒve},
									})))
								} else {
									λ.Calm(ϒself, "report_warning", λ.Add(ϒerrmsg, λ.Cal(λ.StrType, ϒve)))
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(ϒcompat_etree_fromstring, λ.Calm(ϒxml_string, "encode", λ.StrLiteral("utf-8")))
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor__download_json_handle = λ.NewFunction("_download_json_handle",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.StrLiteral("Downloading JSON metadata")},
					{Name: "errnote", Def: λ.StrLiteral("Unable to download JSON metadata")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒjson_string      λ.Object
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒurlh             λ.Object
						ϒvideo_id         = λargs[2]
						τmp0              λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
						ϒnote,
						ϒerrnote,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					if ϒres == λ.False {
						return ϒres
					}
					τmp0 = ϒres
					ϒjson_string = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					return λ.NewTuple(
						λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							ϒjson_string,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "transform_source", Value: ϒtransform_source},
							{Name: "fatal", Value: ϒfatal},
						}),
						ϒurlh,
					)
				})
			InfoExtractor__download_json = λ.NewFunction("_download_json",
				[]λ.Param{
					{Name: "self"},
					{Name: "url_or_request"},
					{Name: "video_id"},
					{Name: "note", Def: λ.StrLiteral("Downloading JSON metadata")},
					{Name: "errnote", Def: λ.StrLiteral("Unable to download JSON metadata")},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "encoding", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "expected_status", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒencoding         = λargs[7]
						ϒerrnote          = λargs[4]
						ϒexpected_status  = λargs[11]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒnote             = λargs[3]
						ϒquery            = λargs[10]
						ϒres              λ.Object
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒurl_or_request   = λargs[1]
						ϒvideo_id         = λargs[2]
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_json_handle", nil), λ.NewArgs(
						ϒurl_or_request,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: ϒnote},
						{Name: "errnote", Value: ϒerrnote},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "encoding", Value: ϒencoding},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
						{Name: "expected_status", Value: ϒexpected_status},
					})
					return func() λ.Object {
						if ϒres == λ.False {
							return ϒres
						} else {
							return λ.GetItem(ϒres, λ.IntLiteral(0))
						}
					}()
				})
			InfoExtractor__parse_json = λ.NewFunction("_parse_json",
				[]λ.Param{
					{Name: "self"},
					{Name: "json_string"},
					{Name: "video_id"},
					{Name: "transform_source", Def: λ.None},
					{Name: "fatal", Def: λ.True},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒerrmsg           λ.Object
						ϒfatal            = λargs[4]
						ϒjson_string      = λargs[1]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[3]
						ϒvideo_id         = λargs[2]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if λ.IsTrue(ϒtransform_source) {
						ϒjson_string = λ.Cal(ϒtransform_source, ϒjson_string)
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
								var ϒve λ.Object = λex
								ϒerrmsg = λ.Mod(λ.StrLiteral("%s: Failed to parse JSON "), ϒvideo_id)
								if λ.IsTrue(ϒfatal) {
									panic(λ.Raise(λ.Call(ExtractorError, λ.NewArgs(ϒerrmsg), λ.KWArgs{
										{Name: "cause", Value: ϒve},
									})))
								} else {
									λ.Calm(ϒself, "report_warning", λ.Add(ϒerrmsg, λ.Cal(λ.StrType, ϒve)))
								}
							}},
						)
						λexit, λret = λ.BlockExitReturn, λ.Cal(Ωjson.ϒloads, ϒjson_string)
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor_report_warning = λ.NewFunction("report_warning",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
					{Name: "video_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒidstr    λ.Object
						ϒmsg      = λargs[1]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					ϒidstr = func() λ.Object {
						if ϒvideo_id == λ.None {
							return λ.StrLiteral("")
						} else {
							return λ.Mod(λ.StrLiteral("%s: "), ϒvideo_id)
						}
					}()
					λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.Mod(λ.StrLiteral("[%s] %s%s"), λ.NewTuple(
						λ.GetAttr(ϒself, "IE_NAME", nil),
						ϒidstr,
						ϒmsg,
					)))
					return λ.None
				})
			InfoExtractor_to_screen = λ.NewFunction("to_screen",
				[]λ.Param{
					{Name: "self"},
					{Name: "msg"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒmsg  = λargs[1]
						ϒself = λargs[0]
					)
					λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "to_screen", λ.Mod(λ.StrLiteral("[%s] %s"), λ.NewTuple(
						λ.GetAttr(ϒself, "IE_NAME", nil),
						ϒmsg,
					)))
					return λ.None
				})
			InfoExtractor_report_extraction = λ.NewFunction("report_extraction",
				[]λ.Param{
					{Name: "self"},
					{Name: "id_or_name"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒid_or_name = λargs[1]
						ϒself       = λargs[0]
					)
					λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("%s: Extracting information"), ϒid_or_name))
					return λ.None
				})
			InfoExtractor_report_download_webpage = λ.NewFunction("report_download_webpage",
				[]λ.Param{
					{Name: "self"},
					{Name: "video_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself     = λargs[0]
						ϒvideo_id = λargs[1]
					)
					λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("%s: Downloading webpage"), ϒvideo_id))
					return λ.None
				})
			InfoExtractor_raise_geo_restricted = λ.NewFunction("raise_geo_restricted",
				[]λ.Param{
					{Name: "msg", Def: λ.StrLiteral("This video is not available from your location due to geo restriction")},
					{Name: "countries", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcountries = λargs[1]
						ϒmsg       = λargs[0]
					)
					panic(λ.Raise(λ.Call(GeoRestrictedError, λ.NewArgs(ϒmsg), λ.KWArgs{
						{Name: "countries", Value: ϒcountries},
					})))
					return λ.None
				})
			InfoExtractor_raise_geo_restricted = λ.Cal(λ.StaticMethodType, InfoExtractor_raise_geo_restricted)
			InfoExtractor_url_result = λ.NewFunction("url_result",
				[]λ.Param{
					{Name: "url"},
					{Name: "ie", Def: λ.None},
					{Name: "video_id", Def: λ.None},
					{Name: "video_title", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒie          = λargs[1]
						ϒurl         = λargs[0]
						ϒvideo_id    = λargs[2]
						ϒvideo_info  λ.Object
						ϒvideo_title = λargs[3]
					)
					ϒvideo_info = λ.DictLiteral(map[string]λ.Object{
						"_type":  λ.StrLiteral("url"),
						"url":    ϒurl,
						"ie_key": ϒie,
					})
					if ϒvideo_id != λ.None {
						λ.SetItem(ϒvideo_info, λ.StrLiteral("id"), ϒvideo_id)
					}
					if ϒvideo_title != λ.None {
						λ.SetItem(ϒvideo_info, λ.StrLiteral("title"), ϒvideo_title)
					}
					return ϒvideo_info
				})
			InfoExtractor_url_result = λ.Cal(λ.StaticMethodType, InfoExtractor_url_result)
			InfoExtractor_playlist_result = λ.NewFunction("playlist_result",
				[]λ.Param{
					{Name: "entries"},
					{Name: "playlist_id", Def: λ.None},
					{Name: "playlist_title", Def: λ.None},
					{Name: "playlist_description", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒentries              = λargs[0]
						ϒplaylist_description = λargs[3]
						ϒplaylist_id          = λargs[1]
						ϒplaylist_title       = λargs[2]
						ϒvideo_info           λ.Object
					)
					ϒvideo_info = λ.DictLiteral(map[string]λ.Object{
						"_type":   λ.StrLiteral("playlist"),
						"entries": ϒentries,
					})
					if λ.IsTrue(ϒplaylist_id) {
						λ.SetItem(ϒvideo_info, λ.StrLiteral("id"), ϒplaylist_id)
					}
					if λ.IsTrue(ϒplaylist_title) {
						λ.SetItem(ϒvideo_info, λ.StrLiteral("title"), ϒplaylist_title)
					}
					if λ.IsTrue(ϒplaylist_description) {
						λ.SetItem(ϒvideo_info, λ.StrLiteral("description"), ϒplaylist_description)
					}
					return ϒvideo_info
				})
			InfoExtractor_playlist_result = λ.Cal(λ.StaticMethodType, InfoExtractor_playlist_result)
			InfoExtractor__search_regex = λ.NewFunction("_search_regex",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "string"},
					{Name: "name"},
					{Name: "default", Def: NO_DEFAULT},
					{Name: "fatal", Def: λ.True},
					{Name: "flags", Def: λ.IntLiteral(0)},
					{Name: "group", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_name   λ.Object
						ϒdefault = λargs[4]
						ϒfatal   = λargs[5]
						ϒflags   = λargs[6]
						ϒgroup   = λargs[7]
						ϒmobj    λ.Object
						ϒname    = λargs[3]
						ϒp       λ.Object
						ϒpattern = λargs[1]
						ϒself    = λargs[0]
						ϒstring  = λargs[2]
						τmp0     λ.Object
						τmp1     λ.Object
					)
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpattern, λ.NewTuple(
						λ.StrType,
						ϒcompat_str,
						ϒcompiled_regex_type,
					))) {
						ϒmobj = λ.Cal(Ωre.ϒsearch, ϒpattern, ϒstring, ϒflags)
					} else {
						τmp0 = λ.Cal(λ.BuiltinIter, ϒpattern)
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒp = τmp1
							ϒmobj = λ.Cal(Ωre.ϒsearch, ϒp, ϒstring, ϒflags)
							if λ.IsTrue(ϒmobj) {
								break
							}
						}
					}
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("no_color")))); !λ.IsTrue(λv) {
							return λv
						} else if λv := λ.Ne(λ.None, λ.StrLiteral("nt")); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.None, "isatty")
						}
					}()) {
						ϒ_name = λ.Mod(λ.StrLiteral("[0;34m%s[0m"), ϒname)
					} else {
						ϒ_name = ϒname
					}
					if λ.IsTrue(ϒmobj) {
						if ϒgroup == λ.None {
							return λ.Cal(λ.BuiltinNext, λ.Cal(λ.NewFunction("<generator>",
								nil,
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
										var (
											ϒg   λ.Object
											τmp0 λ.Object
											τmp1 λ.Object
										)
										τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒmobj, "groups"))
										for {
											if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
												break
											}
											ϒg = τmp1
											if ϒg != λ.None {
												λgy.Yield(ϒg)
											}
										}
										return λ.None
									})
								})))
						} else {
							return λ.Calm(ϒmobj, "group", ϒgroup)
						}
					} else {
						if ϒdefault != NO_DEFAULT {
							return ϒdefault
						} else {
							if λ.IsTrue(ϒfatal) {
								panic(λ.Raise(λ.Cal(RegexNotFoundError, λ.Mod(λ.StrLiteral("Unable to extract %s"), ϒ_name))))
							} else {
								λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.Add(λ.Mod(λ.StrLiteral("unable to extract %s"), ϒ_name), λ.Cal(ϒbug_reports_message)))
								return λ.None
							}
						}
					}
					return λ.None
				})
			InfoExtractor__html_search_regex = λ.NewFunction("_html_search_regex",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "string"},
					{Name: "name"},
					{Name: "default", Def: NO_DEFAULT},
					{Name: "fatal", Def: λ.True},
					{Name: "flags", Def: λ.IntLiteral(0)},
					{Name: "group", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault = λargs[4]
						ϒfatal   = λargs[5]
						ϒflags   = λargs[6]
						ϒgroup   = λargs[7]
						ϒname    = λargs[3]
						ϒpattern = λargs[1]
						ϒres     λ.Object
						ϒself    = λargs[0]
						ϒstring  = λargs[2]
					)
					ϒres = λ.Calm(ϒself, "_search_regex", ϒpattern, ϒstring, ϒname, ϒdefault, ϒfatal, ϒflags, ϒgroup)
					if λ.IsTrue(ϒres) {
						return λ.Calm(λ.Cal(ϒclean_html, ϒres), "strip")
					} else {
						return ϒres
					}
					return λ.None
				})
			InfoExtractor__get_netrc_login_info = λ.NewFunction("_get_netrc_login_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "netrc_machine", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒinfo          λ.Object
						ϒnetrc_machine = λargs[1]
						ϒpassword      λ.Object
						ϒself          = λargs[0]
						ϒusername      λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
					)
					_ = τmp0
					_ = τmp1
					ϒusername = λ.None
					ϒpassword = λ.None
					ϒnetrc_machine = func() λ.Object {
						if λv := ϒnetrc_machine; λ.IsTrue(λv) {
							return λv
						} else {
							return λ.GetAttr(ϒself, "_NETRC_MACHINE", nil)
						}
					}()
					if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("usenetrc"), λ.False)) {
						τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
							defer λ.CatchMulti(
								nil,
								&λ.Catcher{λ.NewTuple(
									λ.OSErrorType,
									λ.GetAttr(λ.None, "NetrcParseError", nil),
								), func(λex λ.BaseException) {
									var ϒerr λ.Object = λex
									λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.Mod(λ.StrLiteral("parsing .netrc: %s"), λ.Cal(ϒerror_to_compat_str, ϒerr)))
								}},
							)
							ϒinfo = λ.Calm(λ.Calm(λ.None, "netrc"), "authenticators", ϒnetrc_machine)
							if ϒinfo != λ.None {
								ϒusername = λ.GetItem(ϒinfo, λ.IntLiteral(0))
								ϒpassword = λ.GetItem(ϒinfo, λ.IntLiteral(2))
							} else {
								panic(λ.Raise(λ.Calm(λ.None, "NetrcParseError", λ.Mod(λ.StrLiteral("No authenticators for %s"), ϒnetrc_machine))))
							}
							return λ.BlockExitNormally, nil
						}()
					}
					return λ.NewTuple(
						ϒusername,
						ϒpassword,
					)
				})
			InfoExtractor__get_login_info = λ.NewFunction("_get_login_info",
				[]λ.Param{
					{Name: "self"},
					{Name: "username_option", Def: λ.StrLiteral("username")},
					{Name: "password_option", Def: λ.StrLiteral("password")},
					{Name: "netrc_machine", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdownloader_params λ.Object
						ϒnetrc_machine     = λargs[3]
						ϒpassword          λ.Object
						ϒpassword_option   = λargs[2]
						ϒself              = λargs[0]
						ϒusername          λ.Object
						ϒusername_option   = λargs[1]
						τmp0               λ.Object
					)
					if λ.GetAttr(ϒself, "_downloader", nil) == λ.None {
						return λ.NewTuple(
							λ.None,
							λ.None,
						)
					}
					ϒdownloader_params = λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil)
					if λ.Calm(ϒdownloader_params, "get", ϒusername_option) != λ.None {
						ϒusername = λ.GetItem(ϒdownloader_params, ϒusername_option)
						ϒpassword = λ.GetItem(ϒdownloader_params, ϒpassword_option)
					} else {
						τmp0 = λ.Calm(ϒself, "_get_netrc_login_info", ϒnetrc_machine)
						ϒusername = λ.GetItem(τmp0, λ.IntLiteral(0))
						ϒpassword = λ.GetItem(τmp0, λ.IntLiteral(1))
					}
					return λ.NewTuple(
						ϒusername,
						ϒpassword,
					)
				})
			InfoExtractor__og_regexes = λ.NewFunction("_og_regexes",
				[]λ.Param{
					{Name: "prop"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcontent_re  λ.Object
						ϒprop        = λargs[0]
						ϒproperty_re λ.Object
						ϒtemplate    λ.Object
					)
					ϒcontent_re = λ.StrLiteral("content=(?:\"([^\"]+?)\"|\\'([^\\']+?)\\'|\\s*([^\\s\"\\'=<>`]+?))")
					ϒproperty_re = λ.Mod(λ.StrLiteral("(?:name|property)=(?:\\'og[:-]%(prop)s\\'|\"og[:-]%(prop)s\"|\\s*og[:-]%(prop)s\\b)"), λ.DictLiteral(map[string]λ.Object{
						"prop": λ.Cal(Ωre.ϒescape, ϒprop),
					}))
					ϒtemplate = λ.StrLiteral("<meta[^>]+?%s[^>]+?%s")
					return λ.NewList(
						λ.Mod(ϒtemplate, λ.NewTuple(
							ϒproperty_re,
							ϒcontent_re,
						)),
						λ.Mod(ϒtemplate, λ.NewTuple(
							ϒcontent_re,
							ϒproperty_re,
						)),
					)
				})
			InfoExtractor__og_regexes = λ.Cal(λ.StaticMethodType, InfoExtractor__og_regexes)
			InfoExtractor__meta_regex = λ.NewFunction("_meta_regex",
				[]λ.Param{
					{Name: "prop"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒprop = λargs[0]
					)
					return λ.Mod(λ.StrLiteral("(?isx)<meta\n                    (?=[^>]+(?:itemprop|name|property|id|http-equiv)=([\"\\']?)%s\\1)\n                    [^>]+?content=([\"\\'])(?P<content>.*?)\\2"), λ.Cal(Ωre.ϒescape, ϒprop))
				})
			InfoExtractor__meta_regex = λ.Cal(λ.StaticMethodType, InfoExtractor__meta_regex)
			InfoExtractor__og_search_property = λ.NewFunction("_og_search_property",
				[]λ.Param{
					{Name: "self"},
					{Name: "prop"},
					{Name: "html"},
					{Name: "name", Def: λ.None},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒescaped    λ.Object
						ϒhtml       = λargs[2]
						ϒkargs      = λargs[4]
						ϒname       = λargs[3]
						ϒog_regexes λ.Object
						ϒp          λ.Object
						ϒprop       = λargs[1]
						ϒself       = λargs[0]
						τmp0        λ.Object
						τmp1        λ.Object
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒprop, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
					))) {
						ϒprop = λ.NewList(ϒprop)
					}
					if ϒname == λ.None {
						ϒname = λ.Mod(λ.StrLiteral("OpenGraph %s"), λ.GetItem(ϒprop, λ.IntLiteral(0)))
					}
					ϒog_regexes = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒprop)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒp = τmp1
						λ.Calm(ϒog_regexes, "extend", λ.Calm(ϒself, "_og_regexes", ϒp))
					}
					ϒescaped = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						ϒog_regexes,
						ϒhtml,
						ϒname,
					), λ.KWArgs{
						{Name: "flags", Value: Ωre.DOTALL},
						{Name: "", Value: ϒkargs},
					})
					if ϒescaped == λ.None {
						return λ.None
					}
					return λ.Cal(ϒunescapeHTML, ϒescaped)
				})
			InfoExtractor__og_search_thumbnail = λ.NewFunction("_og_search_thumbnail",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.StrLiteral("image"),
						ϒhtml,
						λ.StrLiteral("thumbnail URL"),
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_description = λ.NewFunction("_og_search_description",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.StrLiteral("description"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_title = λ.NewFunction("_og_search_title",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.StrLiteral("title"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_video_url = λ.NewFunction("_og_search_video_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
					{Name: "name", Def: λ.StrLiteral("video url")},
					{Name: "secure", Def: λ.True},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml    = λargs[1]
						ϒkargs   = λargs[4]
						ϒname    = λargs[2]
						ϒregexes λ.Object
						ϒsecure  = λargs[3]
						ϒself    = λargs[0]
					)
					ϒregexes = λ.Add(λ.Calm(ϒself, "_og_regexes", λ.StrLiteral("video")), λ.Calm(ϒself, "_og_regexes", λ.StrLiteral("video:url")))
					if λ.IsTrue(ϒsecure) {
						ϒregexes = λ.Add(λ.Calm(ϒself, "_og_regexes", λ.StrLiteral("video:secure_url")), ϒregexes)
					}
					return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						ϒregexes,
						ϒhtml,
						ϒname,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__og_search_url = λ.NewFunction("_og_search_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml  = λargs[1]
						ϒkargs = λargs[2]
						ϒself  = λargs[0]
					)
					return λ.Call(λ.GetAttr(ϒself, "_og_search_property", nil), λ.NewArgs(
						λ.StrLiteral("url"),
						ϒhtml,
					), λ.KWArgs{
						{Name: "", Value: ϒkargs},
					})
				})
			InfoExtractor__html_search_meta = λ.NewFunction("_html_search_meta",
				[]λ.Param{
					{Name: "self"},
					{Name: "name"},
					{Name: "html"},
					{Name: "display_name", Def: λ.None},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdisplay_name = λargs[3]
						ϒfatal        = λargs[4]
						ϒhtml         = λargs[2]
						ϒkwargs       = λargs[5]
						ϒname         = λargs[1]
						ϒself         = λargs[0]
					)
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒname, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
					))) {
						ϒname = λ.NewList(ϒname)
					}
					if ϒdisplay_name == λ.None {
						ϒdisplay_name = λ.GetItem(ϒname, λ.IntLiteral(0))
					}
					return λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒn   λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, ϒname)
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒn = τmp1
										λgy.Yield(λ.Calm(ϒself, "_meta_regex", ϒn))
									}
									return λ.None
								})
							}))),
						ϒhtml,
						ϒdisplay_name,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "group", Value: λ.StrLiteral("content")},
						{Name: "", Value: ϒkwargs},
					})
				})
			InfoExtractor__rta_search = λ.NewFunction("_rta_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒhtml = λargs[1]
						ϒself = λargs[0]
					)
					_ = ϒself
					if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.StrLiteral("(?ix)<meta\\s+name=\"rating\"\\s+     content=\"RTA-5042-1996-1400-1577-RTA\""), ϒhtml)) {
						return λ.IntLiteral(18)
					}
					return λ.IntLiteral(0)
				})
			InfoExtractor__media_rating_search = λ.NewFunction("_media_rating_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						RATING_TABLE λ.Object
						ϒhtml        = λargs[1]
						ϒrating      λ.Object
						ϒself        = λargs[0]
					)
					ϒrating = λ.Calm(ϒself, "_html_search_meta", λ.StrLiteral("rating"), ϒhtml)
					if !λ.IsTrue(ϒrating) {
						return λ.None
					}
					RATING_TABLE = λ.DictLiteral(map[string]int{
						"safe for kids": 0,
						"general":       8,
						"14 years":      14,
						"mature":        17,
						"restricted":    19,
					})
					return λ.Calm(RATING_TABLE, "get", λ.Calm(ϒrating, "lower"))
				})
			InfoExtractor__search_json_ld = λ.NewFunction("_search_json_ld",
				[]λ.Param{
					{Name: "self"},
					{Name: "html"},
					{Name: "video_id"},
					{Name: "expected_type", Def: λ.None},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdefault       λ.Object
						ϒexpected_type = λargs[3]
						ϒfatal         λ.Object
						ϒhtml          = λargs[1]
						ϒjson_ld       λ.Object
						ϒjson_ld_it    λ.Object
						ϒjson_ld_item  λ.Object
						ϒkwargs        = λargs[4]
						ϒmobj          λ.Object
						ϒself          = λargs[0]
						ϒvideo_id      = λargs[2]
						τmp0           λ.Object
						τmp1           λ.Object
					)
					ϒjson_ld_it = λ.Cal(Ωre.ϒfinditer, JSON_LD_RE, ϒhtml)
					ϒdefault = λ.Calm(ϒkwargs, "get", λ.StrLiteral("default"), NO_DEFAULT)
					ϒfatal = func() λ.Object {
						if λ.IsTrue(λ.Eq(ϒdefault, NO_DEFAULT)) {
							return λ.Calm(ϒkwargs, "get", λ.StrLiteral("fatal"), λ.True)
						} else {
							return λ.False
						}
					}()
					ϒjson_ld = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒjson_ld_it)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmobj = τmp1
						ϒjson_ld_item = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							λ.Calm(ϒmobj, "group", λ.StrLiteral("json_ld")),
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: ϒfatal},
						})
						if !λ.IsTrue(ϒjson_ld_item) {
							continue
						}
						if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld_item, λ.DictType)) {
							λ.Calm(ϒjson_ld, "append", ϒjson_ld_item)
						} else {
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld_item, λ.NewTuple(
								λ.ListType,
								λ.TupleType,
							))) {
								λ.Calm(ϒjson_ld, "extend", ϒjson_ld_item)
							}
						}
					}
					if λ.IsTrue(ϒjson_ld) {
						ϒjson_ld = λ.Call(λ.GetAttr(ϒself, "_json_ld", nil), λ.NewArgs(
							ϒjson_ld,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: ϒfatal},
							{Name: "expected_type", Value: ϒexpected_type},
						})
					}
					if λ.IsTrue(ϒjson_ld) {
						return ϒjson_ld
					}
					if ϒdefault != NO_DEFAULT {
						return ϒdefault
					} else {
						if λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(RegexNotFoundError, λ.StrLiteral("Unable to extract JSON-LD"))))
						} else {
							λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", λ.Mod(λ.StrLiteral("unable to extract JSON-LD %s"), λ.Cal(ϒbug_reports_message)))
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						}
					}
					return λ.None
				})
			InfoExtractor__json_ld = λ.NewFunction("_json_ld",
				[]λ.Param{
					{Name: "self"},
					{Name: "json_ld"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "expected_type", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						INTERACTION_TYPE_MAP           λ.Object
						ϒe                             λ.Object
						ϒepisode_name                  λ.Object
						ϒexpected_type                 = λargs[4]
						ϒextract_interaction_statistic λ.Object
						ϒextract_video_object          λ.Object
						ϒfatal                         = λargs[3]
						ϒinfo                          λ.Object
						ϒitem_type                     λ.Object
						ϒjson_ld                       = λargs[1]
						ϒpart_of_season                λ.Object
						ϒpart_of_series                λ.Object
						ϒself                          = λargs[0]
						ϒvideo                         λ.Object
						ϒvideo_id                      = λargs[2]
						τmp0                           λ.Object
						τmp1                           λ.Object
					)
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, ϒcompat_str)) {
						ϒjson_ld = λ.Call(λ.GetAttr(ϒself, "_parse_json", nil), λ.NewArgs(
							ϒjson_ld,
							ϒvideo_id,
						), λ.KWArgs{
							{Name: "fatal", Value: ϒfatal},
						})
					}
					if !λ.IsTrue(ϒjson_ld) {
						return λ.DictLiteral(map[λ.Object]λ.Object{})
					}
					ϒinfo = λ.DictLiteral(map[λ.Object]λ.Object{})
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, λ.NewTuple(
						λ.ListType,
						λ.TupleType,
						λ.DictType,
					))) {
						return ϒinfo
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒjson_ld, λ.DictType)) {
						ϒjson_ld = λ.NewList(ϒjson_ld)
					}
					INTERACTION_TYPE_MAP = λ.DictLiteral(map[string]string{
						"CommentAction":  "comment",
						"AgreeAction":    "like",
						"DisagreeAction": "dislike",
						"LikeAction":     "like",
						"DislikeAction":  "dislike",
						"ListenAction":   "view",
						"WatchAction":    "view",
						"ViewAction":     "view",
					})
					ϒextract_interaction_statistic = λ.NewFunction("extract_interaction_statistic",
						[]λ.Param{
							{Name: "e"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcount_key             λ.Object
								ϒcount_kind            λ.Object
								ϒe                     = λargs[0]
								ϒinteraction_count     λ.Object
								ϒinteraction_statistic λ.Object
								ϒinteraction_type      λ.Object
								ϒis_e                  λ.Object
								τmp0                   λ.Object
								τmp1                   λ.Object
							)
							ϒinteraction_statistic = λ.Calm(ϒe, "get", λ.StrLiteral("interactionStatistic"))
							if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒinteraction_statistic, λ.ListType)) {
								return λ.None
							}
							τmp0 = λ.Cal(λ.BuiltinIter, ϒinteraction_statistic)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒis_e = τmp1
								if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒis_e, λ.DictType)) {
									continue
								}
								if λ.IsTrue(λ.Ne(λ.Calm(ϒis_e, "get", λ.StrLiteral("@type")), λ.StrLiteral("InteractionCounter"))) {
									continue
								}
								ϒinteraction_type = λ.Calm(ϒis_e, "get", λ.StrLiteral("interactionType"))
								if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒinteraction_type, ϒcompat_str)) {
									continue
								}
								ϒinteraction_count = λ.Cal(ϒstr_to_int, λ.Calm(ϒis_e, "get", λ.StrLiteral("userInteractionCount")))
								if ϒinteraction_count == λ.None {
									continue
								}
								ϒcount_kind = λ.Calm(INTERACTION_TYPE_MAP, "get", λ.GetItem(λ.Calm(ϒinteraction_type, "split", λ.StrLiteral("/")), λ.Neg(λ.IntLiteral(1))))
								if !λ.IsTrue(ϒcount_kind) {
									continue
								}
								ϒcount_key = λ.Mod(λ.StrLiteral("%s_count"), ϒcount_kind)
								if λ.Calm(ϒinfo, "get", ϒcount_key) != λ.None {
									continue
								}
								λ.SetItem(ϒinfo, ϒcount_key, ϒinteraction_count)
							}
							return λ.None
						})
					ϒextract_video_object = λ.NewFunction("extract_video_object",
						[]λ.Param{
							{Name: "e"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒe = λargs[0]
							)
							if !λ.IsTrue(λ.Eq(λ.GetItem(ϒe, λ.StrLiteral("@type")), λ.StrLiteral("VideoObject"))) {
								panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
							}
							λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
								"url":         λ.Cal(ϒurl_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("contentUrl"))),
								"title":       λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("name"))),
								"description": λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("description"))),
								"thumbnail": λ.Cal(ϒurl_or_none, func() λ.Object {
									if λv := λ.Calm(ϒe, "get", λ.StrLiteral("thumbnailUrl")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒe, "get", λ.StrLiteral("thumbnailURL"))
									}
								}()),
								"duration":   λ.Cal(ϒparse_duration, λ.Calm(ϒe, "get", λ.StrLiteral("duration"))),
								"timestamp":  λ.Cal(ϒunified_timestamp, λ.Calm(ϒe, "get", λ.StrLiteral("uploadDate"))),
								"uploader":   λ.Cal(ϒstr_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("author"))),
								"filesize":   λ.Cal(ϒfloat_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("contentSize"))),
								"tbr":        λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("bitrate"))),
								"width":      λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("width"))),
								"height":     λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("height"))),
								"view_count": λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("interactionCount"))),
							}))
							λ.Cal(ϒextract_interaction_statistic, ϒe)
							return λ.None
						})
					τmp0 = λ.Cal(λ.BuiltinIter, ϒjson_ld)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒe = τmp1
						if λ.Contains(ϒe, λ.StrLiteral("@context")) {
							ϒitem_type = λ.Calm(ϒe, "get", λ.StrLiteral("@type"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(ϒexpected_type != λ.None); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Ne(ϒexpected_type, ϒitem_type)
								}
							}()) {
								continue
							}
							if λ.Contains(λ.NewTuple(
								λ.StrLiteral("TVEpisode"),
								λ.StrLiteral("Episode"),
							), ϒitem_type) {
								ϒepisode_name = λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("name")))
								λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
									"episode":        ϒepisode_name,
									"episode_number": λ.Cal(ϒint_or_none, λ.Calm(ϒe, "get", λ.StrLiteral("episodeNumber"))),
									"description":    λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("description"))),
								}))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(λ.Calm(ϒinfo, "get", λ.StrLiteral("title")))); !λ.IsTrue(λv) {
										return λv
									} else {
										return ϒepisode_name
									}
								}()) {
									λ.SetItem(ϒinfo, λ.StrLiteral("title"), ϒepisode_name)
								}
								ϒpart_of_season = λ.Calm(ϒe, "get", λ.StrLiteral("partOfSeason"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinIsInstance, ϒpart_of_season, λ.DictType); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.StrLiteral("TVSeason"),
											λ.StrLiteral("Season"),
											λ.StrLiteral("CreativeWorkSeason"),
										), λ.Calm(ϒpart_of_season, "get", λ.StrLiteral("@type"))))
									}
								}()) {
									λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
										"season":        λ.Cal(ϒunescapeHTML, λ.Calm(ϒpart_of_season, "get", λ.StrLiteral("name"))),
										"season_number": λ.Cal(ϒint_or_none, λ.Calm(ϒpart_of_season, "get", λ.StrLiteral("seasonNumber"))),
									}))
								}
								ϒpart_of_series = func() λ.Object {
									if λv := λ.Calm(ϒe, "get", λ.StrLiteral("partOfSeries")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒe, "get", λ.StrLiteral("partOfTVSeries"))
									}
								}()
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Cal(λ.BuiltinIsInstance, ϒpart_of_series, λ.DictType); !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.StrLiteral("TVSeries"),
											λ.StrLiteral("Series"),
											λ.StrLiteral("CreativeWorkSeries"),
										), λ.Calm(ϒpart_of_series, "get", λ.StrLiteral("@type"))))
									}
								}()) {
									λ.SetItem(ϒinfo, λ.StrLiteral("series"), λ.Cal(ϒunescapeHTML, λ.Calm(ϒpart_of_series, "get", λ.StrLiteral("name"))))
								}
							} else {
								if λ.IsTrue(λ.Eq(ϒitem_type, λ.StrLiteral("Movie"))) {
									λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
										"title":       λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("name"))),
										"description": λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("description"))),
										"duration":    λ.Cal(ϒparse_duration, λ.Calm(ϒe, "get", λ.StrLiteral("duration"))),
										"timestamp":   λ.Cal(ϒunified_timestamp, λ.Calm(ϒe, "get", λ.StrLiteral("dateCreated"))),
									}))
								} else {
									if λ.Contains(λ.NewTuple(
										λ.StrLiteral("Article"),
										λ.StrLiteral("NewsArticle"),
									), ϒitem_type) {
										λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
											"timestamp":   λ.Cal(ϒparse_iso8601, λ.Calm(ϒe, "get", λ.StrLiteral("datePublished"))),
											"title":       λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("headline"))),
											"description": λ.Cal(ϒunescapeHTML, λ.Calm(ϒe, "get", λ.StrLiteral("articleBody"))),
										}))
									} else {
										if λ.IsTrue(λ.Eq(ϒitem_type, λ.StrLiteral("VideoObject"))) {
											λ.Cal(ϒextract_video_object, ϒe)
											if ϒexpected_type == λ.None {
												continue
											} else {
												break
											}
										}
									}
								}
							}
							ϒvideo = λ.Calm(ϒe, "get", λ.StrLiteral("video"))
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Cal(λ.BuiltinIsInstance, ϒvideo, λ.DictType); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(λ.Calm(ϒvideo, "get", λ.StrLiteral("@type")), λ.StrLiteral("VideoObject"))
								}
							}()) {
								λ.Cal(ϒextract_video_object, ϒvideo)
							}
							if ϒexpected_type == λ.None {
								continue
							} else {
								break
							}
						}
					}
					return λ.Cal(λ.DictType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒk   λ.Object
									ϒv   λ.Object
									τmp0 λ.Object
									τmp1 λ.Object
									τmp2 λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒinfo, "items"))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒk = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒv = λ.GetItem(τmp2, λ.IntLiteral(1))
									if ϒv != λ.None {
										λgy.Yield(λ.NewTuple(
											ϒk,
											ϒv,
										))
									}
								}
								return λ.None
							})
						})))
				})
			InfoExtractor__hidden_inputs = λ.NewFunction("_hidden_inputs",
				[]λ.Param{
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒattrs         λ.Object
						ϒhidden_inputs λ.Object
						ϒhtml          = λargs[0]
						ϒinput         λ.Object
						ϒname          λ.Object
						ϒvalue         λ.Object
						τmp0           λ.Object
						τmp1           λ.Object
					)
					ϒhtml = λ.Cal(Ωre.ϒsub, λ.StrLiteral("<!--(?:(?!<!--).)*-->"), λ.StrLiteral(""), ϒhtml)
					ϒhidden_inputs = λ.DictLiteral(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.StrLiteral("(?i)(<input[^>]+>)"), ϒhtml))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒinput = τmp1
						ϒattrs = λ.Cal(ϒextract_attributes, ϒinput)
						if !λ.IsTrue(ϒinput) {
							continue
						}
						if !λ.Contains(λ.NewTuple(
							λ.StrLiteral("hidden"),
							λ.StrLiteral("submit"),
						), λ.Calm(ϒattrs, "get", λ.StrLiteral("type"))) {
							continue
						}
						ϒname = func() λ.Object {
							if λv := λ.Calm(ϒattrs, "get", λ.StrLiteral("name")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒattrs, "get", λ.StrLiteral("id"))
							}
						}()
						ϒvalue = λ.Calm(ϒattrs, "get", λ.StrLiteral("value"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒname; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(ϒvalue != λ.None)
							}
						}()) {
							λ.SetItem(ϒhidden_inputs, ϒname, ϒvalue)
						}
					}
					return ϒhidden_inputs
				})
			InfoExtractor__hidden_inputs = λ.Cal(λ.StaticMethodType, InfoExtractor__hidden_inputs)
			InfoExtractor__form_hidden_inputs = λ.NewFunction("_form_hidden_inputs",
				[]λ.Param{
					{Name: "self"},
					{Name: "form_id"},
					{Name: "html"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒform    λ.Object
						ϒform_id = λargs[1]
						ϒhtml    = λargs[2]
						ϒself    = λargs[0]
					)
					ϒform = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.Mod(λ.StrLiteral("(?is)<form[^>]+?id=([\"\\'])%s\\1[^>]*>(?P<form>.+?)</form>"), ϒform_id),
						ϒhtml,
						λ.Mod(λ.StrLiteral("%s form"), ϒform_id),
					), λ.KWArgs{
						{Name: "group", Value: λ.StrLiteral("form")},
					})
					return λ.Calm(ϒself, "_hidden_inputs", ϒform)
				})
			InfoExtractor__sort_formats = λ.NewFunction("_sort_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "formats"},
					{Name: "field_preference", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_formats_key     λ.Object
						ϒf                λ.Object
						ϒfield_preference = λargs[2]
						ϒformats          = λargs[1]
						ϒself             = λargs[0]
						τmp0              λ.Object
						τmp1              λ.Object
					)
					if !λ.IsTrue(ϒformats) {
						panic(λ.Raise(λ.Cal(ExtractorError, λ.StrLiteral("No video formats found"))))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒf = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.Contains(ϒf, λ.StrLiteral("tbr"))); !λ.IsTrue(λv) {
								return λv
							} else if λv := λ.NewBool(λ.Calm(ϒf, "get", λ.StrLiteral("abr")) != λ.None); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Calm(ϒf, "get", λ.StrLiteral("vbr")) != λ.None)
							}
						}()) {
							λ.SetItem(ϒf, λ.StrLiteral("tbr"), λ.Add(λ.GetItem(ϒf, λ.StrLiteral("abr")), λ.GetItem(ϒf, λ.StrLiteral("vbr"))))
						}
					}
					ϒ_formats_key = λ.NewFunction("_formats_key",
						[]λ.Param{
							{Name: "f"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ORDER                 λ.Object
								ϒaudio_ext_preference λ.Object
								ϒdetermine_ext        λ.Object
								ϒext_preference       λ.Object
								ϒf                    = λargs[0]
								ϒpreference           λ.Object
								ϒproto_preference     λ.Object
								ϒprotocol             λ.Object
								τmp0                  λ.Object
								τmp1                  λ.Object
							)
							_ = τmp0
							_ = τmp1
							ϒdetermine_ext = Ωutils.ϒdetermine_ext
							if λ.IsTrue(func() λ.Object {
								if λv := λ.NewBool(!λ.IsTrue(λ.Calm(ϒf, "get", λ.StrLiteral("ext")))); !λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Contains(ϒf, λ.StrLiteral("url")))
								}
							}()) {
								λ.SetItem(ϒf, λ.StrLiteral("ext"), λ.Cal(ϒdetermine_ext, λ.GetItem(ϒf, λ.StrLiteral("url"))))
							}
							if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒfield_preference, λ.NewTuple(
								λ.ListType,
								λ.TupleType,
							))) {
								return λ.Cal(λ.TupleType, λ.Cal(λ.NewFunction("<generator>",
									nil,
									0, false, false,
									func(λargs []λ.Object) λ.Object {
										return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
											var (
												ϒfield λ.Object
												τmp0   λ.Object
												τmp1   λ.Object
											)
											τmp0 = λ.Cal(λ.BuiltinIter, ϒfield_preference)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒfield = τmp1
												λgy.Yield(func() λ.Object {
													if λ.Calm(ϒf, "get", ϒfield) != λ.None {
														return λ.Calm(ϒf, "get", ϒfield)
													} else {
														return func() λ.Object {
															if λ.IsTrue(λ.Eq(ϒfield, λ.StrLiteral("format_id"))) {
																return λ.StrLiteral("")
															} else {
																return λ.Neg(λ.IntLiteral(1))
															}
														}()
													}
												}())
											}
											return λ.None
										})
									})))
							}
							ϒpreference = λ.Calm(ϒf, "get", λ.StrLiteral("preference"))
							if ϒpreference == λ.None {
								ϒpreference = λ.IntLiteral(0)
								if λ.Contains(λ.NewList(
									λ.StrLiteral("f4f"),
									λ.StrLiteral("f4m"),
								), λ.Calm(ϒf, "get", λ.StrLiteral("ext"))) {
									τmp0 = λ.ISub(ϒpreference, λ.FloatLiteral(0.5))
									ϒpreference = τmp0
								}
							}
							ϒprotocol = func() λ.Object {
								if λv := λ.Calm(ϒf, "get", λ.StrLiteral("protocol")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒdetermine_protocol, ϒf)
								}
							}()
							ϒproto_preference = func() λ.Object {
								if λ.Contains(λ.NewList(
									λ.StrLiteral("http"),
									λ.StrLiteral("https"),
								), ϒprotocol) {
									return λ.IntLiteral(0)
								} else {
									return func() λ.Object {
										if λ.IsTrue(λ.Eq(ϒprotocol, λ.StrLiteral("rtsp"))) {
											return λ.Neg(λ.FloatLiteral(0.5))
										} else {
											return λ.Neg(λ.FloatLiteral(0.1))
										}
									}()
								}
							}()
							if λ.IsTrue(λ.Eq(λ.Calm(ϒf, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none"))) {
								τmp0 = λ.ISub(ϒpreference, λ.IntLiteral(50))
								ϒpreference = τmp0
								if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("prefer_free_formats"))) {
									ORDER = λ.NewList(
										λ.StrLiteral("aac"),
										λ.StrLiteral("mp3"),
										λ.StrLiteral("m4a"),
										λ.StrLiteral("webm"),
										λ.StrLiteral("ogg"),
										λ.StrLiteral("opus"),
									)
								} else {
									ORDER = λ.NewList(
										λ.StrLiteral("webm"),
										λ.StrLiteral("opus"),
										λ.StrLiteral("ogg"),
										λ.StrLiteral("mp3"),
										λ.StrLiteral("aac"),
										λ.StrLiteral("m4a"),
									)
								}
								ϒext_preference = λ.IntLiteral(0)
								τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
											ϒaudio_ext_preference = λ.Neg(λ.IntLiteral(1))
										}},
									)
									ϒaudio_ext_preference = λ.Calm(ORDER, "index", λ.GetItem(ϒf, λ.StrLiteral("ext")))
									return λ.BlockExitNormally, nil
								}()
							} else {
								if λ.IsTrue(λ.Eq(λ.Calm(ϒf, "get", λ.StrLiteral("acodec")), λ.StrLiteral("none"))) {
									τmp1 = λ.ISub(ϒpreference, λ.IntLiteral(40))
									ϒpreference = τmp1
								}
								if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("prefer_free_formats"))) {
									ORDER = λ.NewList(
										λ.StrLiteral("flv"),
										λ.StrLiteral("mp4"),
										λ.StrLiteral("webm"),
									)
								} else {
									ORDER = λ.NewList(
										λ.StrLiteral("webm"),
										λ.StrLiteral("flv"),
										λ.StrLiteral("mp4"),
									)
								}
								τmp1, τmp0 = func() (λexit λ.Object, λret λ.Object) {
									defer λ.CatchMulti(
										nil,
										&λ.Catcher{λ.ValueErrorType, func(λex λ.BaseException) {
											ϒext_preference = λ.Neg(λ.IntLiteral(1))
										}},
									)
									ϒext_preference = λ.Calm(ORDER, "index", λ.GetItem(ϒf, λ.StrLiteral("ext")))
									return λ.BlockExitNormally, nil
								}()
								ϒaudio_ext_preference = λ.IntLiteral(0)
							}
							return λ.NewTuple(
								ϒpreference,
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("language_preference")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("language_preference"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("quality")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("quality"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("tbr")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("tbr"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("filesize")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("filesize"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("vbr")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("vbr"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("height")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("height"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("width")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("width"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								ϒproto_preference,
								ϒext_preference,
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("abr")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("abr"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								ϒaudio_ext_preference,
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("fps")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("fps"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("filesize_approx")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("filesize_approx"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("source_preference")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("source_preference"))
									} else {
										return λ.Neg(λ.IntLiteral(1))
									}
								}(),
								func() λ.Object {
									if λ.Calm(ϒf, "get", λ.StrLiteral("format_id")) != λ.None {
										return λ.Calm(ϒf, "get", λ.StrLiteral("format_id"))
									} else {
										return λ.StrLiteral("")
									}
								}(),
							)
						})
					λ.Call(λ.GetAttr(ϒformats, "sort", nil), nil, λ.KWArgs{
						{Name: "key", Value: ϒ_formats_key},
					})
					return λ.None
				})
			InfoExtractor__check_formats = λ.NewFunction("_check_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "formats"},
					{Name: "video_id"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒformats  = λargs[1]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					if λ.IsTrue(ϒformats) {
						λ.SetItem(ϒformats, λ.NewSlice(λ.None, λ.None, λ.None), λ.Cal(λ.FilterIteratorType, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "f"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒf = λargs[0]
								)
								return λ.Call(λ.GetAttr(ϒself, "_is_valid_url", nil), λ.NewArgs(
									λ.GetItem(ϒf, λ.StrLiteral("url")),
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "item", Value: func() λ.Object {
										if λ.IsTrue(λ.Calm(ϒf, "get", λ.StrLiteral("format_id"))) {
											return λ.Mod(λ.StrLiteral("%s video format"), λ.Calm(ϒf, "get", λ.StrLiteral("format_id")))
										} else {
											return λ.StrLiteral("video")
										}
									}()},
								})
							}), ϒformats))
					}
					return λ.None
				})
			InfoExtractor__remove_duplicate_formats = λ.NewFunction("_remove_duplicate_formats",
				[]λ.Param{
					{Name: "formats"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf              λ.Object
						ϒformat_urls    λ.Object
						ϒformats        = λargs[0]
						ϒunique_formats λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
					)
					ϒformat_urls = λ.Cal(λ.SetType)
					ϒunique_formats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒformats)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒf = τmp1
						if !λ.Contains(ϒformat_urls, λ.GetItem(ϒf, λ.StrLiteral("url"))) {
							λ.Calm(ϒformat_urls, "add", λ.GetItem(ϒf, λ.StrLiteral("url")))
							λ.Calm(ϒunique_formats, "append", ϒf)
						}
					}
					λ.SetItem(ϒformats, λ.NewSlice(λ.None, λ.None, λ.None), ϒunique_formats)
					return λ.None
				})
			InfoExtractor__remove_duplicate_formats = λ.Cal(λ.StaticMethodType, InfoExtractor__remove_duplicate_formats)
			InfoExtractor__is_valid_url = λ.NewFunction("_is_valid_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "video_id"},
					{Name: "item", Def: λ.StrLiteral("video")},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒheaders  = λargs[4]
						ϒitem     = λargs[3]
						ϒself     = λargs[0]
						ϒurl      = λargs[1]
						ϒvideo_id = λargs[2]
						τmp0      λ.Object
						τmp1      λ.Object
					)
					ϒurl = λ.Call(λ.GetAttr(ϒself, "_proto_relative_url", nil), λ.NewArgs(ϒurl), λ.KWArgs{
						{Name: "scheme", Value: λ.StrLiteral("http:")},
					})
					if !λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(ϒurl, "startswith", λ.StrLiteral("http://")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒurl, "startswith", λ.StrLiteral("https://"))
						}
					}()) {
						return λ.True
					}
					τmp0, τmp1 = func() (λexit λ.Object, λret λ.Object) {
						defer λ.CatchMulti(
							nil,
							&λ.Catcher{ExtractorError, func(λex λ.BaseException) {
								var ϒe λ.Object = λex
								λ.Calm(ϒself, "to_screen", λ.Mod(λ.StrLiteral("%s: %s URL is invalid, skipping: %s"), λ.NewTuple(
									ϒvideo_id,
									ϒitem,
									λ.Cal(ϒerror_to_compat_str, λ.GetAttr(ϒe, "cause", nil)),
								)))
								λexit, λret = λ.BlockExitReturn, λ.False
								return
							}},
						)
						λ.Call(λ.GetAttr(ϒself, "_request_webpage", nil), λ.NewArgs(
							ϒurl,
							ϒvideo_id,
							λ.Mod(λ.StrLiteral("Checking %s URL"), ϒitem),
						), λ.KWArgs{
							{Name: "headers", Value: ϒheaders},
						})
						λexit, λret = λ.BlockExitReturn, λ.True
						return
						return λ.BlockExitNormally, nil
					}()
					if τmp0 == λ.BlockExitReturn {
						return τmp1
					}
					return λ.None
				})
			InfoExtractor_http_scheme = λ.NewFunction("http_scheme",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					return func() λ.Object {
						if λ.IsTrue(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("prefer_insecure"), λ.False)) {
							return λ.StrLiteral("http:")
						} else {
							return λ.StrLiteral("https:")
						}
					}()
				})
			InfoExtractor__proto_relative_url = λ.NewFunction("_proto_relative_url",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
					{Name: "scheme", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒscheme = λargs[2]
						ϒself   = λargs[0]
						ϒurl    = λargs[1]
					)
					if ϒurl == λ.None {
						return ϒurl
					}
					if λ.IsTrue(λ.Calm(ϒurl, "startswith", λ.StrLiteral("//"))) {
						if ϒscheme == λ.None {
							ϒscheme = λ.Calm(ϒself, "http_scheme")
						}
						return λ.Add(ϒscheme, ϒurl)
					} else {
						return ϒurl
					}
					return λ.None
				})
			InfoExtractor__extract_f4m_formats = λ.NewFunction("_extract_f4m_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "manifest_url"},
					{Name: "video_id"},
					{Name: "preference", Def: λ.None},
					{Name: "f4m_id", Def: λ.None},
					{Name: "transform_source", Def: λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "s"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒs = λargs[0]
							)
							return λ.Calm(λ.Cal(ϒfix_xml_ampersands, ϒs), "strip")
						})},
					{Name: "fatal", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata             = λargs[8]
						ϒf4m_id           = λargs[4]
						ϒfatal            = λargs[6]
						ϒheaders          = λargs[9]
						ϒm3u8_id          = λargs[7]
						ϒmanifest         λ.Object
						ϒmanifest_url     = λargs[1]
						ϒpreference       = λargs[3]
						ϒquery            = λargs[10]
						ϒself             = λargs[0]
						ϒtransform_source = λargs[5]
						ϒvideo_id         = λargs[2]
					)
					ϒmanifest = λ.Call(λ.GetAttr(ϒself, "_download_xml", nil), λ.NewArgs(
						ϒmanifest_url,
						ϒvideo_id,
						λ.StrLiteral("Downloading f4m manifest"),
						λ.StrLiteral("Unable to download f4m manifest"),
					), λ.KWArgs{
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
					})
					if ϒmanifest == λ.False {
						return λ.NewList()
					}
					return λ.Call(λ.GetAttr(ϒself, "_parse_f4m_formats", nil), λ.NewArgs(
						ϒmanifest,
						ϒmanifest_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "preference", Value: ϒpreference},
						{Name: "f4m_id", Value: ϒf4m_id},
						{Name: "transform_source", Value: ϒtransform_source},
						{Name: "fatal", Value: ϒfatal},
						{Name: "m3u8_id", Value: ϒm3u8_id},
					})
				})
			InfoExtractor__parse_f4m_formats = λ.NewFunction("_parse_f4m_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "manifest"},
					{Name: "manifest_url"},
					{Name: "video_id"},
					{Name: "preference", Def: λ.None},
					{Name: "f4m_id", Def: λ.None},
					{Name: "transform_source", Def: λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "s"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒs = λargs[0]
							)
							return λ.Calm(λ.Cal(ϒfix_xml_ampersands, ϒs), "strip")
						})},
					{Name: "fatal", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒakamai_pv                   λ.Object
						ϒbootstrap_info              λ.Object
						ϒext                         λ.Object
						ϒf                           λ.Object
						ϒf4m_formats                 λ.Object
						ϒf4m_id                      = λargs[5]
						ϒfatal                       = λargs[7]
						ϒformat_id                   λ.Object
						ϒformats                     λ.Object
						ϒheight                      λ.Object
						ϒi                           λ.Object
						ϒm3u8_id                     = λargs[8]
						ϒmanifest                    = λargs[1]
						ϒmanifest_base_url           λ.Object
						ϒmanifest_url                = λargs[2]
						ϒmanifest_version            λ.Object
						ϒmedia_el                    λ.Object
						ϒmedia_nodes                 λ.Object
						ϒmedia_url                   λ.Object
						ϒmime_type                   λ.Object
						ϒplayerVerificationChallenge λ.Object
						ϒpreference                  = λargs[4]
						ϒself                        = λargs[0]
						ϒtbr                         λ.Object
						ϒtransform_source            = λargs[6]
						ϒvcodec                      λ.Object
						ϒvideo_id                    = λargs[3]
						ϒwidth                       λ.Object
						τmp0                         λ.Object
						τmp1                         λ.Object
						τmp2                         λ.Object
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒmanifest, ϒcompat_etree_Element))); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.IsTrue(ϒfatal))
						}
					}()) {
						return λ.NewList()
					}
					ϒakamai_pv = λ.Calm(ϒmanifest, "find", λ.StrLiteral("{http://ns.adobe.com/f4m/1.0}pv-2.0"))
					if λ.IsTrue(func() λ.Object {
						if λv := λ.NewBool(ϒakamai_pv != λ.None); !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Contains(λ.GetAttr(ϒakamai_pv, "text", nil), λ.StrLiteral(";")))
						}
					}()) {
						ϒplayerVerificationChallenge = λ.GetItem(λ.Calm(λ.GetAttr(ϒakamai_pv, "text", nil), "split", λ.StrLiteral(";")), λ.IntLiteral(0))
						if λ.IsTrue(λ.Ne(λ.Calm(ϒplayerVerificationChallenge, "strip"), λ.StrLiteral(""))) {
							return λ.NewList()
						}
					}
					ϒformats = λ.NewList()
					ϒmanifest_version = λ.StrLiteral("1.0")
					ϒmedia_nodes = λ.Calm(ϒmanifest, "findall", λ.StrLiteral("{http://ns.adobe.com/f4m/1.0}media"))
					if !λ.IsTrue(ϒmedia_nodes) {
						ϒmanifest_version = λ.StrLiteral("2.0")
						ϒmedia_nodes = λ.Calm(ϒmanifest, "findall", λ.StrLiteral("{http://ns.adobe.com/f4m/2.0}media"))
					}
					ϒmedia_nodes = λ.Cal(ϒremove_encrypted_media, ϒmedia_nodes)
					if !λ.IsTrue(ϒmedia_nodes) {
						return ϒformats
					}
					ϒmanifest_base_url = λ.Cal(ϒget_base_url, ϒmanifest)
					ϒbootstrap_info = λ.Call(ϒxpath_element, λ.NewArgs(
						ϒmanifest,
						λ.NewList(
							λ.StrLiteral("{http://ns.adobe.com/f4m/1.0}bootstrapInfo"),
							λ.StrLiteral("{http://ns.adobe.com/f4m/2.0}bootstrapInfo"),
						),
						λ.StrLiteral("bootstrap info"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒvcodec = λ.None
					ϒmime_type = λ.Call(ϒxpath_text, λ.NewArgs(
						ϒmanifest,
						λ.NewList(
							λ.StrLiteral("{http://ns.adobe.com/f4m/1.0}mimeType"),
							λ.StrLiteral("{http://ns.adobe.com/f4m/2.0}mimeType"),
						),
						λ.StrLiteral("base URL"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					if λ.IsTrue(func() λ.Object {
						if λv := ϒmime_type; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(ϒmime_type, "startswith", λ.StrLiteral("audio/"))
						}
					}()) {
						ϒvcodec = λ.StrLiteral("none")
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒmedia_nodes))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒi = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒmedia_el = λ.GetItem(τmp2, λ.IntLiteral(1))
						ϒtbr = λ.Cal(ϒint_or_none, λ.Calm(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", λ.StrLiteral("bitrate")))
						ϒwidth = λ.Cal(ϒint_or_none, λ.Calm(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", λ.StrLiteral("width")))
						ϒheight = λ.Cal(ϒint_or_none, λ.Calm(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", λ.StrLiteral("height")))
						ϒformat_id = λ.Calm(λ.StrLiteral("-"), "join", λ.Cal(λ.FilterIteratorType, λ.None, λ.NewList(
							ϒf4m_id,
							λ.Cal(ϒcompat_str, func() λ.Object {
								if ϒtbr == λ.None {
									return ϒi
								} else {
									return ϒtbr
								}
							}()),
						)))
						if ϒbootstrap_info == λ.None {
							ϒmedia_url = λ.None
							if λ.IsTrue(λ.Eq(ϒmanifest_version, λ.StrLiteral("2.0"))) {
								ϒmedia_url = λ.Calm(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", λ.StrLiteral("href"))
							}
							if ϒmedia_url == λ.None {
								ϒmedia_url = λ.Calm(λ.GetAttr(ϒmedia_el, "attrib", nil), "get", λ.StrLiteral("url"))
							}
							if !λ.IsTrue(ϒmedia_url) {
								continue
							}
							ϒmanifest_url = func() λ.Object {
								if λ.IsTrue(func() λ.Object {
									if λv := λ.Calm(ϒmedia_url, "startswith", λ.StrLiteral("http://")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒmedia_url, "startswith", λ.StrLiteral("https://"))
									}
								}()) {
									return ϒmedia_url
								} else {
									return λ.Add(λ.Add(func() λ.Object {
										if λv := ϒmanifest_base_url; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(λ.StrLiteral("/"), "join", λ.GetItem(λ.Calm(ϒmanifest_url, "split", λ.StrLiteral("/")), λ.NewSlice(λ.None, λ.Neg(λ.IntLiteral(1)), λ.None)))
										}
									}(), λ.StrLiteral("/")), ϒmedia_url)
								}
							}()
							ϒext = λ.Cal(ϒdetermine_ext, ϒmanifest_url)
							if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("f4m"))) {
								ϒf4m_formats = λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
									ϒmanifest_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "preference", Value: ϒpreference},
									{Name: "f4m_id", Value: ϒf4m_id},
									{Name: "transform_source", Value: ϒtransform_source},
									{Name: "fatal", Value: ϒfatal},
								})
								if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒf4m_formats), λ.IntLiteral(1))) {
									ϒf = λ.GetItem(ϒf4m_formats, λ.IntLiteral(0))
									λ.Calm(ϒf, "update", λ.DictLiteral(map[string]λ.Object{
										"tbr": func() λ.Object {
											if λv := λ.Calm(ϒf, "get", λ.StrLiteral("tbr")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒtbr
											}
										}(),
										"width": func() λ.Object {
											if λv := λ.Calm(ϒf, "get", λ.StrLiteral("width")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒwidth
											}
										}(),
										"height": func() λ.Object {
											if λv := λ.Calm(ϒf, "get", λ.StrLiteral("height")); λ.IsTrue(λv) {
												return λv
											} else {
												return ϒheight
											}
										}(),
										"format_id": func() λ.Object {
											if !λ.IsTrue(ϒtbr) {
												return λ.Calm(ϒf, "get", λ.StrLiteral("format_id"))
											} else {
												return ϒformat_id
											}
										}(),
										"vcodec": ϒvcodec,
									}))
								}
								λ.Calm(ϒformats, "extend", ϒf4m_formats)
								continue
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("m3u8"))) {
									λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
										ϒmanifest_url,
										ϒvideo_id,
										λ.StrLiteral("mp4"),
									), λ.KWArgs{
										{Name: "preference", Value: ϒpreference},
										{Name: "m3u8_id", Value: ϒm3u8_id},
										{Name: "fatal", Value: ϒfatal},
									}))
									continue
								}
							}
						}
						λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
							"format_id":    ϒformat_id,
							"url":          ϒmanifest_url,
							"manifest_url": ϒmanifest_url,
							"ext": func() λ.Object {
								if ϒbootstrap_info != λ.None {
									return λ.StrLiteral("flv")
								} else {
									return λ.None
								}
							}(),
							"protocol":   λ.StrLiteral("f4m"),
							"tbr":        ϒtbr,
							"width":      ϒwidth,
							"height":     ϒheight,
							"vcodec":     ϒvcodec,
							"preference": ϒpreference,
						}))
					}
					return ϒformats
				})
			InfoExtractor__extract_m3u8_formats = λ.NewFunction("_extract_m3u8_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "m3u8_url"},
					{Name: "video_id"},
					{Name: "ext", Def: λ.None},
					{Name: "entry_protocol", Def: λ.StrLiteral("m3u8")},
					{Name: "preference", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "live", Def: λ.False},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata           = λargs[11]
						ϒentry_protocol = λargs[4]
						ϒerrnote        = λargs[8]
						ϒext            = λargs[3]
						ϒfatal          = λargs[9]
						ϒheaders        = λargs[12]
						ϒlive           = λargs[10]
						ϒm3u8_doc       λ.Object
						ϒm3u8_id        = λargs[6]
						ϒm3u8_url       = λargs[1]
						ϒnote           = λargs[7]
						ϒpreference     = λargs[5]
						ϒquery          = λargs[13]
						ϒres            λ.Object
						ϒself           = λargs[0]
						ϒurlh           λ.Object
						ϒvideo_id       = λargs[2]
						τmp0            λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_webpage_handle", nil), λ.NewArgs(
						ϒm3u8_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Downloading m3u8 information")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Failed to download m3u8 information")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
					})
					if ϒres == λ.False {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒm3u8_doc = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					ϒm3u8_url = λ.Calm(ϒurlh, "geturl")
					return λ.Call(λ.GetAttr(ϒself, "_parse_m3u8_formats", nil), λ.NewArgs(
						ϒm3u8_doc,
						ϒm3u8_url,
					), λ.KWArgs{
						{Name: "ext", Value: ϒext},
						{Name: "entry_protocol", Value: ϒentry_protocol},
						{Name: "preference", Value: ϒpreference},
						{Name: "m3u8_id", Value: ϒm3u8_id},
						{Name: "live", Value: ϒlive},
					})
				})
			InfoExtractor__parse_m3u8_formats = λ.NewFunction("_parse_m3u8_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "m3u8_doc"},
					{Name: "m3u8_url"},
					{Name: "ext", Def: λ.None},
					{Name: "entry_protocol", Def: λ.StrLiteral("m3u8")},
					{Name: "preference", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "live", Def: λ.False},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒabr               λ.Object
						ϒaudio_group       λ.Object
						ϒaudio_group_id    λ.Object
						ϒbuild_stream_name λ.Object
						ϒcodecs            λ.Object
						ϒentry_protocol    = λargs[4]
						ϒext               = λargs[3]
						ϒextract_media     λ.Object
						ϒf                 λ.Object
						ϒformat_id         λ.Object
						ϒformat_url        λ.Object
						ϒformats           λ.Object
						ϒgroups            λ.Object
						ϒhttp_f            λ.Object
						ϒlast_stream_inf   λ.Object
						ϒline              λ.Object
						ϒlive              = λargs[7]
						ϒm3u8_doc          = λargs[1]
						ϒm3u8_id           = λargs[6]
						ϒm3u8_url          = λargs[2]
						ϒmanifest_url      λ.Object
						ϒmobj              λ.Object
						ϒpreference        = λargs[5]
						ϒprogressive_uri   λ.Object
						ϒresolution        λ.Object
						ϒself              = λargs[0]
						ϒstream_name       λ.Object
						ϒtbr               λ.Object
						ϒvbr               λ.Object
						τmp0               λ.Object
						τmp1               λ.Object
						τmp2               λ.Object
					)
					_ = ϒself
					if λ.Contains(ϒm3u8_doc, λ.StrLiteral("#EXT-X-FAXS-CM:")) {
						return λ.NewList()
					}
					if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.StrLiteral("#EXT-X-SESSION-KEY:.*?URI=\"skd://"), ϒm3u8_doc)) {
						return λ.NewList()
					}
					ϒformats = λ.NewList()
					ϒformat_url = λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "u"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒu = λargs[0]
							)
							return func() λ.Object {
								if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("^https?://"), ϒu)) {
									return ϒu
								} else {
									return λ.Cal(Ωparse.ϒurljoin, ϒm3u8_url, ϒu)
								}
							}()
						})
					if λ.Contains(ϒm3u8_doc, λ.StrLiteral("#EXT-X-TARGETDURATION")) {
						return λ.NewList(λ.DictLiteral(map[string]λ.Object{
							"url":        ϒm3u8_url,
							"format_id":  ϒm3u8_id,
							"ext":        ϒext,
							"protocol":   ϒentry_protocol,
							"preference": ϒpreference,
						}))
					}
					ϒgroups = λ.DictLiteral(map[λ.Object]λ.Object{})
					ϒlast_stream_inf = λ.DictLiteral(map[λ.Object]λ.Object{})
					ϒextract_media = λ.NewFunction("extract_media",
						[]λ.Param{
							{Name: "x_media_line"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒf            λ.Object
								ϒformat_id    λ.Object
								ϒgroup_id     λ.Object
								ϒmedia        λ.Object
								ϒmedia_type   λ.Object
								ϒmedia_url    λ.Object
								ϒname         λ.Object
								ϒv            λ.Object
								ϒx_media_line = λargs[0]
								τmp0          λ.Object
								τmp1          λ.Object
							)
							ϒmedia = λ.Cal(ϒparse_m3u8_attributes, ϒx_media_line)
							τmp0 = λ.NewTuple(
								λ.Calm(ϒmedia, "get", λ.StrLiteral("TYPE")),
								λ.Calm(ϒmedia, "get", λ.StrLiteral("GROUP-ID")),
								λ.Calm(ϒmedia, "get", λ.StrLiteral("NAME")),
							)
							ϒmedia_type = λ.GetItem(τmp0, λ.IntLiteral(0))
							ϒgroup_id = λ.GetItem(τmp0, λ.IntLiteral(1))
							ϒname = λ.GetItem(τmp0, λ.IntLiteral(2))
							if !λ.IsTrue(func() λ.Object {
								if λv := ϒmedia_type; !λ.IsTrue(λv) {
									return λv
								} else if λv := ϒgroup_id; !λ.IsTrue(λv) {
									return λv
								} else {
									return ϒname
								}
							}()) {
								return λ.None
							}
							λ.Calm(λ.Calm(ϒgroups, "setdefault", ϒgroup_id, λ.NewList()), "append", ϒmedia)
							if !λ.Contains(λ.NewTuple(
								λ.StrLiteral("VIDEO"),
								λ.StrLiteral("AUDIO"),
							), ϒmedia_type) {
								return λ.None
							}
							ϒmedia_url = λ.Calm(ϒmedia, "get", λ.StrLiteral("URI"))
							if λ.IsTrue(ϒmedia_url) {
								ϒformat_id = λ.NewList()
								τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
									ϒm3u8_id,
									ϒgroup_id,
									ϒname,
								))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒv = τmp1
									if λ.IsTrue(ϒv) {
										λ.Calm(ϒformat_id, "append", ϒv)
									}
								}
								ϒf = λ.DictLiteral(map[string]λ.Object{
									"format_id":    λ.Calm(λ.StrLiteral("-"), "join", ϒformat_id),
									"url":          λ.Cal(ϒformat_url, ϒmedia_url),
									"manifest_url": ϒm3u8_url,
									"language":     λ.Calm(ϒmedia, "get", λ.StrLiteral("LANGUAGE")),
									"ext":          ϒext,
									"protocol":     ϒentry_protocol,
									"preference":   ϒpreference,
								})
								if λ.IsTrue(λ.Eq(ϒmedia_type, λ.StrLiteral("AUDIO"))) {
									λ.SetItem(ϒf, λ.StrLiteral("vcodec"), λ.StrLiteral("none"))
								}
								λ.Calm(ϒformats, "append", ϒf)
							}
							return λ.None
						})
					ϒbuild_stream_name = λ.NewFunction("build_stream_name",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒrendition       λ.Object
								ϒstream_group    λ.Object
								ϒstream_group_id λ.Object
								ϒstream_name     λ.Object
							)
							ϒstream_name = λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("NAME"))
							if λ.IsTrue(ϒstream_name) {
								return ϒstream_name
							}
							ϒstream_group_id = λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("VIDEO"))
							if !λ.IsTrue(ϒstream_group_id) {
								return λ.None
							}
							ϒstream_group = λ.Calm(ϒgroups, "get", ϒstream_group_id)
							if !λ.IsTrue(ϒstream_group) {
								return ϒstream_group_id
							}
							ϒrendition = λ.GetItem(ϒstream_group, λ.IntLiteral(0))
							return func() λ.Object {
								if λv := λ.Calm(ϒrendition, "get", λ.StrLiteral("NAME")); λ.IsTrue(λv) {
									return λv
								} else {
									return ϒstream_group_id
								}
							}()
						})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒm3u8_doc, "splitlines"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒline = τmp1
						if λ.IsTrue(λ.Calm(ϒline, "startswith", λ.StrLiteral("#EXT-X-MEDIA:"))) {
							λ.Cal(ϒextract_media, ϒline)
						}
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒm3u8_doc, "splitlines"))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒline = τmp1
						if λ.IsTrue(λ.Calm(ϒline, "startswith", λ.StrLiteral("#EXT-X-STREAM-INF:"))) {
							ϒlast_stream_inf = λ.Cal(ϒparse_m3u8_attributes, ϒline)
						} else {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Calm(ϒline, "startswith", λ.StrLiteral("#")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(!λ.IsTrue(λ.Calm(ϒline, "strip")))
								}
							}()) {
								continue
							} else {
								ϒtbr = λ.Call(ϒfloat_or_none, λ.NewArgs(func() λ.Object {
									if λv := λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("AVERAGE-BANDWIDTH")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("BANDWIDTH"))
									}
								}()), λ.KWArgs{
									{Name: "scale", Value: λ.IntLiteral(1000)},
								})
								ϒformat_id = λ.NewList()
								if λ.IsTrue(ϒm3u8_id) {
									λ.Calm(ϒformat_id, "append", ϒm3u8_id)
								}
								ϒstream_name = λ.Cal(ϒbuild_stream_name)
								if !λ.IsTrue(ϒlive) {
									λ.Calm(ϒformat_id, "append", func() λ.Object {
										if λ.IsTrue(ϒstream_name) {
											return ϒstream_name
										} else {
											return λ.Mod(λ.StrLiteral("%d"), func() λ.Object {
												if λ.IsTrue(ϒtbr) {
													return ϒtbr
												} else {
													return λ.Cal(λ.BuiltinLen, ϒformats)
												}
											}())
										}
									}())
								}
								ϒmanifest_url = λ.Cal(ϒformat_url, λ.Calm(ϒline, "strip"))
								ϒf = λ.DictLiteral(map[string]λ.Object{
									"format_id":    λ.Calm(λ.StrLiteral("-"), "join", ϒformat_id),
									"url":          ϒmanifest_url,
									"manifest_url": ϒm3u8_url,
									"tbr":          ϒtbr,
									"ext":          ϒext,
									"fps":          λ.Cal(ϒfloat_or_none, λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("FRAME-RATE"))),
									"protocol":     ϒentry_protocol,
									"preference":   ϒpreference,
								})
								ϒresolution = λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("RESOLUTION"))
								if λ.IsTrue(ϒresolution) {
									ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("(?P<width>\\d+)[xX](?P<height>\\d+)"), ϒresolution)
									if λ.IsTrue(ϒmobj) {
										λ.SetItem(ϒf, λ.StrLiteral("width"), λ.Cal(λ.IntType, λ.Calm(ϒmobj, "group", λ.StrLiteral("width"))))
										λ.SetItem(ϒf, λ.StrLiteral("height"), λ.Cal(λ.IntType, λ.Calm(ϒmobj, "group", λ.StrLiteral("height"))))
									}
								}
								ϒmobj = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("audio.*?(?:%3D|=)(\\d+)(?:-video.*?(?:%3D|=)(\\d+))?"), λ.GetItem(ϒf, λ.StrLiteral("url")))
								if λ.IsTrue(ϒmobj) {
									τmp2 = λ.Calm(ϒmobj, "groups")
									ϒabr = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒvbr = λ.GetItem(τmp2, λ.IntLiteral(1))
									τmp2 = λ.NewTuple(
										λ.Cal(ϒfloat_or_none, ϒabr, λ.IntLiteral(1000)),
										λ.Cal(ϒfloat_or_none, ϒvbr, λ.IntLiteral(1000)),
									)
									ϒabr = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒvbr = λ.GetItem(τmp2, λ.IntLiteral(1))
									λ.Calm(ϒf, "update", λ.DictLiteral(map[string]λ.Object{
										"vbr": ϒvbr,
										"abr": ϒabr,
									}))
								}
								ϒcodecs = λ.Cal(ϒparse_codecs, λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("CODECS")))
								λ.Calm(ϒf, "update", ϒcodecs)
								ϒaudio_group_id = λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("AUDIO"))
								if λ.IsTrue(func() λ.Object {
									if λv := ϒaudio_group_id; !λ.IsTrue(λv) {
										return λv
									} else if λv := ϒcodecs; !λ.IsTrue(λv) {
										return λv
									} else {
										return λ.Ne(λ.Calm(ϒf, "get", λ.StrLiteral("vcodec")), λ.StrLiteral("none"))
									}
								}()) {
									ϒaudio_group = λ.Calm(ϒgroups, "get", ϒaudio_group_id)
									if λ.IsTrue(func() λ.Object {
										if λv := ϒaudio_group; !λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(λ.GetItem(ϒaudio_group, λ.IntLiteral(0)), "get", λ.StrLiteral("URI"))
										}
									}()) {
										λ.SetItem(ϒf, λ.StrLiteral("acodec"), λ.StrLiteral("none"))
									}
								}
								λ.Calm(ϒformats, "append", ϒf)
								ϒprogressive_uri = λ.Calm(ϒlast_stream_inf, "get", λ.StrLiteral("PROGRESSIVE-URI"))
								if λ.IsTrue(ϒprogressive_uri) {
									ϒhttp_f = λ.Calm(ϒf, "copy")
									λ.DelItem(ϒhttp_f, λ.StrLiteral("manifest_url"))
									λ.Calm(ϒhttp_f, "update", λ.DictLiteral(map[string]λ.Object{
										"format_id": λ.Calm(λ.GetItem(ϒf, λ.StrLiteral("format_id")), "replace", λ.StrLiteral("hls-"), λ.StrLiteral("http-")),
										"protocol":  λ.StrLiteral("http"),
										"url":       ϒprogressive_uri,
									}))
									λ.Calm(ϒformats, "append", ϒhttp_f)
								}
								ϒlast_stream_inf = λ.DictLiteral(map[λ.Object]λ.Object{})
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__xpath_ns = λ.NewFunction("_xpath_ns",
				[]λ.Param{
					{Name: "path"},
					{Name: "namespace", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒc         λ.Object
						ϒnamespace = λargs[1]
						ϒout       λ.Object
						ϒpath      = λargs[0]
						τmp0       λ.Object
						τmp1       λ.Object
					)
					if !λ.IsTrue(ϒnamespace) {
						return ϒpath
					}
					ϒout = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒpath, "split", λ.StrLiteral("/")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒc = τmp1
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒc)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒc, λ.StrLiteral("."))
							}
						}()) {
							λ.Calm(ϒout, "append", ϒc)
						} else {
							λ.Calm(ϒout, "append", λ.Mod(λ.StrLiteral("{%s}%s"), λ.NewTuple(
								ϒnamespace,
								ϒc,
							)))
						}
					}
					return λ.Calm(λ.StrLiteral("/"), "join", ϒout)
				})
			InfoExtractor__xpath_ns = λ.Cal(λ.StaticMethodType, InfoExtractor__xpath_ns)
			InfoExtractor__extract_smil_formats = λ.NewFunction("_extract_smil_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "f4m_params", Def: λ.None},
					{Name: "transform_source", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒf4m_params       = λargs[4]
						ϒfatal            = λargs[3]
						ϒnamespace        λ.Object
						ϒself             = λargs[0]
						ϒsmil             λ.Object
						ϒsmil_url         = λargs[1]
						ϒtransform_source = λargs[5]
						ϒvideo_id         = λargs[2]
					)
					ϒsmil = λ.Call(λ.GetAttr(ϒself, "_download_smil", nil), λ.NewArgs(
						ϒsmil_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "transform_source", Value: ϒtransform_source},
					})
					if ϒsmil == λ.False {
						if !!λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(λ.AssertionErrorType)))
						}
						return λ.NewList()
					}
					ϒnamespace = λ.Calm(ϒself, "_parse_smil_namespace", ϒsmil)
					return λ.Call(λ.GetAttr(ϒself, "_parse_smil_formats", nil), λ.NewArgs(
						ϒsmil,
						ϒsmil_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "namespace", Value: ϒnamespace},
						{Name: "f4m_params", Value: ϒf4m_params},
					})
				})
			InfoExtractor__download_smil = λ.NewFunction("_download_smil",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "fatal", Def: λ.True},
					{Name: "transform_source", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal            = λargs[3]
						ϒself             = λargs[0]
						ϒsmil_url         = λargs[1]
						ϒtransform_source = λargs[4]
						ϒvideo_id         = λargs[2]
					)
					return λ.Call(λ.GetAttr(ϒself, "_download_xml", nil), λ.NewArgs(
						ϒsmil_url,
						ϒvideo_id,
						λ.StrLiteral("Downloading SMIL file"),
						λ.StrLiteral("Unable to download SMIL file"),
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "transform_source", Value: ϒtransform_source},
					})
				})
			InfoExtractor__parse_smil_namespace = λ.NewFunction("_parse_smil_namespace",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
						ϒsmil = λargs[1]
					)
					return λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?i)^{([^}]+)?}smil$"),
						λ.GetAttr(ϒsmil, "tag", nil),
						λ.StrLiteral("namespace"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
				})
			InfoExtractor__parse_smil_formats = λ.NewFunction("_parse_smil_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil"},
					{Name: "smil_url"},
					{Name: "video_id"},
					{Name: "namespace", Def: λ.None},
					{Name: "f4m_params", Def: λ.None},
					{Name: "transform_rtmp_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒb                  λ.Object
						ϒbase               λ.Object
						ϒbitrate            λ.Object
						ϒext                λ.Object
						ϒf4m_params         = λargs[5]
						ϒf4m_url            λ.Object
						ϒfilesize           λ.Object
						ϒformats            λ.Object
						ϒheight             λ.Object
						ϒhttp_count         λ.Object
						ϒm3u8_count         λ.Object
						ϒm3u8_formats       λ.Object
						ϒmedia              λ.Object
						ϒmedium             λ.Object
						ϒmeta               λ.Object
						ϒnamespace          = λargs[4]
						ϒproto              λ.Object
						ϒrtmp_count         λ.Object
						ϒself               = λargs[0]
						ϒsmil               = λargs[1]
						ϒsmil_url           = λargs[2]
						ϒsrc                λ.Object
						ϒsrc_ext            λ.Object
						ϒsrc_url            λ.Object
						ϒsrcs               λ.Object
						ϒstreamer           λ.Object
						ϒtransform_rtmp_url = λargs[6]
						ϒvideo_id           = λargs[3]
						ϒwidth              λ.Object
						τmp0                λ.Object
						τmp1                λ.Object
						τmp2                λ.Object
					)
					ϒbase = ϒsmil_url
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒsmil, "findall", λ.Calm(ϒself, "_xpath_ns", λ.StrLiteral("./head/meta"), ϒnamespace)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmeta = τmp1
						ϒb = func() λ.Object {
							if λv := λ.Calm(ϒmeta, "get", λ.StrLiteral("base")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒmeta, "get", λ.StrLiteral("httpBase"))
							}
						}()
						if λ.IsTrue(ϒb) {
							ϒbase = ϒb
							break
						}
					}
					ϒformats = λ.NewList()
					ϒrtmp_count = λ.IntLiteral(0)
					ϒhttp_count = λ.IntLiteral(0)
					ϒm3u8_count = λ.IntLiteral(0)
					ϒsrcs = λ.NewList()
					ϒmedia = λ.Add(λ.Calm(ϒsmil, "findall", λ.Calm(ϒself, "_xpath_ns", λ.StrLiteral(".//video"), ϒnamespace)), λ.Calm(ϒsmil, "findall", λ.Calm(ϒself, "_xpath_ns", λ.StrLiteral(".//audio"), ϒnamespace)))
					τmp0 = λ.Cal(λ.BuiltinIter, ϒmedia)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒmedium = τmp1
						ϒsrc = λ.Calm(ϒmedium, "get", λ.StrLiteral("src"))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒsrc)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒsrcs, ϒsrc))
							}
						}()) {
							continue
						}
						λ.Calm(ϒsrcs, "append", ϒsrc)
						ϒbitrate = λ.Cal(ϒfloat_or_none, func() λ.Object {
							if λv := λ.Calm(ϒmedium, "get", λ.StrLiteral("system-bitrate")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒmedium, "get", λ.StrLiteral("systemBitrate"))
							}
						}(), λ.IntLiteral(1000))
						ϒfilesize = λ.Cal(ϒint_or_none, func() λ.Object {
							if λv := λ.Calm(ϒmedium, "get", λ.StrLiteral("size")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒmedium, "get", λ.StrLiteral("fileSize"))
							}
						}())
						ϒwidth = λ.Cal(ϒint_or_none, λ.Calm(ϒmedium, "get", λ.StrLiteral("width")))
						ϒheight = λ.Cal(ϒint_or_none, λ.Calm(ϒmedium, "get", λ.StrLiteral("height")))
						ϒproto = λ.Calm(ϒmedium, "get", λ.StrLiteral("proto"))
						ϒext = λ.Calm(ϒmedium, "get", λ.StrLiteral("ext"))
						ϒsrc_ext = λ.Cal(ϒdetermine_ext, ϒsrc)
						ϒstreamer = func() λ.Object {
							if λv := λ.Calm(ϒmedium, "get", λ.StrLiteral("streamer")); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒbase
							}
						}()
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒproto, λ.StrLiteral("rtmp")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(ϒstreamer, "startswith", λ.StrLiteral("rtmp"))
							}
						}()) {
							τmp2 = λ.IAdd(ϒrtmp_count, λ.IntLiteral(1))
							ϒrtmp_count = τmp2
							λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
								"url":       ϒstreamer,
								"play_path": ϒsrc,
								"ext":       λ.StrLiteral("flv"),
								"format_id": λ.Mod(λ.StrLiteral("rtmp-%d"), func() λ.Object {
									if ϒbitrate == λ.None {
										return ϒrtmp_count
									} else {
										return ϒbitrate
									}
								}()),
								"tbr":      ϒbitrate,
								"filesize": ϒfilesize,
								"width":    ϒwidth,
								"height":   ϒheight,
							}))
							if λ.IsTrue(ϒtransform_rtmp_url) {
								τmp2 = λ.Cal(ϒtransform_rtmp_url, ϒstreamer, ϒsrc)
								ϒstreamer = λ.GetItem(τmp2, λ.IntLiteral(0))
								ϒsrc = λ.GetItem(τmp2, λ.IntLiteral(1))
								λ.Calm(λ.GetItem(ϒformats, λ.Neg(λ.IntLiteral(1))), "update", λ.DictLiteral(map[string]λ.Object{
									"url":       ϒstreamer,
									"play_path": ϒsrc,
								}))
							}
							continue
						}
						ϒsrc_url = func() λ.Object {
							if λ.IsTrue(λ.Calm(ϒsrc, "startswith", λ.StrLiteral("http"))) {
								return ϒsrc
							} else {
								return λ.Cal(Ωparse.ϒurljoin, ϒbase, ϒsrc)
							}
						}()
						ϒsrc_url = λ.Calm(ϒsrc_url, "strip")
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒproto, λ.StrLiteral("m3u8")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒsrc_ext, λ.StrLiteral("m3u8"))
							}
						}()) {
							ϒm3u8_formats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
								ϒsrc_url,
								ϒvideo_id,
								func() λ.Object {
									if λv := ϒext; λ.IsTrue(λv) {
										return λv
									} else {
										return λ.StrLiteral("mp4")
									}
								}(),
							), λ.KWArgs{
								{Name: "m3u8_id", Value: λ.StrLiteral("hls")},
								{Name: "fatal", Value: λ.False},
							})
							if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒm3u8_formats), λ.IntLiteral(1))) {
								τmp2 = λ.IAdd(ϒm3u8_count, λ.IntLiteral(1))
								ϒm3u8_count = τmp2
								λ.Calm(λ.GetItem(ϒm3u8_formats, λ.IntLiteral(0)), "update", λ.DictLiteral(map[string]λ.Object{
									"format_id": λ.Mod(λ.StrLiteral("hls-%d"), func() λ.Object {
										if ϒbitrate == λ.None {
											return ϒm3u8_count
										} else {
											return ϒbitrate
										}
									}()),
									"tbr":    ϒbitrate,
									"width":  ϒwidth,
									"height": ϒheight,
								}))
							}
							λ.Calm(ϒformats, "extend", ϒm3u8_formats)
						} else {
							if λ.IsTrue(λ.Eq(ϒsrc_ext, λ.StrLiteral("f4m"))) {
								ϒf4m_url = ϒsrc_url
								if !λ.IsTrue(ϒf4m_params) {
									ϒf4m_params = λ.DictLiteral(map[string]string{
										"hdcore": "3.2.0",
										"plugin": "flowplayer-3.2.0.1",
									})
								}
								τmp2 = λ.IAdd(ϒf4m_url, func() λ.Object {
									if λ.Contains(ϒf4m_url, λ.StrLiteral("?")) {
										return λ.StrLiteral("&")
									} else {
										return λ.StrLiteral("?")
									}
								}())
								ϒf4m_url = τmp2
								τmp2 = λ.IAdd(ϒf4m_url, λ.Cal(ϒcompat_urllib_parse_urlencode, ϒf4m_params))
								ϒf4m_url = τmp2
								λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
									ϒf4m_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "f4m_id", Value: λ.StrLiteral("hds")},
									{Name: "fatal", Value: λ.False},
								}))
							} else {
								if λ.IsTrue(λ.Eq(ϒsrc_ext, λ.StrLiteral("mpd"))) {
									λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
										ϒsrc_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "mpd_id", Value: λ.StrLiteral("dash")},
										{Name: "fatal", Value: λ.False},
									}))
								} else {
									if λ.IsTrue(λ.Cal(Ωre.ϒsearch, λ.StrLiteral("\\.ism/[Mm]anifest"), ϒsrc_url)) {
										λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_ism_formats", nil), λ.NewArgs(
											ϒsrc_url,
											ϒvideo_id,
										), λ.KWArgs{
											{Name: "ism_id", Value: λ.StrLiteral("mss")},
											{Name: "fatal", Value: λ.False},
										}))
									} else {
										if λ.IsTrue(func() λ.Object {
											if λv := λ.Calm(ϒsrc_url, "startswith", λ.StrLiteral("http")); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Calm(ϒself, "_is_valid_url", ϒsrc, ϒvideo_id)
											}
										}()) {
											τmp2 = λ.IAdd(ϒhttp_count, λ.IntLiteral(1))
											ϒhttp_count = τmp2
											λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
												"url": ϒsrc_url,
												"ext": func() λ.Object {
													if λv := ϒext; λ.IsTrue(λv) {
														return λv
													} else if λv := ϒsrc_ext; λ.IsTrue(λv) {
														return λv
													} else {
														return λ.StrLiteral("flv")
													}
												}(),
												"format_id": λ.Mod(λ.StrLiteral("http-%d"), func() λ.Object {
													if λv := ϒbitrate; λ.IsTrue(λv) {
														return λv
													} else {
														return ϒhttp_count
													}
												}()),
												"tbr":      ϒbitrate,
												"filesize": ϒfilesize,
												"width":    ϒwidth,
												"height":   ϒheight,
											}))
										}
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__parse_smil_subtitles = λ.NewFunction("_parse_smil_subtitles",
				[]λ.Param{
					{Name: "self"},
					{Name: "smil"},
					{Name: "namespace", Def: λ.None},
					{Name: "subtitles_lang", Def: λ.StrLiteral("en")},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒext            λ.Object
						ϒlang           λ.Object
						ϒnamespace      = λargs[2]
						ϒnum            λ.Object
						ϒself           = λargs[0]
						ϒsmil           = λargs[1]
						ϒsrc            λ.Object
						ϒsubtitles      λ.Object
						ϒsubtitles_lang = λargs[3]
						ϒtextstream     λ.Object
						ϒurls           λ.Object
						τmp0            λ.Object
						τmp1            λ.Object
						τmp2            λ.Object
					)
					_ = ϒnum
					ϒurls = λ.NewList()
					ϒsubtitles = λ.DictLiteral(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, λ.Calm(ϒsmil, "findall", λ.Calm(ϒself, "_xpath_ns", λ.StrLiteral(".//textstream"), ϒnamespace))))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒnum = λ.GetItem(τmp2, λ.IntLiteral(0))
						ϒtextstream = λ.GetItem(τmp2, λ.IntLiteral(1))
						ϒsrc = λ.Calm(ϒtextstream, "get", λ.StrLiteral("src"))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒsrc)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒurls, ϒsrc))
							}
						}()) {
							continue
						}
						λ.Calm(ϒurls, "append", ϒsrc)
						ϒext = func() λ.Object {
							if λv := λ.Calm(ϒtextstream, "get", λ.StrLiteral("ext")); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Cal(ϒmimetype2ext, λ.Calm(ϒtextstream, "get", λ.StrLiteral("type"))); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(ϒdetermine_ext, ϒsrc)
							}
						}()
						ϒlang = func() λ.Object {
							if λv := λ.Calm(ϒtextstream, "get", λ.StrLiteral("systemLanguage")); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Calm(ϒtextstream, "get", λ.StrLiteral("systemLanguageName")); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Calm(ϒtextstream, "get", λ.StrLiteral("lang")); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒsubtitles_lang
							}
						}()
						λ.Calm(λ.Calm(ϒsubtitles, "setdefault", ϒlang, λ.NewList()), "append", λ.DictLiteral(map[string]λ.Object{
							"url": ϒsrc,
							"ext": ϒext,
						}))
					}
					return ϒsubtitles
				})
			InfoExtractor__extract_mpd_formats = λ.NewFunction("_extract_mpd_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "mpd_url"},
					{Name: "video_id"},
					{Name: "mpd_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "formats_dict", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata         = λargs[8]
						ϒerrnote      = λargs[5]
						ϒfatal        = λargs[6]
						ϒformats_dict = λargs[7]
						ϒheaders      = λargs[9]
						ϒmpd_base_url λ.Object
						ϒmpd_doc      λ.Object
						ϒmpd_id       = λargs[3]
						ϒmpd_url      = λargs[1]
						ϒnote         = λargs[4]
						ϒquery        = λargs[10]
						ϒres          λ.Object
						ϒself         = λargs[0]
						ϒurlh         λ.Object
						ϒvideo_id     = λargs[2]
						τmp0          λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒmpd_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Downloading MPD manifest")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Failed to download MPD manifest")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
					})
					if ϒres == λ.False {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒmpd_doc = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					if ϒmpd_doc == λ.None {
						return λ.NewList()
					}
					ϒmpd_base_url = λ.Cal(ϒbase_url, λ.Calm(ϒurlh, "geturl"))
					return λ.Call(λ.GetAttr(ϒself, "_parse_mpd_formats", nil), λ.NewArgs(ϒmpd_doc), λ.KWArgs{
						{Name: "mpd_id", Value: ϒmpd_id},
						{Name: "mpd_base_url", Value: ϒmpd_base_url},
						{Name: "formats_dict", Value: ϒformats_dict},
						{Name: "mpd_url", Value: ϒmpd_url},
					})
				})
			InfoExtractor__parse_mpd_formats = λ.NewFunction("_parse_mpd_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "mpd_doc"},
					{Name: "mpd_id", Def: λ.None},
					{Name: "mpd_base_url", Def: λ.StrLiteral("")},
					{Name: "formats_dict", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "mpd_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_add_ns                   λ.Object
						ϒadaptation_set            λ.Object
						ϒadaption_set_ms_info      λ.Object
						ϒadd_segment_url           λ.Object
						ϒbandwidth                 λ.Object
						ϒbase_url                  λ.Object
						ϒbase_url_e                λ.Object
						ϒcontent_type              λ.Object
						ϒduration                  λ.Object
						ϒelement                   λ.Object
						ϒextract_multisegment_info λ.Object
						ϒf                         λ.Object
						ϒfilesize                  λ.Object
						ϒformats                   λ.Object
						ϒformats_dict              = λargs[4]
						ϒfragment                  λ.Object
						ϒfragments                 λ.Object
						ϒfull_info                 λ.Object
						ϒinitialization_template   λ.Object
						ϒinitialization_url        λ.Object
						ϒis_drm_protected          λ.Object
						ϒlang                      λ.Object
						ϒlocation_key              λ.Object
						ϒmedia_location_key        λ.Object
						ϒmedia_template            λ.Object
						ϒmime_type                 λ.Object
						ϒmpd_base_url              = λargs[3]
						ϒmpd_doc                   = λargs[1]
						ϒmpd_duration              λ.Object
						ϒmpd_id                    = λargs[2]
						ϒmpd_url                   = λargs[5]
						ϒnamespace                 λ.Object
						ϒnum                       λ.Object
						ϒperiod                    λ.Object
						ϒperiod_duration           λ.Object
						ϒperiod_ms_info            λ.Object
						ϒprepare_template          λ.Object
						ϒr                         λ.Object
						ϒrepresentation            λ.Object
						ϒrepresentation_attrib     λ.Object
						ϒrepresentation_id         λ.Object
						ϒrepresentation_ms_info    λ.Object
						ϒs                         λ.Object
						ϒsegment_d                 λ.Object
						ϒsegment_duration          λ.Object
						ϒsegment_index             λ.Object
						ϒsegment_number            λ.Object
						ϒsegment_time              λ.Object
						ϒsegment_uri               λ.Object
						ϒsegment_url               λ.Object
						ϒself                      = λargs[0]
						ϒtimescale                 λ.Object
						ϒurl_el                    λ.Object
						τmp0                       λ.Object
						τmp1                       λ.Object
						τmp10                      λ.Object
						τmp2                       λ.Object
						τmp3                       λ.Object
						τmp4                       λ.Object
						τmp5                       λ.Object
						τmp6                       λ.Object
						τmp7                       λ.Object
						τmp8                       λ.Object
						τmp9                       λ.Object
					)
					_ = ϒnum
					_ = ϒr
					if λ.IsTrue(λ.Eq(λ.Calm(ϒmpd_doc, "get", λ.StrLiteral("type")), λ.StrLiteral("dynamic"))) {
						return λ.NewList()
					}
					ϒnamespace = λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?i)^{([^}]+)?}MPD$"),
						λ.GetAttr(ϒmpd_doc, "tag", nil),
						λ.StrLiteral("namespace"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					})
					ϒ_add_ns = λ.NewFunction("_add_ns",
						[]λ.Param{
							{Name: "path"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒpath = λargs[0]
							)
							return λ.Calm(ϒself, "_xpath_ns", ϒpath, ϒnamespace)
						})
					ϒis_drm_protected = λ.NewFunction("is_drm_protected",
						[]λ.Param{
							{Name: "element"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒelement = λargs[0]
							)
							return λ.NewBool(λ.Calm(ϒelement, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("ContentProtection"))) != λ.None)
						})
					ϒextract_multisegment_info = λ.NewFunction("extract_multisegment_info",
						[]λ.Param{
							{Name: "element"},
							{Name: "ms_parent_info"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒelement                = λargs[0]
								ϒextract_Initialization λ.Object
								ϒextract_common         λ.Object
								ϒinitialization         λ.Object
								ϒmedia                  λ.Object
								ϒms_info                λ.Object
								ϒms_parent_info         = λargs[1]
								ϒsegment_list           λ.Object
								ϒsegment_template       λ.Object
								ϒsegment_urls_e         λ.Object
							)
							ϒms_info = λ.Calm(ϒms_parent_info, "copy")
							ϒextract_common = λ.NewFunction("extract_common",
								[]λ.Param{
									{Name: "source"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒr                λ.Object
										ϒs                λ.Object
										ϒs_e              λ.Object
										ϒsegment_duration λ.Object
										ϒsegment_timeline λ.Object
										ϒsource           = λargs[0]
										ϒstart_number     λ.Object
										ϒtimescale        λ.Object
										τmp0              λ.Object
										τmp1              λ.Object
										τmp2              λ.Object
									)
									ϒsegment_timeline = λ.Calm(ϒsource, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("SegmentTimeline")))
									if ϒsegment_timeline != λ.None {
										ϒs_e = λ.Calm(ϒsegment_timeline, "findall", λ.Cal(ϒ_add_ns, λ.StrLiteral("S")))
										if λ.IsTrue(ϒs_e) {
											λ.SetItem(ϒms_info, λ.StrLiteral("total_number"), λ.IntLiteral(0))
											λ.SetItem(ϒms_info, λ.StrLiteral("s"), λ.NewList())
											τmp0 = λ.Cal(λ.BuiltinIter, ϒs_e)
											for {
												if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
													break
												}
												ϒs = τmp1
												ϒr = λ.Cal(λ.IntType, λ.Calm(ϒs, "get", λ.StrLiteral("r"), λ.IntLiteral(0)))
												τmp2 = λ.IAdd(λ.GetItem(ϒms_info, λ.StrLiteral("total_number")), λ.Add(λ.IntLiteral(1), ϒr))
												λ.SetItem(ϒms_info, λ.StrLiteral("total_number"), τmp2)
												λ.Calm(λ.GetItem(ϒms_info, λ.StrLiteral("s")), "append", λ.DictLiteral(map[string]λ.Object{
													"t": λ.Cal(λ.IntType, λ.Calm(ϒs, "get", λ.StrLiteral("t"), λ.IntLiteral(0))),
													"d": λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒs, "attrib", nil), λ.StrLiteral("d"))),
													"r": ϒr,
												}))
											}
										}
									}
									ϒstart_number = λ.Calm(ϒsource, "get", λ.StrLiteral("startNumber"))
									if λ.IsTrue(ϒstart_number) {
										λ.SetItem(ϒms_info, λ.StrLiteral("start_number"), λ.Cal(λ.IntType, ϒstart_number))
									}
									ϒtimescale = λ.Calm(ϒsource, "get", λ.StrLiteral("timescale"))
									if λ.IsTrue(ϒtimescale) {
										λ.SetItem(ϒms_info, λ.StrLiteral("timescale"), λ.Cal(λ.IntType, ϒtimescale))
									}
									ϒsegment_duration = λ.Calm(ϒsource, "get", λ.StrLiteral("duration"))
									if λ.IsTrue(ϒsegment_duration) {
										λ.SetItem(ϒms_info, λ.StrLiteral("segment_duration"), λ.Cal(λ.FloatType, ϒsegment_duration))
									}
									return λ.None
								})
							ϒextract_Initialization = λ.NewFunction("extract_Initialization",
								[]λ.Param{
									{Name: "source"},
								},
								0, false, false,
								func(λargs []λ.Object) λ.Object {
									var (
										ϒinitialization λ.Object
										ϒsource         = λargs[0]
									)
									ϒinitialization = λ.Calm(ϒsource, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("Initialization")))
									if ϒinitialization != λ.None {
										λ.SetItem(ϒms_info, λ.StrLiteral("initialization_url"), λ.GetItem(λ.GetAttr(ϒinitialization, "attrib", nil), λ.StrLiteral("sourceURL")))
									}
									return λ.None
								})
							ϒsegment_list = λ.Calm(ϒelement, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("SegmentList")))
							if ϒsegment_list != λ.None {
								λ.Cal(ϒextract_common, ϒsegment_list)
								λ.Cal(ϒextract_Initialization, ϒsegment_list)
								ϒsegment_urls_e = λ.Calm(ϒsegment_list, "findall", λ.Cal(ϒ_add_ns, λ.StrLiteral("SegmentURL")))
								if λ.IsTrue(ϒsegment_urls_e) {
									λ.SetItem(ϒms_info, λ.StrLiteral("segment_urls"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
										nil,
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
												var (
													ϒsegment λ.Object
													τmp0     λ.Object
													τmp1     λ.Object
												)
												τmp0 = λ.Cal(λ.BuiltinIter, ϒsegment_urls_e)
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒsegment = τmp1
													λgy.Yield(λ.GetItem(λ.GetAttr(ϒsegment, "attrib", nil), λ.StrLiteral("media")))
												}
												return λ.None
											})
										}))))
								}
							} else {
								ϒsegment_template = λ.Calm(ϒelement, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("SegmentTemplate")))
								if ϒsegment_template != λ.None {
									λ.Cal(ϒextract_common, ϒsegment_template)
									ϒmedia = λ.Calm(ϒsegment_template, "get", λ.StrLiteral("media"))
									if λ.IsTrue(ϒmedia) {
										λ.SetItem(ϒms_info, λ.StrLiteral("media"), ϒmedia)
									}
									ϒinitialization = λ.Calm(ϒsegment_template, "get", λ.StrLiteral("initialization"))
									if λ.IsTrue(ϒinitialization) {
										λ.SetItem(ϒms_info, λ.StrLiteral("initialization"), ϒinitialization)
									} else {
										λ.Cal(ϒextract_Initialization, ϒsegment_template)
									}
								}
							}
							return ϒms_info
						})
					ϒmpd_duration = λ.Cal(ϒparse_duration, λ.Calm(ϒmpd_doc, "get", λ.StrLiteral("mediaPresentationDuration")))
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒmpd_doc, "findall", λ.Cal(ϒ_add_ns, λ.StrLiteral("Period"))))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒperiod = τmp1
						ϒperiod_duration = func() λ.Object {
							if λv := λ.Cal(ϒparse_duration, λ.Calm(ϒperiod, "get", λ.StrLiteral("duration"))); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒmpd_duration
							}
						}()
						ϒperiod_ms_info = λ.Cal(ϒextract_multisegment_info, ϒperiod, λ.DictLiteral(map[string]int{
							"start_number": 1,
							"timescale":    1,
						}))
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒperiod, "findall", λ.Cal(ϒ_add_ns, λ.StrLiteral("AdaptationSet"))))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒadaptation_set = τmp3
							if λ.IsTrue(λ.Cal(ϒis_drm_protected, ϒadaptation_set)) {
								continue
							}
							ϒadaption_set_ms_info = λ.Cal(ϒextract_multisegment_info, ϒadaptation_set, ϒperiod_ms_info)
							τmp4 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒadaptation_set, "findall", λ.Cal(ϒ_add_ns, λ.StrLiteral("Representation"))))
							for {
								if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
									break
								}
								ϒrepresentation = τmp5
								if λ.IsTrue(λ.Cal(ϒis_drm_protected, ϒrepresentation)) {
									continue
								}
								ϒrepresentation_attrib = λ.Calm(λ.GetAttr(ϒadaptation_set, "attrib", nil), "copy")
								λ.Calm(ϒrepresentation_attrib, "update", λ.GetAttr(ϒrepresentation, "attrib", nil))
								ϒmime_type = λ.GetItem(ϒrepresentation_attrib, λ.StrLiteral("mimeType"))
								ϒcontent_type = λ.GetItem(λ.Calm(ϒmime_type, "split", λ.StrLiteral("/")), λ.IntLiteral(0))
								if λ.IsTrue(λ.Eq(ϒcontent_type, λ.StrLiteral("text"))) {
									// pass
								} else {
									if λ.Contains(λ.NewTuple(
										λ.StrLiteral("video"),
										λ.StrLiteral("audio"),
									), ϒcontent_type) {
										ϒbase_url = λ.StrLiteral("")
										τmp6 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
											ϒrepresentation,
											ϒadaptation_set,
											ϒperiod,
											ϒmpd_doc,
										))
										for {
											if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
												break
											}
											ϒelement = τmp7
											ϒbase_url_e = λ.Calm(ϒelement, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("BaseURL")))
											if ϒbase_url_e != λ.None {
												ϒbase_url = λ.Add(λ.GetAttr(ϒbase_url_e, "text", nil), ϒbase_url)
												if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("^https?://"), ϒbase_url)) {
													break
												}
											}
										}
										if λ.IsTrue(func() λ.Object {
											if λv := ϒmpd_base_url; !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(!λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("^https?://"), ϒbase_url)))
											}
										}()) {
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(!λ.IsTrue(λ.Calm(ϒmpd_base_url, "endswith", λ.StrLiteral("/")))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(!λ.IsTrue(λ.Calm(ϒbase_url, "startswith", λ.StrLiteral("/"))))
												}
											}()) {
												τmp6 = λ.IAdd(ϒmpd_base_url, λ.StrLiteral("/"))
												ϒmpd_base_url = τmp6
											}
											ϒbase_url = λ.Add(ϒmpd_base_url, ϒbase_url)
										}
										ϒrepresentation_id = λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("id"))
										ϒlang = λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("lang"))
										ϒurl_el = λ.Calm(ϒrepresentation, "find", λ.Cal(ϒ_add_ns, λ.StrLiteral("BaseURL")))
										ϒfilesize = λ.Cal(ϒint_or_none, func() λ.Object {
											if ϒurl_el != λ.None {
												return λ.Calm(λ.GetAttr(ϒurl_el, "attrib", nil), "get", λ.StrLiteral("{http://youtube.com/yt/2012/10/10}contentLength"))
											} else {
												return λ.None
											}
										}())
										ϒbandwidth = λ.Cal(ϒint_or_none, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("bandwidth")))
										ϒf = λ.DictLiteral(map[string]λ.Object{
											"format_id": func() λ.Object {
												if λ.IsTrue(ϒmpd_id) {
													return λ.Mod(λ.StrLiteral("%s-%s"), λ.NewTuple(
														ϒmpd_id,
														ϒrepresentation_id,
													))
												} else {
													return ϒrepresentation_id
												}
											}(),
											"manifest_url": ϒmpd_url,
											"ext":          λ.Cal(ϒmimetype2ext, ϒmime_type),
											"width":        λ.Cal(ϒint_or_none, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("width"))),
											"height":       λ.Cal(ϒint_or_none, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("height"))),
											"tbr":          λ.Cal(ϒfloat_or_none, ϒbandwidth, λ.IntLiteral(1000)),
											"asr":          λ.Cal(ϒint_or_none, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("audioSamplingRate"))),
											"fps":          λ.Cal(ϒint_or_none, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("frameRate"))),
											"language": func() λ.Object {
												if !λ.Contains(λ.NewTuple(
													λ.StrLiteral("mul"),
													λ.StrLiteral("und"),
													λ.StrLiteral("zxx"),
													λ.StrLiteral("mis"),
												), ϒlang) {
													return ϒlang
												} else {
													return λ.None
												}
											}(),
											"format_note": λ.Mod(λ.StrLiteral("DASH %s"), ϒcontent_type),
											"filesize":    ϒfilesize,
											"container":   λ.Add(λ.Cal(ϒmimetype2ext, ϒmime_type), λ.StrLiteral("_dash")),
										})
										λ.Calm(ϒf, "update", λ.Cal(ϒparse_codecs, λ.Calm(ϒrepresentation_attrib, "get", λ.StrLiteral("codecs"))))
										ϒrepresentation_ms_info = λ.Cal(ϒextract_multisegment_info, ϒrepresentation, ϒadaption_set_ms_info)
										ϒprepare_template = λ.NewFunction("prepare_template",
											[]λ.Param{
												{Name: "template_name"},
												{Name: "identifiers"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒc             λ.Object
													ϒidentifiers   = λargs[1]
													ϒin_template   λ.Object
													ϒt             λ.Object
													ϒtemplate_name = λargs[0]
													ϒtmpl          λ.Object
													τmp0           λ.Object
													τmp1           λ.Object
													τmp2           λ.Object
												)
												ϒtmpl = λ.GetItem(ϒrepresentation_ms_info, ϒtemplate_name)
												ϒt = λ.StrLiteral("")
												ϒin_template = λ.False
												τmp0 = λ.Cal(λ.BuiltinIter, ϒtmpl)
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒc = τmp1
													τmp2 = λ.IAdd(ϒt, ϒc)
													ϒt = τmp2
													if λ.IsTrue(λ.Eq(ϒc, λ.StrLiteral("$"))) {
														ϒin_template = λ.NewBool(!λ.IsTrue(ϒin_template))
													} else {
														if λ.IsTrue(func() λ.Object {
															if λv := λ.Eq(ϒc, λ.StrLiteral("%")); !λ.IsTrue(λv) {
																return λv
															} else {
																return λ.NewBool(!λ.IsTrue(ϒin_template))
															}
														}()) {
															τmp2 = λ.IAdd(ϒt, ϒc)
															ϒt = τmp2
														}
													}
												}
												ϒt = λ.Calm(ϒt, "replace", λ.StrLiteral("$RepresentationID$"), ϒrepresentation_id)
												ϒt = λ.Cal(Ωre.ϒsub, λ.Mod(λ.StrLiteral("\\$(%s)\\$"), λ.Calm(λ.StrLiteral("|"), "join", ϒidentifiers)), λ.StrLiteral("%(\\1)d"), ϒt)
												ϒt = λ.Cal(Ωre.ϒsub, λ.Mod(λ.StrLiteral("\\$(%s)%%([^$]+)\\$"), λ.Calm(λ.StrLiteral("|"), "join", ϒidentifiers)), λ.StrLiteral("%(\\1)\\2"), ϒt)
												λ.Calm(ϒt, "replace", λ.StrLiteral("$$"), λ.StrLiteral("$"))
												return ϒt
											})
										if λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("initialization")) {
											ϒinitialization_template = λ.Cal(ϒprepare_template, λ.StrLiteral("initialization"), λ.NewTuple(λ.StrLiteral("Bandwidth")))
											λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("initialization_url"), λ.Mod(ϒinitialization_template, λ.DictLiteral(map[string]λ.Object{
												"Bandwidth": ϒbandwidth,
											})))
										}
										ϒlocation_key = λ.NewFunction("location_key",
											[]λ.Param{
												{Name: "location"},
											},
											0, false, false,
											func(λargs []λ.Object) λ.Object {
												var (
													ϒlocation = λargs[0]
												)
												return func() λ.Object {
													if λ.IsTrue(λ.Cal(Ωre.ϒmatch, λ.StrLiteral("^https?://"), ϒlocation)) {
														return λ.StrLiteral("url")
													} else {
														return λ.StrLiteral("path")
													}
												}()
											})
										if λ.IsTrue(func() λ.Object {
											if λv := λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("segment_urls"))); !λ.IsTrue(λv) {
												return λv
											} else {
												return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("media")))
											}
										}()) {
											ϒmedia_template = λ.Cal(ϒprepare_template, λ.StrLiteral("media"), λ.NewTuple(
												λ.StrLiteral("Number"),
												λ.StrLiteral("Bandwidth"),
												λ.StrLiteral("Time"),
											))
											ϒmedia_location_key = λ.Cal(ϒlocation_key, ϒmedia_template)
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(λ.Contains(ϒmedia_template, λ.StrLiteral("%(Number"))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("s")))
												}
											}()) {
												ϒsegment_duration = λ.None
												if λ.IsTrue(func() λ.Object {
													if λv := λ.NewBool(!λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("total_number"))); !λ.IsTrue(λv) {
														return λv
													} else {
														return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("segment_duration")))
													}
												}()) {
													ϒsegment_duration = λ.Cal(ϒfloat_or_none, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("segment_duration")), λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("timescale")))
													λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("total_number"), λ.Cal(λ.IntType, λ.Cal(Ωmath.ϒceil, λ.TrueDiv(λ.Cal(λ.FloatType, ϒperiod_duration), ϒsegment_duration))))
												}
												λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments"), λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
													nil,
													0, false, false,
													func(λargs []λ.Object) λ.Object {
														return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
															var (
																ϒsegment_number λ.Object
																τmp0            λ.Object
																τmp1            λ.Object
															)
															τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("start_number")), λ.Add(λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("total_number")), λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("start_number")))))
															for {
																if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
																	break
																}
																ϒsegment_number = τmp1
																λgy.Yield(λ.DictLiteral(map[λ.Object]λ.Object{
																	ϒmedia_location_key: λ.Mod(ϒmedia_template, λ.DictLiteral(map[string]λ.Object{
																		"Number":    ϒsegment_number,
																		"Bandwidth": ϒbandwidth,
																	})),
																	λ.StrLiteral("duration"): ϒsegment_duration,
																}))
															}
															return λ.None
														})
													}))))
											} else {
												λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments"), λ.NewList())
												ϒsegment_time = λ.IntLiteral(0)
												ϒsegment_d = λ.None
												ϒsegment_number = λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("start_number"))
												ϒadd_segment_url = λ.NewFunction("add_segment_url",
													nil,
													0, false, false,
													func(λargs []λ.Object) λ.Object {
														var (
															ϒsegment_url λ.Object
														)
														ϒsegment_url = λ.Mod(ϒmedia_template, λ.DictLiteral(map[string]λ.Object{
															"Time":      ϒsegment_time,
															"Bandwidth": ϒbandwidth,
															"Number":    ϒsegment_number,
														}))
														λ.Calm(λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments")), "append", λ.DictLiteral(map[λ.Object]λ.Object{
															ϒmedia_location_key:      ϒsegment_url,
															λ.StrLiteral("duration"): λ.Cal(ϒfloat_or_none, ϒsegment_d, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("timescale"))),
														}))
														return λ.None
													})
												τmp6 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("s"))))
												for {
													if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
														break
													}
													τmp8 = τmp7
													ϒnum = λ.GetItem(τmp8, λ.IntLiteral(0))
													ϒs = λ.GetItem(τmp8, λ.IntLiteral(1))
													ϒsegment_time = func() λ.Object {
														if λv := λ.Calm(ϒs, "get", λ.StrLiteral("t")); λ.IsTrue(λv) {
															return λv
														} else {
															return ϒsegment_time
														}
													}()
													ϒsegment_d = λ.GetItem(ϒs, λ.StrLiteral("d"))
													λ.Cal(ϒadd_segment_url)
													τmp8 = λ.IAdd(ϒsegment_number, λ.IntLiteral(1))
													ϒsegment_number = τmp8
													τmp8 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.Calm(ϒs, "get", λ.StrLiteral("r"), λ.IntLiteral(0))))
													for {
														if τmp9 = λ.NextDefault(τmp8, λ.AfterLast); τmp9 == λ.AfterLast {
															break
														}
														ϒr = τmp9
														τmp10 = λ.IAdd(ϒsegment_time, ϒsegment_d)
														ϒsegment_time = τmp10
														λ.Cal(ϒadd_segment_url)
														τmp10 = λ.IAdd(ϒsegment_number, λ.IntLiteral(1))
														ϒsegment_number = τmp10
													}
													τmp8 = λ.IAdd(ϒsegment_time, ϒsegment_d)
													ϒsegment_time = τmp8
												}
											}
										} else {
											if λ.IsTrue(func() λ.Object {
												if λv := λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("segment_urls"))); !λ.IsTrue(λv) {
													return λv
												} else {
													return λ.NewBool(λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("s")))
												}
											}()) {
												ϒfragments = λ.NewList()
												ϒsegment_index = λ.IntLiteral(0)
												ϒtimescale = λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("timescale"))
												τmp6 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("s")))
												for {
													if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
														break
													}
													ϒs = τmp7
													ϒduration = λ.Cal(ϒfloat_or_none, λ.GetItem(ϒs, λ.StrLiteral("d")), ϒtimescale)
													τmp8 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, λ.Add(λ.Calm(ϒs, "get", λ.StrLiteral("r"), λ.IntLiteral(0)), λ.IntLiteral(1))))
													for {
														if τmp9 = λ.NextDefault(τmp8, λ.AfterLast); τmp9 == λ.AfterLast {
															break
														}
														ϒr = τmp9
														ϒsegment_uri = λ.GetItem(λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("segment_urls")), ϒsegment_index)
														λ.Calm(ϒfragments, "append", λ.DictLiteral(map[λ.Object]λ.Object{
															λ.Cal(ϒlocation_key, ϒsegment_uri): ϒsegment_uri,
															λ.StrLiteral("duration"):           ϒduration,
														}))
														τmp10 = λ.IAdd(ϒsegment_index, λ.IntLiteral(1))
														ϒsegment_index = τmp10
													}
												}
												λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments"), ϒfragments)
											} else {
												if λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("segment_urls")) {
													ϒfragments = λ.NewList()
													ϒsegment_duration = func() λ.Object {
														if λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("segment_duration")) {
															return λ.Cal(ϒfloat_or_none, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("segment_duration")), λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("timescale")))
														} else {
															return λ.None
														}
													}()
													τmp6 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("segment_urls")))
													for {
														if τmp7 = λ.NextDefault(τmp6, λ.AfterLast); τmp7 == λ.AfterLast {
															break
														}
														ϒsegment_url = τmp7
														ϒfragment = λ.DictLiteral(map[λ.Object]λ.Object{
															λ.Cal(ϒlocation_key, ϒsegment_url): ϒsegment_url,
														})
														if λ.IsTrue(ϒsegment_duration) {
															λ.SetItem(ϒfragment, λ.StrLiteral("duration"), ϒsegment_duration)
														}
														λ.Calm(ϒfragments, "append", ϒfragment)
													}
													λ.SetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments"), ϒfragments)
												}
											}
										}
										if λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("fragments")) {
											λ.Calm(ϒf, "update", λ.DictLiteral(map[string]λ.Object{
												"url": func() λ.Object {
													if λv := ϒmpd_url; λ.IsTrue(λv) {
														return λv
													} else {
														return ϒbase_url
													}
												}(),
												"fragment_base_url": ϒbase_url,
												"fragments":         λ.NewList(),
												"protocol":          λ.StrLiteral("http_dash_segments"),
											}))
											if λ.Contains(ϒrepresentation_ms_info, λ.StrLiteral("initialization_url")) {
												ϒinitialization_url = λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("initialization_url"))
												if !λ.IsTrue(λ.Calm(ϒf, "get", λ.StrLiteral("url"))) {
													λ.SetItem(ϒf, λ.StrLiteral("url"), ϒinitialization_url)
												}
												λ.Calm(λ.GetItem(ϒf, λ.StrLiteral("fragments")), "append", λ.DictLiteral(map[λ.Object]λ.Object{
													λ.Cal(ϒlocation_key, ϒinitialization_url): ϒinitialization_url,
												}))
											}
											λ.Calm(λ.GetItem(ϒf, λ.StrLiteral("fragments")), "extend", λ.GetItem(ϒrepresentation_ms_info, λ.StrLiteral("fragments")))
										} else {
											λ.SetItem(ϒf, λ.StrLiteral("url"), ϒbase_url)
										}
										ϒfull_info = λ.Calm(λ.Calm(ϒformats_dict, "get", ϒrepresentation_id, λ.DictLiteral(map[λ.Object]λ.Object{})), "copy")
										λ.Calm(ϒfull_info, "update", ϒf)
										λ.Calm(ϒformats, "append", ϒfull_info)
									} else {
										λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("Unknown MIME type %s in DASH manifest"), ϒmime_type))
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__extract_ism_formats = λ.NewFunction("_extract_ism_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "ism_url"},
					{Name: "video_id"},
					{Name: "ism_id", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "errnote", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "data", Def: λ.None},
					{Name: "headers", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
					{Name: "query", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒdata     = λargs[7]
						ϒerrnote  = λargs[5]
						ϒfatal    = λargs[6]
						ϒheaders  = λargs[8]
						ϒism_doc  λ.Object
						ϒism_id   = λargs[3]
						ϒism_url  = λargs[1]
						ϒnote     = λargs[4]
						ϒquery    = λargs[9]
						ϒres      λ.Object
						ϒself     = λargs[0]
						ϒurlh     λ.Object
						ϒvideo_id = λargs[2]
						τmp0      λ.Object
					)
					ϒres = λ.Call(λ.GetAttr(ϒself, "_download_xml_handle", nil), λ.NewArgs(
						ϒism_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "note", Value: func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Downloading ISM manifest")
							}
						}()},
						{Name: "errnote", Value: func() λ.Object {
							if λv := ϒerrnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("Failed to download ISM manifest")
							}
						}()},
						{Name: "fatal", Value: ϒfatal},
						{Name: "data", Value: ϒdata},
						{Name: "headers", Value: ϒheaders},
						{Name: "query", Value: ϒquery},
					})
					if ϒres == λ.False {
						return λ.NewList()
					}
					τmp0 = ϒres
					ϒism_doc = λ.GetItem(τmp0, λ.IntLiteral(0))
					ϒurlh = λ.GetItem(τmp0, λ.IntLiteral(1))
					if ϒism_doc == λ.None {
						return λ.NewList()
					}
					return λ.Calm(ϒself, "_parse_ism_formats", ϒism_doc, λ.Calm(ϒurlh, "geturl"), ϒism_id)
				})
			InfoExtractor__parse_ism_formats = λ.NewFunction("_parse_ism_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "ism_doc"},
					{Name: "ism_url"},
					{Name: "ism_id", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒduration              λ.Object
						ϒformat_id             λ.Object
						ϒformats               λ.Object
						ϒfourcc                λ.Object
						ϒfragment_ctx          λ.Object
						ϒfragment_repeat       λ.Object
						ϒfragments             λ.Object
						ϒheight                λ.Object
						ϒism_doc               = λargs[1]
						ϒism_id                = λargs[3]
						ϒism_url               = λargs[2]
						ϒnext_fragment_time    λ.Object
						ϒsampling_rate         λ.Object
						ϒself                  = λargs[0]
						ϒstream                λ.Object
						ϒstream_fragment       λ.Object
						ϒstream_fragment_index λ.Object
						ϒstream_fragments      λ.Object
						ϒstream_name           λ.Object
						ϒstream_timescale      λ.Object
						ϒstream_type           λ.Object
						ϒtbr                   λ.Object
						ϒtimescale             λ.Object
						ϒtrack                 λ.Object
						ϒtrack_url_pattern     λ.Object
						ϒurl_pattern           λ.Object
						ϒwidth                 λ.Object
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
						τmp3                   λ.Object
						τmp4                   λ.Object
						τmp5                   λ.Object
						τmp6                   λ.Object
						τmp7                   λ.Object
						τmp8                   λ.Object
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Eq(λ.Calm(ϒism_doc, "get", λ.StrLiteral("IsLive")), λ.StrLiteral("TRUE")); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(λ.Calm(ϒism_doc, "find", λ.StrLiteral("Protection")) != λ.None)
						}
					}()) {
						return λ.NewList()
					}
					ϒduration = λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒism_doc, "attrib", nil), λ.StrLiteral("Duration")))
					ϒtimescale = func() λ.Object {
						if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒism_doc, "get", λ.StrLiteral("TimeScale"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.IntLiteral(10000000)
						}
					}()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒism_doc, "findall", λ.StrLiteral("StreamIndex")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒstream = τmp1
						ϒstream_type = λ.Calm(ϒstream, "get", λ.StrLiteral("Type"))
						if !λ.Contains(λ.NewTuple(
							λ.StrLiteral("video"),
							λ.StrLiteral("audio"),
						), ϒstream_type) {
							continue
						}
						ϒurl_pattern = λ.GetItem(λ.GetAttr(ϒstream, "attrib", nil), λ.StrLiteral("Url"))
						ϒstream_timescale = func() λ.Object {
							if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒstream, "get", λ.StrLiteral("TimeScale"))); λ.IsTrue(λv) {
								return λv
							} else {
								return ϒtimescale
							}
						}()
						ϒstream_name = λ.Calm(ϒstream, "get", λ.StrLiteral("Name"))
						τmp2 = λ.Cal(λ.BuiltinIter, λ.Calm(ϒstream, "findall", λ.StrLiteral("QualityLevel")))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒtrack = τmp3
							ϒfourcc = λ.Calm(ϒtrack, "get", λ.StrLiteral("FourCC"), func() λ.Object {
								if λ.IsTrue(λ.Eq(λ.Calm(ϒtrack, "get", λ.StrLiteral("AudioTag")), λ.StrLiteral("255"))) {
									return λ.StrLiteral("AACL")
								} else {
									return λ.None
								}
							}())
							if !λ.Contains(λ.NewTuple(
								λ.StrLiteral("H264"),
								λ.StrLiteral("AVC1"),
								λ.StrLiteral("AACL"),
							), ϒfourcc) {
								λ.Calm(ϒself, "report_warning", λ.Mod(λ.StrLiteral("%s is not a supported codec"), ϒfourcc))
								continue
							}
							ϒtbr = λ.FloorDiv(λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(ϒtrack, "attrib", nil), λ.StrLiteral("Bitrate"))), λ.IntLiteral(1000))
							ϒwidth = λ.Cal(ϒint_or_none, func() λ.Object {
								if λv := λ.Calm(ϒtrack, "get", λ.StrLiteral("MaxWidth")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒtrack, "get", λ.StrLiteral("Width"))
								}
							}())
							ϒheight = λ.Cal(ϒint_or_none, func() λ.Object {
								if λv := λ.Calm(ϒtrack, "get", λ.StrLiteral("MaxHeight")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒtrack, "get", λ.StrLiteral("Height"))
								}
							}())
							ϒsampling_rate = λ.Cal(ϒint_or_none, λ.Calm(ϒtrack, "get", λ.StrLiteral("SamplingRate")))
							ϒtrack_url_pattern = λ.Cal(Ωre.ϒsub, λ.StrLiteral("{[Bb]itrate}"), λ.GetItem(λ.GetAttr(ϒtrack, "attrib", nil), λ.StrLiteral("Bitrate")), ϒurl_pattern)
							ϒtrack_url_pattern = λ.Cal(Ωparse.ϒurljoin, ϒism_url, ϒtrack_url_pattern)
							ϒfragments = λ.NewList()
							ϒfragment_ctx = λ.DictLiteral(map[string]int{
								"time": 0,
							})
							ϒstream_fragments = λ.Calm(ϒstream, "findall", λ.StrLiteral("c"))
							τmp4 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.EnumerateIteratorType, ϒstream_fragments))
							for {
								if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
									break
								}
								τmp6 = τmp5
								ϒstream_fragment_index = λ.GetItem(τmp6, λ.IntLiteral(0))
								ϒstream_fragment = λ.GetItem(τmp6, λ.IntLiteral(1))
								λ.SetItem(ϒfragment_ctx, λ.StrLiteral("time"), func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒstream_fragment, "get", λ.StrLiteral("t"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.GetItem(ϒfragment_ctx, λ.StrLiteral("time"))
									}
								}())
								ϒfragment_repeat = func() λ.Object {
									if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒstream_fragment, "get", λ.StrLiteral("r"))); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.IntLiteral(1)
									}
								}()
								λ.SetItem(ϒfragment_ctx, λ.StrLiteral("duration"), λ.Cal(ϒint_or_none, λ.Calm(ϒstream_fragment, "get", λ.StrLiteral("d"))))
								if !λ.IsTrue(λ.GetItem(ϒfragment_ctx, λ.StrLiteral("duration"))) {
									τmp6, τmp7 = func() (λexit λ.Object, λret λ.Object) {
										defer λ.CatchMulti(
											nil,
											&λ.Catcher{λ.IndexErrorType, func(λex λ.BaseException) {
												ϒnext_fragment_time = ϒduration
											}},
										)
										ϒnext_fragment_time = λ.Cal(λ.IntType, λ.GetItem(λ.GetAttr(λ.GetItem(ϒstream_fragment, λ.Add(ϒstream_fragment_index, λ.IntLiteral(1))), "attrib", nil), λ.StrLiteral("t")))
										return λ.BlockExitNormally, nil
									}()
									λ.SetItem(ϒfragment_ctx, λ.StrLiteral("duration"), λ.TrueDiv(λ.Sub(ϒnext_fragment_time, λ.GetItem(ϒfragment_ctx, λ.StrLiteral("time"))), ϒfragment_repeat))
								}
								τmp7 = λ.Cal(λ.BuiltinIter, λ.Cal(λ.RangeType, ϒfragment_repeat))
								for {
									if τmp6 = λ.NextDefault(τmp7, λ.AfterLast); τmp6 == λ.AfterLast {
										break
									}
									_ = τmp6
									λ.Calm(ϒfragments, "append", λ.DictLiteral(map[string]λ.Object{
										"url":      λ.Cal(Ωre.ϒsub, λ.StrLiteral("{start[ _]time}"), λ.Cal(ϒcompat_str, λ.GetItem(ϒfragment_ctx, λ.StrLiteral("time"))), ϒtrack_url_pattern),
										"duration": λ.TrueDiv(λ.GetItem(ϒfragment_ctx, λ.StrLiteral("duration")), ϒstream_timescale),
									}))
									τmp8 = λ.IAdd(λ.GetItem(ϒfragment_ctx, λ.StrLiteral("time")), λ.GetItem(ϒfragment_ctx, λ.StrLiteral("duration")))
									λ.SetItem(ϒfragment_ctx, λ.StrLiteral("time"), τmp8)
								}
							}
							ϒformat_id = λ.NewList()
							if λ.IsTrue(ϒism_id) {
								λ.Calm(ϒformat_id, "append", ϒism_id)
							}
							if λ.IsTrue(ϒstream_name) {
								λ.Calm(ϒformat_id, "append", ϒstream_name)
							}
							λ.Calm(ϒformat_id, "append", λ.Cal(ϒcompat_str, ϒtbr))
							λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
								"format_id":    λ.Calm(λ.StrLiteral("-"), "join", ϒformat_id),
								"url":          ϒism_url,
								"manifest_url": ϒism_url,
								"ext": func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.StrLiteral("video"))) {
										return λ.StrLiteral("ismv")
									} else {
										return λ.StrLiteral("isma")
									}
								}(),
								"width":  ϒwidth,
								"height": ϒheight,
								"tbr":    ϒtbr,
								"asr":    ϒsampling_rate,
								"vcodec": func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.StrLiteral("audio"))) {
										return λ.StrLiteral("none")
									} else {
										return ϒfourcc
									}
								}(),
								"acodec": func() λ.Object {
									if λ.IsTrue(λ.Eq(ϒstream_type, λ.StrLiteral("video"))) {
										return λ.StrLiteral("none")
									} else {
										return ϒfourcc
									}
								}(),
								"protocol":  λ.StrLiteral("ism"),
								"fragments": ϒfragments,
								"_download_params": λ.DictLiteral(map[string]λ.Object{
									"duration":  ϒduration,
									"timescale": ϒstream_timescale,
									"width": func() λ.Object {
										if λv := ϒwidth; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.IntLiteral(0)
										}
									}(),
									"height": func() λ.Object {
										if λv := ϒheight; λ.IsTrue(λv) {
											return λv
										} else {
											return λ.IntLiteral(0)
										}
									}(),
									"fourcc":                ϒfourcc,
									"codec_private_data":    λ.Calm(ϒtrack, "get", λ.StrLiteral("CodecPrivateData")),
									"sampling_rate":         ϒsampling_rate,
									"channels":              λ.Cal(ϒint_or_none, λ.Calm(ϒtrack, "get", λ.StrLiteral("Channels"), λ.IntLiteral(2))),
									"bits_per_sample":       λ.Cal(ϒint_or_none, λ.Calm(ϒtrack, "get", λ.StrLiteral("BitsPerSample"), λ.IntLiteral(16))),
									"nal_unit_length_field": λ.Cal(ϒint_or_none, λ.Calm(ϒtrack, "get", λ.StrLiteral("NALUnitLengthField"), λ.IntLiteral(4))),
								}),
							}))
						}
					}
					return ϒformats
				})
			InfoExtractor__parse_html5_media_entries = λ.NewFunction("_parse_html5_media_entries",
				[]λ.Param{
					{Name: "self"},
					{Name: "base_url"},
					{Name: "webpage"},
					{Name: "video_id"},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "m3u8_entry_protocol", Def: λ.StrLiteral("m3u8")},
					{Name: "mpd_id", Def: λ.None},
					{Name: "preference", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒ_MEDIA_TAG_NAME_RE  λ.Object
						ϒ_media_formats      λ.Object
						ϒabsolute_url        λ.Object
						ϒbase_url            = λargs[1]
						ϒentries             λ.Object
						ϒf                   λ.Object
						ϒformats             λ.Object
						ϒheight              λ.Object
						ϒis_plain_url        λ.Object
						ϒkind                λ.Object
						ϒlabels              λ.Object
						ϒlang                λ.Object
						ϒlbl                 λ.Object
						ϒm3u8_entry_protocol = λargs[5]
						ϒm3u8_id             = λargs[4]
						ϒmedia_attributes    λ.Object
						ϒmedia_content       λ.Object
						ϒmedia_info          λ.Object
						ϒmedia_tag           λ.Object
						ϒmedia_tags          λ.Object
						ϒmedia_type          λ.Object
						ϒmpd_id              = λargs[6]
						ϒparse_content_type  λ.Object
						ϒpreference          = λargs[7]
						ϒresolution          λ.Object
						ϒs_attr              λ.Object
						ϒself                = λargs[0]
						ϒsource_tag          λ.Object
						ϒsrc                 λ.Object
						ϒtbr                 λ.Object
						ϒtrack_attributes    λ.Object
						ϒtrack_tag           λ.Object
						ϒvideo_id            = λargs[3]
						ϒwebpage             = λargs[2]
						ϒwidth               λ.Object
						τmp0                 λ.Object
						τmp1                 λ.Object
						τmp2                 λ.Object
						τmp3                 λ.Object
						τmp4                 λ.Object
						τmp5                 λ.Object
					)
					ϒabsolute_url = λ.NewFunction("absolute_url",
						[]λ.Param{
							{Name: "item_url"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒitem_url = λargs[0]
							)
							return λ.Cal(ϒurljoin, ϒbase_url, ϒitem_url)
						})
					ϒparse_content_type = λ.NewFunction("parse_content_type",
						[]λ.Param{
							{Name: "content_type"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcodecs       λ.Object
								ϒcontent_type = λargs[0]
								ϒctr          λ.Object
								ϒf            λ.Object
								ϒmimetype     λ.Object
								τmp0          λ.Object
							)
							if !λ.IsTrue(ϒcontent_type) {
								return λ.DictLiteral(map[λ.Object]λ.Object{})
							}
							ϒctr = λ.Cal(Ωre.ϒsearch, λ.StrLiteral("(?P<mimetype>[^/]+/[^;]+)(?:;\\s*codecs=\"?(?P<codecs>[^\"]+))?"), ϒcontent_type)
							if λ.IsTrue(ϒctr) {
								τmp0 = λ.Calm(ϒctr, "groups")
								ϒmimetype = λ.GetItem(τmp0, λ.IntLiteral(0))
								ϒcodecs = λ.GetItem(τmp0, λ.IntLiteral(1))
								ϒf = λ.Cal(ϒparse_codecs, ϒcodecs)
								λ.SetItem(ϒf, λ.StrLiteral("ext"), λ.Cal(ϒmimetype2ext, ϒmimetype))
								return ϒf
							}
							return λ.DictLiteral(map[λ.Object]λ.Object{})
						})
					ϒ_media_formats = λ.NewFunction("_media_formats",
						[]λ.Param{
							{Name: "src"},
							{Name: "cur_media_type"},
							{Name: "type_info", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒcur_media_type = λargs[1]
								ϒext            λ.Object
								ϒformats        λ.Object
								ϒfull_url       λ.Object
								ϒis_plain_url   λ.Object
								ϒsrc            = λargs[0]
								ϒtype_info      = λargs[2]
							)
							ϒfull_url = λ.Cal(ϒabsolute_url, ϒsrc)
							ϒext = func() λ.Object {
								if λv := λ.Calm(ϒtype_info, "get", λ.StrLiteral("ext")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Cal(ϒdetermine_ext, ϒfull_url)
								}
							}()
							if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("m3u8"))) {
								ϒis_plain_url = λ.False
								ϒformats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
									ϒfull_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "ext", Value: λ.StrLiteral("mp4")},
									{Name: "entry_protocol", Value: ϒm3u8_entry_protocol},
									{Name: "m3u8_id", Value: ϒm3u8_id},
									{Name: "preference", Value: ϒpreference},
									{Name: "fatal", Value: λ.False},
								})
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("mpd"))) {
									ϒis_plain_url = λ.False
									ϒformats = λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
										ϒfull_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "mpd_id", Value: ϒmpd_id},
										{Name: "fatal", Value: λ.False},
									})
								} else {
									ϒis_plain_url = λ.True
									ϒformats = λ.NewList(λ.DictLiteral(map[string]λ.Object{
										"url": ϒfull_url,
										"vcodec": func() λ.Object {
											if λ.IsTrue(λ.Eq(ϒcur_media_type, λ.StrLiteral("audio"))) {
												return λ.StrLiteral("none")
											} else {
												return λ.None
											}
										}(),
									}))
								}
							}
							return λ.NewTuple(
								ϒis_plain_url,
								ϒformats,
							)
						})
					ϒentries = λ.NewList()
					ϒ_MEDIA_TAG_NAME_RE = λ.StrLiteral("(?:(?:amp|dl8(?:-live)?)-)?(video|audio)")
					ϒmedia_tags = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒmedia_tag      λ.Object
									ϒmedia_tag_name λ.Object
									ϒmedia_type     λ.Object
									τmp0            λ.Object
									τmp1            λ.Object
									τmp2            λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.Mod(λ.StrLiteral("(?s)(<(%s)[^>]*/>)"), ϒ_MEDIA_TAG_NAME_RE), ϒwebpage))
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									τmp2 = τmp1
									ϒmedia_tag = λ.GetItem(τmp2, λ.IntLiteral(0))
									ϒmedia_tag_name = λ.GetItem(τmp2, λ.IntLiteral(1))
									ϒmedia_type = λ.GetItem(τmp2, λ.IntLiteral(2))
									λgy.Yield(λ.NewTuple(
										ϒmedia_tag,
										ϒmedia_tag_name,
										ϒmedia_type,
										λ.StrLiteral(""),
									))
								}
								return λ.None
							})
						})))
					λ.Calm(ϒmedia_tags, "extend", λ.Cal(Ωre.ϒfindall, λ.Mod(λ.StrLiteral("(?s)(<(?P<tag>%s)(?:\\s+[^>]*)?>)(.*?)</(?P=tag)>"), ϒ_MEDIA_TAG_NAME_RE), ϒwebpage))
					τmp0 = λ.Cal(λ.BuiltinIter, ϒmedia_tags)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						τmp2 = τmp1
						ϒmedia_tag = λ.GetItem(τmp2, λ.IntLiteral(0))
						_ = λ.GetItem(τmp2, λ.IntLiteral(1))
						ϒmedia_type = λ.GetItem(τmp2, λ.IntLiteral(2))
						ϒmedia_content = λ.GetItem(τmp2, λ.IntLiteral(3))
						ϒmedia_info = λ.DictLiteral(map[string]λ.Object{
							"formats":   λ.NewList(),
							"subtitles": λ.DictLiteral(map[λ.Object]λ.Object{}),
						})
						ϒmedia_attributes = λ.Cal(ϒextract_attributes, ϒmedia_tag)
						ϒsrc = λ.Cal(ϒstrip_or_none, λ.Calm(ϒmedia_attributes, "get", λ.StrLiteral("src")))
						if λ.IsTrue(ϒsrc) {
							τmp2 = λ.Cal(ϒ_media_formats, ϒsrc, ϒmedia_type)
							_ = λ.GetItem(τmp2, λ.IntLiteral(0))
							ϒformats = λ.GetItem(τmp2, λ.IntLiteral(1))
							λ.Calm(λ.GetItem(ϒmedia_info, λ.StrLiteral("formats")), "extend", ϒformats)
						}
						λ.SetItem(ϒmedia_info, λ.StrLiteral("thumbnail"), λ.Cal(ϒabsolute_url, λ.Calm(ϒmedia_attributes, "get", λ.StrLiteral("poster"))))
						if λ.IsTrue(ϒmedia_content) {
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.StrLiteral("<source[^>]+>"), ϒmedia_content))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒsource_tag = τmp3
								ϒs_attr = λ.Cal(ϒextract_attributes, ϒsource_tag)
								ϒsrc = λ.Cal(ϒstrip_or_none, λ.Cal(ϒdict_get, ϒs_attr, λ.NewTuple(
									λ.StrLiteral("src"),
									λ.StrLiteral("data-video-src"),
									λ.StrLiteral("data-src"),
								)))
								if !λ.IsTrue(ϒsrc) {
									continue
								}
								ϒf = λ.Cal(ϒparse_content_type, λ.Calm(ϒs_attr, "get", λ.StrLiteral("type")))
								τmp4 = λ.Cal(ϒ_media_formats, ϒsrc, ϒmedia_type, ϒf)
								ϒis_plain_url = λ.GetItem(τmp4, λ.IntLiteral(0))
								ϒformats = λ.GetItem(τmp4, λ.IntLiteral(1))
								if λ.IsTrue(ϒis_plain_url) {
									ϒlabels = λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
										nil,
										0, false, false,
										func(λargs []λ.Object) λ.Object {
											return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
												var (
													ϒlbl λ.Object
													τmp0 λ.Object
													τmp1 λ.Object
												)
												τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
													λ.StrLiteral("label"),
													λ.StrLiteral("title"),
												))
												for {
													if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
														break
													}
													ϒlbl = τmp1
													if λ.IsTrue(λ.Cal(ϒstr_or_none, λ.Calm(ϒs_attr, "get", ϒlbl))) {
														λgy.Yield(λ.Calm(ϒs_attr, "get", ϒlbl))
													}
												}
												return λ.None
											})
										})))
									ϒwidth = λ.Cal(ϒint_or_none, λ.Calm(ϒs_attr, "get", λ.StrLiteral("width")))
									ϒheight = func() λ.Object {
										if λv := λ.Cal(ϒint_or_none, λ.Calm(ϒs_attr, "get", λ.StrLiteral("height"))); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Cal(ϒint_or_none, λ.Calm(ϒs_attr, "get", λ.StrLiteral("res")))
										}
									}()
									if λ.IsTrue(func() λ.Object {
										if λv := λ.NewBool(!λ.IsTrue(ϒwidth)); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(!λ.IsTrue(ϒheight))
										}
									}()) {
										τmp4 = λ.Cal(λ.BuiltinIter, ϒlabels)
										for {
											if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
												break
											}
											ϒlbl = τmp5
											ϒresolution = λ.Cal(ϒparse_resolution, ϒlbl)
											if !λ.IsTrue(ϒresolution) {
												continue
											}
											ϒwidth = func() λ.Object {
												if λv := ϒwidth; λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Calm(ϒresolution, "get", λ.StrLiteral("width"))
												}
											}()
											ϒheight = func() λ.Object {
												if λv := ϒheight; λ.IsTrue(λv) {
													return λv
												} else {
													return λ.Calm(ϒresolution, "get", λ.StrLiteral("height"))
												}
											}()
										}
									}
									τmp4 = λ.Cal(λ.BuiltinIter, ϒlabels)
									for {
										if τmp5 = λ.NextDefault(τmp4, λ.AfterLast); τmp5 == λ.AfterLast {
											break
										}
										ϒlbl = τmp5
										ϒtbr = λ.Cal(ϒparse_bitrate, ϒlbl)
										if λ.IsTrue(ϒtbr) {
											break
										}
									}
									if τmp5 == λ.AfterLast {
										ϒtbr = λ.None
									}
									λ.Calm(ϒf, "update", λ.DictLiteral(map[string]λ.Object{
										"width":  ϒwidth,
										"height": ϒheight,
										"tbr":    ϒtbr,
										"format_id": func() λ.Object {
											if λv := λ.Calm(ϒs_attr, "get", λ.StrLiteral("label")); λ.IsTrue(λv) {
												return λv
											} else {
												return λ.Calm(ϒs_attr, "get", λ.StrLiteral("title"))
											}
										}(),
									}))
									λ.Calm(ϒf, "update", λ.GetItem(ϒformats, λ.IntLiteral(0)))
									λ.Calm(λ.GetItem(ϒmedia_info, λ.StrLiteral("formats")), "append", ϒf)
								} else {
									λ.Calm(λ.GetItem(ϒmedia_info, λ.StrLiteral("formats")), "extend", ϒformats)
								}
							}
							τmp2 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.ϒfindall, λ.StrLiteral("<track[^>]+>"), ϒmedia_content))
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒtrack_tag = τmp3
								ϒtrack_attributes = λ.Cal(ϒextract_attributes, ϒtrack_tag)
								ϒkind = λ.Calm(ϒtrack_attributes, "get", λ.StrLiteral("kind"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(ϒkind)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(λ.Contains(λ.NewTuple(
											λ.StrLiteral("subtitles"),
											λ.StrLiteral("captions"),
										), ϒkind))
									}
								}()) {
									ϒsrc = λ.Cal(ϒstrip_or_none, λ.Calm(ϒtrack_attributes, "get", λ.StrLiteral("src")))
									if !λ.IsTrue(ϒsrc) {
										continue
									}
									ϒlang = func() λ.Object {
										if λv := λ.Calm(ϒtrack_attributes, "get", λ.StrLiteral("srclang")); λ.IsTrue(λv) {
											return λv
										} else if λv := λ.Calm(ϒtrack_attributes, "get", λ.StrLiteral("lang")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.Calm(ϒtrack_attributes, "get", λ.StrLiteral("label"))
										}
									}()
									λ.Calm(λ.Calm(λ.GetItem(ϒmedia_info, λ.StrLiteral("subtitles")), "setdefault", ϒlang, λ.NewList()), "append", λ.DictLiteral(map[string]λ.Object{
										"url": λ.Cal(ϒabsolute_url, ϒsrc),
									}))
								}
							}
						}
						τmp2 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒmedia_info, λ.StrLiteral("formats")))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒf = τmp3
							λ.SetItem(λ.Calm(ϒf, "setdefault", λ.StrLiteral("http_headers"), λ.DictLiteral(map[λ.Object]λ.Object{})), λ.StrLiteral("Referer"), ϒbase_url)
						}
						if λ.IsTrue(func() λ.Object {
							if λv := λ.GetItem(ϒmedia_info, λ.StrLiteral("formats")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(ϒmedia_info, λ.StrLiteral("subtitles"))
							}
						}()) {
							λ.Calm(ϒentries, "append", ϒmedia_info)
						}
					}
					return ϒentries
				})
			InfoExtractor__extract_akamai_formats = λ.NewFunction("_extract_akamai_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "manifest_url"},
					{Name: "video_id"},
					{Name: "hosts", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						REPL_REGEX        λ.Object
						ϒentry            λ.Object
						ϒf                λ.Object
						ϒf4m_formats      λ.Object
						ϒf4m_url          λ.Object
						ϒformats          λ.Object
						ϒhdcore_sign      λ.Object
						ϒhds_host         λ.Object
						ϒhls_host         λ.Object
						ϒhosts            = λargs[3]
						ϒhttp_f           λ.Object
						ϒhttp_host        λ.Object
						ϒhttp_url         λ.Object
						ϒi                λ.Object
						ϒm3u8_formats     λ.Object
						ϒm3u8_url         λ.Object
						ϒmanifest_url     = λargs[1]
						ϒprotocol         λ.Object
						ϒqualities        λ.Object
						ϒqualities_length λ.Object
						ϒself             = λargs[0]
						ϒvideo_id         = λargs[2]
						τmp0              λ.Object
						τmp1              λ.Object
						τmp2              λ.Object
						τmp3              λ.Object
					)
					ϒformats = λ.NewList()
					ϒhdcore_sign = λ.StrLiteral("hdcore=3.7.0")
					ϒf4m_url = λ.Calm(λ.Cal(Ωre.ϒsub, λ.StrLiteral("(https?://[^/]+)/i/"), λ.StrLiteral("\\1/z/"), ϒmanifest_url), "replace", λ.StrLiteral("/master.m3u8"), λ.StrLiteral("/manifest.f4m"))
					ϒhds_host = λ.Calm(ϒhosts, "get", λ.StrLiteral("hds"))
					if λ.IsTrue(ϒhds_host) {
						ϒf4m_url = λ.Cal(Ωre.ϒsub, λ.StrLiteral("(https?://)[^/]+"), λ.Add(λ.StrLiteral("\\1"), ϒhds_host), ϒf4m_url)
					}
					if !λ.Contains(ϒf4m_url, λ.StrLiteral("hdcore=")) {
						τmp0 = λ.IAdd(ϒf4m_url, λ.Add(func() λ.Object {
							if λ.Contains(ϒf4m_url, λ.StrLiteral("?")) {
								return λ.StrLiteral("&")
							} else {
								return λ.StrLiteral("?")
							}
						}(), ϒhdcore_sign))
						ϒf4m_url = τmp0
					}
					ϒf4m_formats = λ.Call(λ.GetAttr(ϒself, "_extract_f4m_formats", nil), λ.NewArgs(
						ϒf4m_url,
						ϒvideo_id,
					), λ.KWArgs{
						{Name: "f4m_id", Value: λ.StrLiteral("hds")},
						{Name: "fatal", Value: λ.False},
					})
					τmp0 = λ.Cal(λ.BuiltinIter, ϒf4m_formats)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒentry = τmp1
						λ.Calm(ϒentry, "update", λ.DictLiteral(map[string]λ.Object{
							"extra_param_to_segment_url": ϒhdcore_sign,
						}))
					}
					λ.Calm(ϒformats, "extend", ϒf4m_formats)
					ϒm3u8_url = λ.Calm(λ.Cal(Ωre.ϒsub, λ.StrLiteral("(https?://[^/]+)/z/"), λ.StrLiteral("\\1/i/"), ϒmanifest_url), "replace", λ.StrLiteral("/manifest.f4m"), λ.StrLiteral("/master.m3u8"))
					ϒhls_host = λ.Calm(ϒhosts, "get", λ.StrLiteral("hls"))
					if λ.IsTrue(ϒhls_host) {
						ϒm3u8_url = λ.Cal(Ωre.ϒsub, λ.StrLiteral("(https?://)[^/]+"), λ.Add(λ.StrLiteral("\\1"), ϒhls_host), ϒm3u8_url)
					}
					ϒm3u8_formats = λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
						ϒm3u8_url,
						ϒvideo_id,
						λ.StrLiteral("mp4"),
						λ.StrLiteral("m3u8_native"),
					), λ.KWArgs{
						{Name: "m3u8_id", Value: λ.StrLiteral("hls")},
						{Name: "fatal", Value: λ.False},
					})
					λ.Calm(ϒformats, "extend", ϒm3u8_formats)
					ϒhttp_host = λ.Calm(ϒhosts, "get", λ.StrLiteral("http"))
					if λ.IsTrue(func() λ.Object {
						if λv := ϒhttp_host; !λ.IsTrue(λv) {
							return λv
						} else if λv := ϒm3u8_formats; !λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewBool(!λ.Contains(ϒm3u8_url, λ.StrLiteral("hdnea=")))
						}
					}()) {
						REPL_REGEX = λ.StrLiteral("https?://[^/]+/i/([^,]+),([^/]+),([^/]+)\\.csmil/.+")
						ϒqualities = λ.Calm(λ.Calm(λ.Cal(Ωre.ϒmatch, REPL_REGEX, ϒm3u8_url), "group", λ.IntLiteral(2)), "split", λ.StrLiteral(","))
						ϒqualities_length = λ.Cal(λ.BuiltinLen, ϒqualities)
						if λ.Contains(λ.NewTuple(
							ϒqualities_length,
							λ.Add(ϒqualities_length, λ.IntLiteral(1)),
						), λ.Cal(λ.BuiltinLen, ϒm3u8_formats)) {
							ϒi = λ.IntLiteral(0)
							τmp0 = λ.Cal(λ.BuiltinIter, ϒm3u8_formats)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒf = τmp1
								if λ.IsTrue(λ.Ne(λ.GetItem(ϒf, λ.StrLiteral("vcodec")), λ.StrLiteral("none"))) {
									τmp2 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
										λ.StrLiteral("http"),
										λ.StrLiteral("https"),
									))
									for {
										if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
											break
										}
										ϒprotocol = τmp3
										ϒhttp_f = λ.Calm(ϒf, "copy")
										λ.DelItem(ϒhttp_f, λ.StrLiteral("manifest_url"))
										ϒhttp_url = λ.Cal(Ωre.ϒsub, REPL_REGEX, λ.Add(ϒprotocol, λ.Mod(λ.StrLiteral("://%s/\\g<1>%s\\3"), λ.NewTuple(
											ϒhttp_host,
											λ.GetItem(ϒqualities, ϒi),
										))), λ.GetItem(ϒf, λ.StrLiteral("url")))
										λ.Calm(ϒhttp_f, "update", λ.DictLiteral(map[string]λ.Object{
											"format_id": λ.Calm(λ.GetItem(ϒhttp_f, λ.StrLiteral("format_id")), "replace", λ.StrLiteral("hls-"), λ.Add(ϒprotocol, λ.StrLiteral("-"))),
											"url":       ϒhttp_url,
											"protocol":  ϒprotocol,
										}))
										λ.Calm(ϒformats, "append", ϒhttp_f)
									}
									τmp2 = λ.IAdd(ϒi, λ.IntLiteral(1))
									ϒi = τmp2
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__parse_jwplayer_data = λ.NewFunction("_parse_jwplayer_data",
				[]λ.Param{
					{Name: "self"},
					{Name: "jwplayer_data"},
					{Name: "video_id", Def: λ.None},
					{Name: "require_title", Def: λ.True},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "mpd_id", Def: λ.None},
					{Name: "rtmp_params", Def: λ.None},
					{Name: "base_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒbase_url      = λargs[7]
						ϒentries       λ.Object
						ϒentry         λ.Object
						ϒformats       λ.Object
						ϒjwplayer_data = λargs[1]
						ϒm3u8_id       = λargs[4]
						ϒmpd_id        = λargs[5]
						ϒrequire_title = λargs[3]
						ϒrtmp_params   = λargs[6]
						ϒself          = λargs[0]
						ϒsubtitles     λ.Object
						ϒthis_video_id λ.Object
						ϒtrack         λ.Object
						ϒtrack_kind    λ.Object
						ϒtrack_url     λ.Object
						ϒtracks        λ.Object
						ϒvideo_data    λ.Object
						ϒvideo_id      = λargs[2]
						τmp0           λ.Object
						τmp1           λ.Object
						τmp2           λ.Object
						τmp3           λ.Object
					)
					if !λ.Contains(ϒjwplayer_data, λ.StrLiteral("playlist")) {
						ϒjwplayer_data = λ.DictLiteral(map[string]λ.Object{
							"playlist": λ.NewList(ϒjwplayer_data),
						})
					}
					ϒentries = λ.NewList()
					if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, λ.GetItem(ϒjwplayer_data, λ.StrLiteral("playlist")), λ.ListType)) {
						λ.SetItem(ϒjwplayer_data, λ.StrLiteral("playlist"), λ.NewList(λ.GetItem(ϒjwplayer_data, λ.StrLiteral("playlist"))))
					}
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒjwplayer_data, λ.StrLiteral("playlist")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒvideo_data = τmp1
						if !λ.Contains(ϒvideo_data, λ.StrLiteral("sources")) {
							λ.SetItem(ϒvideo_data, λ.StrLiteral("sources"), λ.NewList(ϒvideo_data))
						}
						ϒthis_video_id = func() λ.Object {
							if λv := ϒvideo_id; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.GetItem(ϒvideo_data, λ.StrLiteral("mediaid"))
							}
						}()
						ϒformats = λ.Call(λ.GetAttr(ϒself, "_parse_jwplayer_formats", nil), λ.NewArgs(λ.GetItem(ϒvideo_data, λ.StrLiteral("sources"))), λ.KWArgs{
							{Name: "video_id", Value: ϒthis_video_id},
							{Name: "m3u8_id", Value: ϒm3u8_id},
							{Name: "mpd_id", Value: ϒmpd_id},
							{Name: "rtmp_params", Value: ϒrtmp_params},
							{Name: "base_url", Value: ϒbase_url},
						})
						ϒsubtitles = λ.DictLiteral(map[λ.Object]λ.Object{})
						ϒtracks = λ.Calm(ϒvideo_data, "get", λ.StrLiteral("tracks"))
						if λ.IsTrue(func() λ.Object {
							if λv := ϒtracks; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.BuiltinIsInstance, ϒtracks, λ.ListType)
							}
						}()) {
							τmp2 = λ.Cal(λ.BuiltinIter, ϒtracks)
							for {
								if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
									break
								}
								ϒtrack = τmp3
								if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒtrack, λ.DictType)) {
									continue
								}
								ϒtrack_kind = λ.Calm(ϒtrack, "get", λ.StrLiteral("kind"))
								if λ.IsTrue(func() λ.Object {
									if λv := λ.NewBool(!λ.IsTrue(ϒtrack_kind)); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.NewBool(!λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒtrack_kind, ϒcompat_str)))
									}
								}()) {
									continue
								}
								if !λ.Contains(λ.NewTuple(
									λ.StrLiteral("captions"),
									λ.StrLiteral("subtitles"),
								), λ.Calm(ϒtrack_kind, "lower")) {
									continue
								}
								ϒtrack_url = λ.Cal(ϒurljoin, ϒbase_url, λ.Calm(ϒtrack, "get", λ.StrLiteral("file")))
								if !λ.IsTrue(ϒtrack_url) {
									continue
								}
								λ.Calm(λ.Calm(ϒsubtitles, "setdefault", func() λ.Object {
									if λv := λ.Calm(ϒtrack, "get", λ.StrLiteral("label")); λ.IsTrue(λv) {
										return λv
									} else {
										return λ.StrLiteral("en")
									}
								}(), λ.NewList()), "append", λ.DictLiteral(map[string]λ.Object{
									"url": λ.Calm(ϒself, "_proto_relative_url", ϒtrack_url),
								}))
							}
						}
						ϒentry = λ.DictLiteral(map[string]λ.Object{
							"id": ϒthis_video_id,
							"title": λ.Cal(ϒunescapeHTML, func() λ.Object {
								if λ.IsTrue(ϒrequire_title) {
									return λ.GetItem(ϒvideo_data, λ.StrLiteral("title"))
								} else {
									return λ.Calm(ϒvideo_data, "get", λ.StrLiteral("title"))
								}
							}()),
							"description": λ.Cal(ϒclean_html, λ.Calm(ϒvideo_data, "get", λ.StrLiteral("description"))),
							"thumbnail":   λ.Cal(ϒurljoin, ϒbase_url, λ.Calm(ϒself, "_proto_relative_url", λ.Calm(ϒvideo_data, "get", λ.StrLiteral("image")))),
							"timestamp":   λ.Cal(ϒint_or_none, λ.Calm(ϒvideo_data, "get", λ.StrLiteral("pubdate"))),
							"duration": λ.Cal(ϒfloat_or_none, func() λ.Object {
								if λv := λ.Calm(ϒjwplayer_data, "get", λ.StrLiteral("duration")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Calm(ϒvideo_data, "get", λ.StrLiteral("duration"))
								}
							}()),
							"subtitles": ϒsubtitles,
						})
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(λ.Cal(λ.BuiltinLen, ϒformats), λ.IntLiteral(1)); !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(Ωre.ϒsearch, λ.StrLiteral("^(?:http|//).*(?:youtube\\.com|youtu\\.be)/.+"), λ.GetItem(λ.GetItem(ϒformats, λ.IntLiteral(0)), λ.StrLiteral("url")))
							}
						}()) {
							λ.Calm(ϒentry, "update", λ.DictLiteral(map[string]λ.Object{
								"_type": λ.StrLiteral("url_transparent"),
								"url":   λ.GetItem(λ.GetItem(ϒformats, λ.IntLiteral(0)), λ.StrLiteral("url")),
							}))
						} else {
							λ.Calm(ϒself, "_sort_formats", ϒformats)
							λ.SetItem(ϒentry, λ.StrLiteral("formats"), ϒformats)
						}
						λ.Calm(ϒentries, "append", ϒentry)
					}
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒentries), λ.IntLiteral(1))) {
						return λ.GetItem(ϒentries, λ.IntLiteral(0))
					} else {
						return λ.Calm(ϒself, "playlist_result", ϒentries)
					}
					return λ.None
				})
			InfoExtractor__parse_jwplayer_formats = λ.NewFunction("_parse_jwplayer_formats",
				[]λ.Param{
					{Name: "self"},
					{Name: "jwplayer_sources_data"},
					{Name: "video_id", Def: λ.None},
					{Name: "m3u8_id", Def: λ.None},
					{Name: "mpd_id", Def: λ.None},
					{Name: "rtmp_params", Def: λ.None},
					{Name: "base_url", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒa_format              λ.Object
						ϒbase_url              = λargs[6]
						ϒext                   λ.Object
						ϒformats               λ.Object
						ϒheight                λ.Object
						ϒjwplayer_sources_data = λargs[1]
						ϒm3u8_id               = λargs[3]
						ϒmpd_id                = λargs[4]
						ϒplay_path             λ.Object
						ϒprefix                λ.Object
						ϒrtmp_params           = λargs[5]
						ϒrtmp_url              λ.Object
						ϒrtmp_url_parts        λ.Object
						ϒself                  = λargs[0]
						ϒsource                λ.Object
						ϒsource_type           λ.Object
						ϒsource_url            λ.Object
						ϒurls                  λ.Object
						ϒvideo_id              = λargs[2]
						τmp0                   λ.Object
						τmp1                   λ.Object
						τmp2                   λ.Object
					)
					ϒurls = λ.NewList()
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, ϒjwplayer_sources_data)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒsource = τmp1
						if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒsource, λ.DictType)) {
							continue
						}
						ϒsource_url = λ.Cal(ϒurljoin, ϒbase_url, λ.Calm(ϒself, "_proto_relative_url", λ.Calm(ϒsource, "get", λ.StrLiteral("file"))))
						if λ.IsTrue(func() λ.Object {
							if λv := λ.NewBool(!λ.IsTrue(ϒsource_url)); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.NewBool(λ.Contains(ϒurls, ϒsource_url))
							}
						}()) {
							continue
						}
						λ.Calm(ϒurls, "append", ϒsource_url)
						ϒsource_type = func() λ.Object {
							if λv := λ.Calm(ϒsource, "get", λ.StrLiteral("type")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("")
							}
						}()
						ϒext = func() λ.Object {
							if λv := λ.Cal(ϒmimetype2ext, ϒsource_type); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(ϒdetermine_ext, ϒsource_url)
							}
						}()
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒsource_type, λ.StrLiteral("hls")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(ϒext, λ.StrLiteral("m3u8"))
							}
						}()) {
							λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_m3u8_formats", nil), λ.NewArgs(
								ϒsource_url,
								ϒvideo_id,
								λ.StrLiteral("mp4"),
							), λ.KWArgs{
								{Name: "entry_protocol", Value: λ.StrLiteral("m3u8_native")},
								{Name: "m3u8_id", Value: ϒm3u8_id},
								{Name: "fatal", Value: λ.False},
							}))
						} else {
							if λ.IsTrue(func() λ.Object {
								if λv := λ.Eq(ϒsource_type, λ.StrLiteral("dash")); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.Eq(ϒext, λ.StrLiteral("mpd"))
								}
							}()) {
								λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_mpd_formats", nil), λ.NewArgs(
									ϒsource_url,
									ϒvideo_id,
								), λ.KWArgs{
									{Name: "mpd_id", Value: ϒmpd_id},
									{Name: "fatal", Value: λ.False},
								}))
							} else {
								if λ.IsTrue(λ.Eq(ϒext, λ.StrLiteral("smil"))) {
									λ.Calm(ϒformats, "extend", λ.Call(λ.GetAttr(ϒself, "_extract_smil_formats", nil), λ.NewArgs(
										ϒsource_url,
										ϒvideo_id,
									), λ.KWArgs{
										{Name: "fatal", Value: λ.False},
									}))
								} else {
									if λ.IsTrue(func() λ.Object {
										if λv := λ.Calm(ϒsource_type, "startswith", λ.StrLiteral("audio")); λ.IsTrue(λv) {
											return λv
										} else {
											return λ.NewBool(λ.Contains(λ.NewTuple(
												λ.StrLiteral("oga"),
												λ.StrLiteral("aac"),
												λ.StrLiteral("mp3"),
												λ.StrLiteral("mpeg"),
												λ.StrLiteral("vorbis"),
											), ϒext))
										}
									}()) {
										λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
											"url":    ϒsource_url,
											"vcodec": λ.StrLiteral("none"),
											"ext":    ϒext,
										}))
									} else {
										ϒheight = λ.Cal(ϒint_or_none, λ.Calm(ϒsource, "get", λ.StrLiteral("height")))
										if ϒheight == λ.None {
											ϒheight = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
												λ.StrLiteral("^(\\d{3,4})[pP]?(?:\\b|$)"),
												λ.Cal(ϒcompat_str, func() λ.Object {
													if λv := λ.Calm(ϒsource, "get", λ.StrLiteral("label")); λ.IsTrue(λv) {
														return λv
													} else {
														return λ.StrLiteral("")
													}
												}()),
												λ.StrLiteral("height"),
											), λ.KWArgs{
												{Name: "default", Value: λ.None},
											}))
										}
										ϒa_format = λ.DictLiteral(map[string]λ.Object{
											"url":    ϒsource_url,
											"width":  λ.Cal(ϒint_or_none, λ.Calm(ϒsource, "get", λ.StrLiteral("width"))),
											"height": ϒheight,
											"tbr":    λ.Cal(ϒint_or_none, λ.Calm(ϒsource, "get", λ.StrLiteral("bitrate"))),
											"ext":    ϒext,
										})
										if λ.IsTrue(λ.Calm(ϒsource_url, "startswith", λ.StrLiteral("rtmp"))) {
											λ.SetItem(ϒa_format, λ.StrLiteral("ext"), λ.StrLiteral("flv"))
											ϒrtmp_url_parts = λ.Cal(λ.None, λ.StrLiteral("((?:mp4|mp3|flv):)"), ϒsource_url, λ.IntLiteral(1))
											if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒrtmp_url_parts), λ.IntLiteral(3))) {
												τmp2 = ϒrtmp_url_parts
												ϒrtmp_url = λ.GetItem(τmp2, λ.IntLiteral(0))
												ϒprefix = λ.GetItem(τmp2, λ.IntLiteral(1))
												ϒplay_path = λ.GetItem(τmp2, λ.IntLiteral(2))
												λ.Calm(ϒa_format, "update", λ.DictLiteral(map[string]λ.Object{
													"url":       ϒrtmp_url,
													"play_path": λ.Add(ϒprefix, ϒplay_path),
												}))
											}
											if λ.IsTrue(ϒrtmp_params) {
												λ.Calm(ϒa_format, "update", ϒrtmp_params)
											}
										}
										λ.Calm(ϒformats, "append", ϒa_format)
									}
								}
							}
						}
					}
					return ϒformats
				})
			InfoExtractor__live_title = λ.NewFunction("_live_title",
				[]λ.Param{
					{Name: "self"},
					{Name: "name"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒname = λargs[1]
						ϒself = λargs[0]
					)
					_ = ϒself
					return ϒname
				})
			InfoExtractor__int = λ.NewFunction("_int",
				[]λ.Param{
					{Name: "self"},
					{Name: "v"},
					{Name: "name"},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal  = λargs[3]
						ϒkwargs = λargs[4]
						ϒmsg    λ.Object
						ϒname   = λargs[2]
						ϒres    λ.Object
						ϒself   = λargs[0]
						ϒv      = λargs[1]
					)
					ϒres = λ.Call(ϒint_or_none, λ.NewArgs(ϒv), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					if λ.Contains(ϒkwargs, λ.StrLiteral("get_attr")) {
						λ.Cal(λ.BuiltinPrint, λ.Cal(λ.BuiltinGetAttr, ϒv, λ.GetItem(ϒkwargs, λ.StrLiteral("get_attr"))))
					}
					if ϒres == λ.None {
						ϒmsg = λ.Mod(λ.StrLiteral("Failed to extract %s: Could not parse value %r"), λ.NewTuple(
							ϒname,
							ϒv,
						))
						if λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(ExtractorError, ϒmsg)))
						} else {
							λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", ϒmsg)
						}
					}
					return ϒres
				})
			InfoExtractor__float = λ.NewFunction("_float",
				[]λ.Param{
					{Name: "self"},
					{Name: "v"},
					{Name: "name"},
					{Name: "fatal", Def: λ.False},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal  = λargs[3]
						ϒkwargs = λargs[4]
						ϒmsg    λ.Object
						ϒname   = λargs[2]
						ϒres    λ.Object
						ϒself   = λargs[0]
						ϒv      = λargs[1]
					)
					ϒres = λ.Call(ϒfloat_or_none, λ.NewArgs(ϒv), λ.KWArgs{
						{Name: "", Value: ϒkwargs},
					})
					if ϒres == λ.None {
						ϒmsg = λ.Mod(λ.StrLiteral("Failed to extract %s: Could not parse value %r"), λ.NewTuple(
							ϒname,
							ϒv,
						))
						if λ.IsTrue(ϒfatal) {
							panic(λ.Raise(λ.Cal(ExtractorError, ϒmsg)))
						} else {
							λ.Calm(λ.GetAttr(ϒself, "_downloader", nil), "report_warning", ϒmsg)
						}
					}
					return ϒres
				})
			InfoExtractor__set_cookie = λ.NewFunction("_set_cookie",
				[]λ.Param{
					{Name: "self"},
					{Name: "domain"},
					{Name: "name"},
					{Name: "value"},
					{Name: "expire_time", Def: λ.None},
					{Name: "port", Def: λ.None},
					{Name: "path", Def: λ.StrLiteral("/")},
					{Name: "secure", Def: λ.False},
					{Name: "discard", Def: λ.False},
					{Name: "rest", Def: λ.DictLiteral(map[λ.Object]λ.Object{})},
				},
				0, false, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcookie      λ.Object
						ϒdiscard     = λargs[8]
						ϒdomain      = λargs[1]
						ϒexpire_time = λargs[4]
						ϒkwargs      = λargs[10]
						ϒname        = λargs[2]
						ϒpath        = λargs[6]
						ϒport        = λargs[5]
						ϒrest        = λargs[9]
						ϒsecure      = λargs[7]
						ϒself        = λargs[0]
						ϒvalue       = λargs[3]
					)
					_ = ϒkwargs
					ϒcookie = λ.Cal(ϒcompat_cookiejar_Cookie, λ.IntLiteral(0), ϒname, ϒvalue, ϒport, λ.NewBool(ϒport != λ.None), ϒdomain, λ.True, λ.Calm(ϒdomain, "startswith", λ.StrLiteral(".")), ϒpath, λ.True, ϒsecure, ϒexpire_time, ϒdiscard, λ.None, λ.None, ϒrest)
					λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "cookiejar", nil), "set_cookie", ϒcookie)
					return λ.None
				})
			InfoExtractor__get_cookies = λ.NewFunction("_get_cookies",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒreq  λ.Object
						ϒself = λargs[0]
						ϒurl  = λargs[1]
					)
					ϒreq = λ.Cal(ϒsanitized_Request, ϒurl)
					λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "cookiejar", nil), "add_cookie_header", ϒreq)
					return λ.Cal(Ωcookies.SimpleCookie, λ.Calm(ϒreq, "get_header", λ.StrLiteral("Cookie")))
				})
			InfoExtractor_extract_subtitles = λ.NewFunction("extract_subtitles",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒself   = λargs[0]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("writesubtitles"), λ.False); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("listsubtitles"))
						}
					}()) {
						return λ.Call(λ.GetAttr(ϒself, "_get_subtitles", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
							{Name: "", Value: ϒkwargs},
						})
					}
					return λ.DictLiteral(map[λ.Object]λ.Object{})
				})
			InfoExtractor__merge_subtitle_items = λ.NewFunction("_merge_subtitle_items",
				[]λ.Param{
					{Name: "subtitle_list1"},
					{Name: "subtitle_list2"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒlist1_urls     λ.Object
						ϒret            λ.Object
						ϒsubtitle_list1 = λargs[0]
						ϒsubtitle_list2 = λargs[1]
					)
					ϒlist1_urls = λ.Cal(λ.SetType, λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒitem λ.Object
									τmp0  λ.Object
									τmp1  λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, ϒsubtitle_list1)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒitem = τmp1
									λgy.Yield(λ.GetItem(ϒitem, λ.StrLiteral("url")))
								}
								return λ.None
							})
						}))))
					ϒret = λ.Cal(λ.ListType, ϒsubtitle_list1)
					λ.Calm(ϒret, "extend", λ.Cal(λ.ListType, λ.Cal(λ.NewFunction("<generator>",
						nil,
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
								var (
									ϒitem λ.Object
									τmp0  λ.Object
									τmp1  λ.Object
								)
								τmp0 = λ.Cal(λ.BuiltinIter, ϒsubtitle_list2)
								for {
									if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
										break
									}
									ϒitem = τmp1
									if !λ.Contains(ϒlist1_urls, λ.GetItem(ϒitem, λ.StrLiteral("url"))) {
										λgy.Yield(ϒitem)
									}
								}
								return λ.None
							})
						}))))
					return ϒret
				})
			InfoExtractor__merge_subtitle_items = λ.Cal(λ.StaticMethodType, InfoExtractor__merge_subtitle_items)
			InfoExtractor__merge_subtitles = λ.NewFunction("_merge_subtitles",
				[]λ.Param{
					{Name: "cls"},
					{Name: "subtitle_dict1"},
					{Name: "subtitle_dict2"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls            = λargs[0]
						ϒlang           λ.Object
						ϒret            λ.Object
						ϒsubtitle_dict1 = λargs[1]
						ϒsubtitle_dict2 = λargs[2]
						τmp0            λ.Object
						τmp1            λ.Object
					)
					ϒret = λ.Cal(λ.DictType, ϒsubtitle_dict1)
					τmp0 = λ.Cal(λ.BuiltinIter, ϒsubtitle_dict2)
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒlang = τmp1
						λ.SetItem(ϒret, ϒlang, λ.Calm(ϒcls, "_merge_subtitle_items", λ.Calm(ϒsubtitle_dict1, "get", ϒlang, λ.NewList()), λ.GetItem(ϒsubtitle_dict2, ϒlang)))
					}
					return ϒret
				})
			InfoExtractor__merge_subtitles = λ.Cal(λ.ClassMethodType, InfoExtractor__merge_subtitles)
			InfoExtractor_extract_automatic_captions = λ.NewFunction("extract_automatic_captions",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒself   = λargs[0]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("writeautomaticsub"), λ.False); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("listsubtitles"))
						}
					}()) {
						return λ.Call(λ.GetAttr(ϒself, "_get_automatic_captions", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
							{Name: "", Value: ϒkwargs},
						})
					}
					return λ.DictLiteral(map[λ.Object]λ.Object{})
				})
			InfoExtractor_mark_watched = λ.NewFunction("mark_watched",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, true,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒargs   = λargs[1]
						ϒkwargs = λargs[2]
						ϒself   = λargs[0]
					)
					if λ.IsTrue(func() λ.Object {
						if λv := λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("mark_watched"), λ.False); !λ.IsTrue(λv) {
							return λv
						} else {
							return func() λ.Object {
								if λv := λ.NewBool(λ.GetItem(λ.Calm(ϒself, "_get_login_info"), λ.IntLiteral(0)) != λ.None); λ.IsTrue(λv) {
									return λv
								} else {
									return λ.NewBool(λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("cookiefile")) != λ.None)
								}
							}()
						}
					}()) {
						λ.Call(λ.GetAttr(ϒself, "_mark_watched", nil), λ.NewArgs(λ.Unpack(λ.AsStarred(ϒargs))...), λ.KWArgs{
							{Name: "", Value: ϒkwargs},
						})
					}
					return λ.None
				})
			InfoExtractor_geo_verification_headers = λ.NewFunction("geo_verification_headers",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒgeo_verification_proxy λ.Object
						ϒheaders                λ.Object
						ϒself                   = λargs[0]
					)
					ϒheaders = λ.DictLiteral(map[λ.Object]λ.Object{})
					ϒgeo_verification_proxy = λ.Calm(λ.GetAttr(λ.GetAttr(ϒself, "_downloader", nil), "params", nil), "get", λ.StrLiteral("geo_verification_proxy"))
					if λ.IsTrue(ϒgeo_verification_proxy) {
						λ.SetItem(ϒheaders, λ.StrLiteral("Ytdl-request-proxy"), ϒgeo_verification_proxy)
					}
					return ϒheaders
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"IE_NAME":                      InfoExtractor_IE_NAME,
				"_GEO_BYPASS":                  InfoExtractor__GEO_BYPASS,
				"_GEO_COUNTRIES":               InfoExtractor__GEO_COUNTRIES,
				"_GEO_IP_BLOCKS":               InfoExtractor__GEO_IP_BLOCKS,
				"_WORKING":                     InfoExtractor__WORKING,
				"__can_accept_status_code":     InfoExtractor___can_accept_status_code,
				"__check_blocked":              InfoExtractor___check_blocked,
				"__init__":                     InfoExtractor___init__,
				"__maybe_fake_ip_and_retry":    InfoExtractor___maybe_fake_ip_and_retry,
				"_check_formats":               InfoExtractor__check_formats,
				"_download_json":               InfoExtractor__download_json,
				"_download_json_handle":        InfoExtractor__download_json_handle,
				"_download_smil":               InfoExtractor__download_smil,
				"_download_webpage":            InfoExtractor__download_webpage,
				"_download_webpage_handle":     InfoExtractor__download_webpage_handle,
				"_download_xml":                InfoExtractor__download_xml,
				"_download_xml_handle":         InfoExtractor__download_xml_handle,
				"_downloader":                  InfoExtractor__downloader,
				"_extract_akamai_formats":      InfoExtractor__extract_akamai_formats,
				"_extract_f4m_formats":         InfoExtractor__extract_f4m_formats,
				"_extract_ism_formats":         InfoExtractor__extract_ism_formats,
				"_extract_m3u8_formats":        InfoExtractor__extract_m3u8_formats,
				"_extract_mpd_formats":         InfoExtractor__extract_mpd_formats,
				"_extract_smil_formats":        InfoExtractor__extract_smil_formats,
				"_float":                       InfoExtractor__float,
				"_form_hidden_inputs":          InfoExtractor__form_hidden_inputs,
				"_get_cookies":                 InfoExtractor__get_cookies,
				"_get_login_info":              InfoExtractor__get_login_info,
				"_get_netrc_login_info":        InfoExtractor__get_netrc_login_info,
				"_guess_encoding_from_content": InfoExtractor__guess_encoding_from_content,
				"_hidden_inputs":               InfoExtractor__hidden_inputs,
				"_html_search_meta":            InfoExtractor__html_search_meta,
				"_html_search_regex":           InfoExtractor__html_search_regex,
				"_initialize_geo_bypass":       InfoExtractor__initialize_geo_bypass,
				"_int":                         InfoExtractor__int,
				"_is_valid_url":                InfoExtractor__is_valid_url,
				"_json_ld":                     InfoExtractor__json_ld,
				"_live_title":                  InfoExtractor__live_title,
				"_match_id":                    InfoExtractor__match_id,
				"_media_rating_search":         InfoExtractor__media_rating_search,
				"_merge_subtitle_items":        InfoExtractor__merge_subtitle_items,
				"_merge_subtitles":             InfoExtractor__merge_subtitles,
				"_meta_regex":                  InfoExtractor__meta_regex,
				"_og_regexes":                  InfoExtractor__og_regexes,
				"_og_search_description":       InfoExtractor__og_search_description,
				"_og_search_property":          InfoExtractor__og_search_property,
				"_og_search_thumbnail":         InfoExtractor__og_search_thumbnail,
				"_og_search_title":             InfoExtractor__og_search_title,
				"_og_search_url":               InfoExtractor__og_search_url,
				"_og_search_video_url":         InfoExtractor__og_search_video_url,
				"_parse_f4m_formats":           InfoExtractor__parse_f4m_formats,
				"_parse_html5_media_entries":   InfoExtractor__parse_html5_media_entries,
				"_parse_ism_formats":           InfoExtractor__parse_ism_formats,
				"_parse_json":                  InfoExtractor__parse_json,
				"_parse_jwplayer_data":         InfoExtractor__parse_jwplayer_data,
				"_parse_jwplayer_formats":      InfoExtractor__parse_jwplayer_formats,
				"_parse_m3u8_formats":          InfoExtractor__parse_m3u8_formats,
				"_parse_mpd_formats":           InfoExtractor__parse_mpd_formats,
				"_parse_smil_formats":          InfoExtractor__parse_smil_formats,
				"_parse_smil_namespace":        InfoExtractor__parse_smil_namespace,
				"_parse_smil_subtitles":        InfoExtractor__parse_smil_subtitles,
				"_parse_xml":                   InfoExtractor__parse_xml,
				"_proto_relative_url":          InfoExtractor__proto_relative_url,
				"_ready":                       InfoExtractor__ready,
				"_real_initialize":             InfoExtractor__real_initialize,
				"_remove_duplicate_formats":    InfoExtractor__remove_duplicate_formats,
				"_request_webpage":             InfoExtractor__request_webpage,
				"_rta_search":                  InfoExtractor__rta_search,
				"_search_json_ld":              InfoExtractor__search_json_ld,
				"_search_regex":                InfoExtractor__search_regex,
				"_set_cookie":                  InfoExtractor__set_cookie,
				"_sort_formats":                InfoExtractor__sort_formats,
				"_webpage_read_content":        InfoExtractor__webpage_read_content,
				"_x_forwarded_for_ip":          InfoExtractor__x_forwarded_for_ip,
				"_xpath_ns":                    InfoExtractor__xpath_ns,
				"extract":                      InfoExtractor_extract,
				"extract_automatic_captions":   InfoExtractor_extract_automatic_captions,
				"extract_subtitles":            InfoExtractor_extract_subtitles,
				"geo_verification_headers":     InfoExtractor_geo_verification_headers,
				"http_scheme":                  InfoExtractor_http_scheme,
				"ie_key":                       InfoExtractor_ie_key,
				"initialize":                   InfoExtractor_initialize,
				"mark_watched":                 InfoExtractor_mark_watched,
				"playlist_result":              InfoExtractor_playlist_result,
				"raise_geo_restricted":         InfoExtractor_raise_geo_restricted,
				"report_download_webpage":      InfoExtractor_report_download_webpage,
				"report_extraction":            InfoExtractor_report_extraction,
				"report_warning":               InfoExtractor_report_warning,
				"set_downloader":               InfoExtractor_set_downloader,
				"suitable":                     InfoExtractor_suitable,
				"to_screen":                    InfoExtractor_to_screen,
				"url_result":                   InfoExtractor_url_result,
				"working":                      InfoExtractor_working,
			})
		}())
		SearchInfoExtractor = λ.Cal(λ.TypeType, λ.StrLiteral("SearchInfoExtractor"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				SearchInfoExtractor__make_valid_url λ.Object
				SearchInfoExtractor_suitable        λ.Object
			)
			SearchInfoExtractor__make_valid_url = λ.NewFunction("_make_valid_url",
				[]λ.Param{
					{Name: "cls"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
					)
					return λ.Mod(λ.StrLiteral("%s(?P<prefix>|[1-9][0-9]*|all):(?P<query>[\\s\\S]+)"), λ.GetAttr(ϒcls, "_SEARCH_KEY", nil))
				})
			SearchInfoExtractor__make_valid_url = λ.Cal(λ.ClassMethodType, SearchInfoExtractor__make_valid_url)
			SearchInfoExtractor_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return λ.NewBool(λ.Cal(Ωre.ϒmatch, λ.Calm(ϒcls, "_make_valid_url"), ϒurl) != λ.None)
				})
			SearchInfoExtractor_suitable = λ.Cal(λ.ClassMethodType, SearchInfoExtractor_suitable)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_make_valid_url": SearchInfoExtractor__make_valid_url,
				"suitable":        SearchInfoExtractor_suitable,
			})
		}())
		λ.Cal(Ωmath.ϒceil, λ.IntLiteral(23))
	})
}
