// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * clyp/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/clyp.py
 */

package clyp

import (
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ClypIE                        λ.Object
	InfoExtractor                 λ.Object
	ϒcompat_parse_qs              λ.Object
	ϒcompat_urllib_parse_urlparse λ.Object
	ϒfloat_or_none                λ.Object
	ϒunified_timestamp            λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_parse_qs = Ωcompat.ϒcompat_parse_qs
		ϒcompat_urllib_parse_urlparse = Ωcompat.ϒcompat_urllib_parse_urlparse
		ϒfloat_or_none = Ωutils.ϒfloat_or_none
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		ClypIE = λ.Cal(λ.TypeType, λ.StrLiteral("ClypIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				ClypIE__VALID_URL    λ.Object
				ClypIE__real_extract λ.Object
			)
			ClypIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?clyp\\.it/(?P<id>[a-z0-9]+)")
			ClypIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒaudio_id    λ.Object
						ϒdescription λ.Object
						ϒduration    λ.Object
						ϒext         λ.Object
						ϒformat_id   λ.Object
						ϒformat_url  λ.Object
						ϒformats     λ.Object
						ϒmetadata    λ.Object
						ϒqs          λ.Object
						ϒquery       λ.Object
						ϒsecure      λ.Object
						ϒself        = λargs[0]
						ϒtimestamp   λ.Object
						ϒtitle       λ.Object
						ϒtoken       λ.Object
						ϒurl         = λargs[1]
						τmp0         λ.Object
						τmp1         λ.Object
						τmp2         λ.Object
						τmp3         λ.Object
					)
					ϒaudio_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒqs = λ.Cal(ϒcompat_parse_qs, λ.GetAttr(λ.Cal(ϒcompat_urllib_parse_urlparse, ϒurl), "query", nil))
					ϒtoken = λ.GetItem(λ.Calm(ϒqs, "get", λ.StrLiteral("token"), λ.NewList(λ.None)), λ.IntLiteral(0))
					ϒquery = λ.DictLiteral(map[λ.Object]λ.Object{})
					if λ.IsTrue(ϒtoken) {
						λ.SetItem(ϒquery, λ.StrLiteral("token"), ϒtoken)
					}
					ϒmetadata = λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
						λ.Mod(λ.StrLiteral("https://api.clyp.it/%s"), ϒaudio_id),
						ϒaudio_id,
					), λ.KWArgs{
						{Name: "query", Value: ϒquery},
					})
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
						λ.StrLiteral(""),
						λ.StrLiteral("Secure"),
					))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒsecure = τmp1
						τmp2 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
							λ.StrLiteral("Ogg"),
							λ.StrLiteral("Mp3"),
						))
						for {
							if τmp3 = λ.NextDefault(τmp2, λ.AfterLast); τmp3 == λ.AfterLast {
								break
							}
							ϒext = τmp3
							ϒformat_id = λ.Mod(λ.StrLiteral("%s%s"), λ.NewTuple(
								ϒsecure,
								ϒext,
							))
							ϒformat_url = λ.Calm(ϒmetadata, "get", λ.Mod(λ.StrLiteral("%sUrl"), ϒformat_id))
							if λ.IsTrue(ϒformat_url) {
								λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
									"url":       ϒformat_url,
									"format_id": ϒformat_id,
									"vcodec":    λ.StrLiteral("none"),
								}))
							}
						}
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒtitle = λ.GetItem(ϒmetadata, λ.StrLiteral("Title"))
					ϒdescription = λ.Calm(ϒmetadata, "get", λ.StrLiteral("Description"))
					ϒduration = λ.Cal(ϒfloat_or_none, λ.Calm(ϒmetadata, "get", λ.StrLiteral("Duration")))
					ϒtimestamp = λ.Cal(ϒunified_timestamp, λ.Calm(ϒmetadata, "get", λ.StrLiteral("DateCreated")))
					return λ.DictLiteral(map[string]λ.Object{
						"id":          ϒaudio_id,
						"title":       ϒtitle,
						"description": ϒdescription,
						"duration":    ϒduration,
						"timestamp":   ϒtimestamp,
						"formats":     ϒformats,
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL":    ClypIE__VALID_URL,
				"_real_extract": ClypIE__real_extract,
			})
		}())
	})
}
