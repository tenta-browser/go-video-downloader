// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * nrk/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/nrk.py
 */

package nrk

import (
	Ωcompat "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/compat"
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	ExtractorError    λ.Object
	InfoExtractor     λ.Object
	NRKBaseIE         λ.Object
	NRKIE             λ.Object
	NRKPlaylistBaseIE λ.Object
	NRKPlaylistIE     λ.Object
	NRKRadioPodkastIE λ.Object
	NRKSkoleIE        λ.Object
	NRKTVDirekteIE    λ.Object
	NRKTVEpisodeIE    λ.Object
	NRKTVEpisodesIE   λ.Object
	NRKTVIE           λ.Object
	NRKTVSeasonIE     λ.Object
	NRKTVSerieBaseIE  λ.Object
	NRKTVSeriesIE     λ.Object
	ϒcompat_str       λ.Object
	ϒdetermine_ext    λ.Object
	ϒint_or_none      λ.Object
	ϒparse_duration   λ.Object
	ϒstr_or_none      λ.Object
	ϒtry_get          λ.Object
	ϒurl_or_none      λ.Object
	ϒurljoin          λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒcompat_str = Ωcompat.ϒcompat_str
		ϒdetermine_ext = Ωutils.ϒdetermine_ext
		ExtractorError = Ωutils.ExtractorError
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒstr_or_none = Ωutils.ϒstr_or_none
		ϒtry_get = Ωutils.ϒtry_get
		ϒurljoin = Ωutils.ϒurljoin
		ϒurl_or_none = Ωutils.ϒurl_or_none
		NRKBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NRKBaseIE__GEO_COUNTRIES λ.Object
				NRKBaseIE__call_api      λ.Object
			)
			NRKBaseIE__GEO_COUNTRIES = λ.NewList(λ.StrLiteral("NO"))
			NRKBaseIE__call_api = λ.NewFunction("_call_api",
				[]λ.Param{
					{Name: "self"},
					{Name: "path"},
					{Name: "video_id"},
					{Name: "item", Def: λ.None},
					{Name: "note", Def: λ.None},
					{Name: "fatal", Def: λ.True},
					{Name: "query", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒfatal    = λargs[5]
						ϒitem     = λargs[3]
						ϒnote     = λargs[4]
						ϒpath     = λargs[1]
						ϒquery    = λargs[6]
						ϒself     = λargs[0]
						ϒvideo_id = λargs[2]
					)
					return λ.Call(λ.GetAttr(ϒself, "_download_json", nil), λ.NewArgs(
						λ.Cal(ϒurljoin, λ.StrLiteral("https://psapi.nrk.no/"), ϒpath),
						ϒvideo_id,
						func() λ.Object {
							if λv := ϒnote; λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Mod(λ.StrLiteral("Downloading %s JSON"), ϒitem)
							}
						}(),
					), λ.KWArgs{
						{Name: "fatal", Value: ϒfatal},
						{Name: "query", Value: ϒquery},
						{Name: "headers", Value: λ.DictLiteral(map[string]string{
							"Accept-Encoding": "gzip, deflate, br",
						})},
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_GEO_COUNTRIES": NRKBaseIE__GEO_COUNTRIES,
				"_call_api":      NRKBaseIE__call_api,
			})
		}())
		NRKIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKIE"), λ.NewTuple(NRKBaseIE), func() λ.Dict {
			var (
				NRKIE__VALID_URL    λ.Object
				NRKIE__real_extract λ.Object
			)
			NRKIE__VALID_URL = λ.StrLiteral("(?x)\n                        (?:\n                            nrk:|\n                            https?://\n                                (?:\n                                    (?:www\\.)?nrk\\.no/video/(?:PS\\*|[^_]+_)|\n                                    v8[-.]psapi\\.nrk\\.no/mediaelement/\n                                )\n                            )\n                            (?P<id>[^?\\#&]+)\n                        ")
			NRKIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒage_limit         λ.Object
						ϒalt_title         λ.Object
						ϒasset             λ.Object
						ϒasset_format      λ.Object
						ϒcall_playback_api λ.Object
						ϒdata              λ.Object
						ϒdescription       λ.Object
						ϒduration          λ.Object
						ϒepisode           λ.Object
						ϒepisode_number    λ.Object
						ϒformat_url        λ.Object
						ϒformats           λ.Object
						ϒimage             λ.Object
						ϒimage_url         λ.Object
						ϒinfo              λ.Object
						ϒis_series         λ.Object
						ϒlegal_age         λ.Object
						ϒmanifest          λ.Object
						ϒpath_templ        λ.Object
						ϒplayable          λ.Object
						ϒpreplay           λ.Object
						ϒprograms          λ.Object
						ϒseason_id         λ.Object
						ϒseason_number     λ.Object
						ϒself              = λargs[0]
						ϒseries            λ.Object
						ϒsub               λ.Object
						ϒsub_key           λ.Object
						ϒsub_type          λ.Object
						ϒsub_url           λ.Object
						ϒsubtitles         λ.Object
						ϒthumbnails        λ.Object
						ϒtitle             λ.Object
						ϒtitles            λ.Object
						ϒurl               = λargs[1]
						ϒvideo_id          λ.Object
						τmp0               λ.Object
						τmp1               λ.Object
						τmp2               λ.Object
					)
					ϒvideo_id = λ.GetItem(λ.Calm(λ.Calm(ϒself, "_match_id", ϒurl), "split", λ.StrLiteral("/")), λ.Neg(λ.IntLiteral(1)))
					ϒpath_templ = λ.Add(λ.StrLiteral("playback/%s/"), ϒvideo_id)
					ϒcall_playback_api = λ.NewFunction("call_playback_api",
						[]λ.Param{
							{Name: "item"},
							{Name: "query", Def: λ.None},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒitem  = λargs[0]
								ϒquery = λargs[1]
							)
							return λ.Call(λ.GetAttr(ϒself, "_call_api", nil), λ.NewArgs(
								λ.Mod(ϒpath_templ, ϒitem),
								ϒvideo_id,
								ϒitem,
							), λ.KWArgs{
								{Name: "query", Value: ϒquery},
							})
						})
					ϒmanifest = λ.Cal(ϒcall_playback_api, λ.StrLiteral("manifest"), λ.DictLiteral(map[string]string{
						"preferredCdn": "akamai",
					}))
					ϒvideo_id = func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒmanifest, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.StrLiteral("id"))
							}), ϒcompat_str); λ.IsTrue(λv) {
							return λv
						} else {
							return ϒvideo_id
						}
					}()
					if λ.IsTrue(λ.Eq(λ.Calm(ϒmanifest, "get", λ.StrLiteral("playability")), λ.StrLiteral("nonPlayable"))) {
						λ.Calm(ϒself, "_raise_error", λ.GetItem(ϒmanifest, λ.StrLiteral("nonPlayable")))
					}
					ϒplayable = λ.GetItem(ϒmanifest, λ.StrLiteral("playable"))
					ϒformats = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, λ.GetItem(ϒplayable, λ.StrLiteral("assets")))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒasset = τmp1
						if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒasset, λ.DictType)) {
							continue
						}
						if λ.IsTrue(λ.Calm(ϒasset, "get", λ.StrLiteral("encrypted"))) {
							continue
						}
						ϒformat_url = λ.Cal(ϒurl_or_none, λ.Calm(ϒasset, "get", λ.StrLiteral("url")))
						if !λ.IsTrue(ϒformat_url) {
							continue
						}
						ϒasset_format = λ.Calm(func() λ.Object {
							if λv := λ.Calm(ϒasset, "get", λ.StrLiteral("format")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("")
							}
						}(), "lower")
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Eq(ϒasset_format, λ.StrLiteral("hls")); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Eq(λ.Cal(ϒdetermine_ext, ϒformat_url), λ.StrLiteral("m3u8"))
							}
						}()) {
							λ.Calm(ϒformats, "extend", λ.Calm(ϒself, "_extract_nrk_formats", ϒformat_url, ϒvideo_id))
						} else {
							if λ.IsTrue(λ.Eq(ϒasset_format, λ.StrLiteral("mp3"))) {
								λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
									"url":       ϒformat_url,
									"format_id": ϒasset_format,
									"vcodec":    λ.StrLiteral("none"),
								}))
							}
						}
					}
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒdata = λ.Cal(ϒcall_playback_api, λ.StrLiteral("metadata"))
					ϒpreplay = λ.GetItem(ϒdata, λ.StrLiteral("preplay"))
					ϒtitles = λ.GetItem(ϒpreplay, λ.StrLiteral("titles"))
					ϒtitle = λ.GetItem(ϒtitles, λ.StrLiteral("title"))
					ϒalt_title = λ.Calm(ϒtitles, "get", λ.StrLiteral("subtitle"))
					ϒdescription = λ.Calm(ϒpreplay, "get", λ.StrLiteral("description"))
					ϒduration = func() λ.Object {
						if λv := λ.Cal(ϒparse_duration, λ.Calm(ϒplayable, "get", λ.StrLiteral("duration"))); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.Cal(ϒparse_duration, λ.Calm(ϒdata, "get", λ.StrLiteral("duration")))
						}
					}()
					ϒthumbnails = λ.NewList()
					τmp0 = λ.Cal(λ.BuiltinIter, func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒpreplay, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("poster")), λ.StrLiteral("images"))
							}), λ.ListType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}())
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒimage = τmp1
						if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒimage, λ.DictType)) {
							continue
						}
						ϒimage_url = λ.Cal(ϒurl_or_none, λ.Calm(ϒimage, "get", λ.StrLiteral("url")))
						if !λ.IsTrue(ϒimage_url) {
							continue
						}
						λ.Calm(ϒthumbnails, "append", λ.DictLiteral(map[string]λ.Object{
							"url":    ϒimage_url,
							"width":  λ.Cal(ϒint_or_none, λ.Calm(ϒimage, "get", λ.StrLiteral("pixelWidth"))),
							"height": λ.Cal(ϒint_or_none, λ.Calm(ϒimage, "get", λ.StrLiteral("pixelHeight"))),
						}))
					}
					ϒsubtitles = λ.DictLiteral(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, func() λ.Object {
						if λv := λ.Cal(ϒtry_get, ϒplayable, λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "x"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒx = λargs[0]
								)
								return λ.GetItem(ϒx, λ.StrLiteral("subtitles"))
							}), λ.ListType); λ.IsTrue(λv) {
							return λv
						} else {
							return λ.NewList()
						}
					}())
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒsub = τmp1
						if !λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒsub, λ.DictType)) {
							continue
						}
						ϒsub_url = λ.Cal(ϒurl_or_none, λ.Calm(ϒsub, "get", λ.StrLiteral("webVtt")))
						if !λ.IsTrue(ϒsub_url) {
							continue
						}
						ϒsub_key = func() λ.Object {
							if λv := λ.Cal(ϒstr_or_none, λ.Calm(ϒsub, "get", λ.StrLiteral("language"))); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.StrLiteral("nb")
							}
						}()
						ϒsub_type = λ.Cal(ϒstr_or_none, λ.Calm(ϒsub, "get", λ.StrLiteral("type")))
						if λ.IsTrue(ϒsub_type) {
							τmp2 = λ.IAdd(ϒsub_key, λ.Mod(λ.StrLiteral("-%s"), ϒsub_type))
							ϒsub_key = τmp2
						}
						λ.Calm(λ.Calm(ϒsubtitles, "setdefault", ϒsub_key, λ.NewList()), "append", λ.DictLiteral(map[string]λ.Object{
							"url": ϒsub_url,
						}))
					}
					ϒlegal_age = λ.Cal(ϒtry_get, ϒdata, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("legalAge")), λ.StrLiteral("body")), λ.StrLiteral("rating")), λ.StrLiteral("code"))
						}), ϒcompat_str)
					ϒage_limit = λ.None
					if λ.IsTrue(ϒlegal_age) {
						if λ.IsTrue(λ.Eq(ϒlegal_age, λ.StrLiteral("A"))) {
							ϒage_limit = λ.IntLiteral(0)
						} else {
							if λ.IsTrue(λ.Calm(ϒlegal_age, "isdigit")) {
								ϒage_limit = λ.Cal(ϒint_or_none, ϒlegal_age)
							}
						}
					}
					ϒis_series = λ.Eq(λ.Cal(ϒtry_get, ϒdata, λ.NewFunction("<lambda>",
						[]λ.Param{
							{Name: "x"},
						},
						0, false, false,
						func(λargs []λ.Object) λ.Object {
							var (
								ϒx = λargs[0]
							)
							return λ.GetItem(λ.GetItem(λ.GetItem(ϒx, λ.StrLiteral("_links")), λ.StrLiteral("series")), λ.StrLiteral("name"))
						})), λ.StrLiteral("series"))
					ϒinfo = λ.DictLiteral(map[string]λ.Object{
						"id":          ϒvideo_id,
						"title":       ϒtitle,
						"alt_title":   ϒalt_title,
						"description": ϒdescription,
						"duration":    ϒduration,
						"thumbnails":  ϒthumbnails,
						"age_limit":   ϒage_limit,
						"formats":     ϒformats,
						"subtitles":   ϒsubtitles,
					})
					if λ.IsTrue(ϒis_series) {
						τmp0 = λ.None
						ϒseries = τmp0
						ϒseason_id = τmp0
						ϒseason_number = τmp0
						ϒepisode = τmp0
						ϒepisode_number = τmp0
						ϒprograms = λ.Call(λ.GetAttr(ϒself, "_call_api", nil), λ.NewArgs(
							λ.Mod(λ.StrLiteral("programs/%s"), ϒvideo_id),
							ϒvideo_id,
							λ.StrLiteral("programs"),
						), λ.KWArgs{
							{Name: "fatal", Value: λ.False},
						})
						if λ.IsTrue(func() λ.Object {
							if λv := ϒprograms; !λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Cal(λ.BuiltinIsInstance, ϒprograms, λ.DictType)
							}
						}()) {
							ϒseries = λ.Cal(ϒstr_or_none, λ.Calm(ϒprograms, "get", λ.StrLiteral("seriesTitle")))
							ϒseason_id = λ.Cal(ϒstr_or_none, λ.Calm(ϒprograms, "get", λ.StrLiteral("seasonId")))
							ϒseason_number = λ.Cal(ϒint_or_none, λ.Calm(ϒprograms, "get", λ.StrLiteral("seasonNumber")))
							ϒepisode = λ.Cal(ϒstr_or_none, λ.Calm(ϒprograms, "get", λ.StrLiteral("episodeTitle")))
							ϒepisode_number = λ.Cal(ϒint_or_none, λ.Calm(ϒprograms, "get", λ.StrLiteral("episodeNumber")))
						}
						if !λ.IsTrue(ϒseries) {
							ϒseries = ϒtitle
						}
						if λ.IsTrue(ϒalt_title) {
							τmp0 = λ.IAdd(ϒtitle, λ.Mod(λ.StrLiteral(" - %s"), ϒalt_title))
							ϒtitle = τmp0
						}
						if !λ.IsTrue(ϒseason_number) {
							ϒseason_number = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("Sesong\\s+(\\d+)"),
								func() λ.Object {
									if λv := ϒdescription; λ.IsTrue(λv) {
										return λv
									} else {
										return λ.StrLiteral("")
									}
								}(),
								λ.StrLiteral("season number"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						}
						if !λ.IsTrue(ϒepisode) {
							ϒepisode = func() λ.Object {
								if λ.IsTrue(ϒis_series) {
									return ϒalt_title
								} else {
									return λ.None
								}
							}()
						}
						if !λ.IsTrue(ϒepisode_number) {
							ϒepisode_number = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("^(\\d+)\\."),
								func() λ.Object {
									if λv := ϒepisode; λ.IsTrue(λv) {
										return λv
									} else {
										return λ.StrLiteral("")
									}
								}(),
								λ.StrLiteral("episode number"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						}
						if !λ.IsTrue(ϒepisode_number) {
							ϒepisode_number = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
								λ.StrLiteral("\\((\\d+)\\s*:\\s*\\d+\\)"),
								func() λ.Object {
									if λv := ϒdescription; λ.IsTrue(λv) {
										return λv
									} else {
										return λ.StrLiteral("")
									}
								}(),
								λ.StrLiteral("episode number"),
							), λ.KWArgs{
								{Name: "default", Value: λ.None},
							}))
						}
						λ.Calm(ϒinfo, "update", λ.DictLiteral(map[string]λ.Object{
							"title":          ϒtitle,
							"series":         ϒseries,
							"season_id":      ϒseason_id,
							"season_number":  ϒseason_number,
							"episode":        ϒepisode,
							"episode_number": ϒepisode_number,
						}))
					}
					return ϒinfo
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL":    NRKIE__VALID_URL,
				"_real_extract": NRKIE__real_extract,
			})
		}())
		NRKTVIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NRKTVIE__EPISODE_RE λ.Object
				NRKTVIE__VALID_URL  λ.Object
			)
			NRKTVIE__EPISODE_RE = λ.StrLiteral("(?P<id>[a-zA-Z]{4}\\d{8})")
			NRKTVIE__VALID_URL = λ.Mod(λ.StrLiteral("https?://(?:tv|radio)\\.nrk(?:super)?\\.no/(?:[^/]+/)*%s"), NRKTVIE__EPISODE_RE)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_EPISODE_RE": NRKTVIE__EPISODE_RE,
				"_VALID_URL":  NRKTVIE__VALID_URL,
			})
		}())
		NRKTVEpisodeIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVEpisodeIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NRKTVEpisodeIE__VALID_URL λ.Object
			)
			NRKTVEpisodeIE__VALID_URL = λ.StrLiteral("https?://tv\\.nrk\\.no/serie/(?P<id>[^/]+/sesong/(?P<season_number>\\d+)/episode/(?P<episode_number>\\d+))")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKTVEpisodeIE__VALID_URL,
			})
		}())
		NRKTVSerieBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVSerieBaseIE"), λ.NewTuple(NRKBaseIE), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		NRKTVSeasonIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVSeasonIE"), λ.NewTuple(NRKTVSerieBaseIE), func() λ.Dict {
			var (
				NRKTVSeasonIE__VALID_URL λ.Object
				NRKTVSeasonIE_suitable   λ.Object
			)
			NRKTVSeasonIE__VALID_URL = λ.StrLiteral("(?x)\n                    https?://\n                        (?P<domain>tv|radio)\\.nrk\\.no/\n                        (?P<serie_kind>serie|pod[ck]ast)/\n                        (?P<serie>[^/]+)/\n                        (?:\n                            (?:sesong/)?(?P<id>\\d+)|\n                            sesong/(?P<id_2>[^/?#&]+)\n                        )\n                    ")
			NRKTVSeasonIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(func() λ.Object {
							if λv := λ.Calm(NRKTVIE, "suitable", ϒurl); λ.IsTrue(λv) {
								return λv
							} else if λv := λ.Calm(NRKTVEpisodeIE, "suitable", ϒurl); λ.IsTrue(λv) {
								return λv
							} else {
								return λ.Calm(NRKRadioPodkastIE, "suitable", ϒurl)
							}
						}()) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, NRKTVSeasonIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			NRKTVSeasonIE_suitable = λ.Cal(λ.ClassMethodType, NRKTVSeasonIE_suitable)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKTVSeasonIE__VALID_URL,
				"suitable":   NRKTVSeasonIE_suitable,
			})
		}())
		NRKTVSeriesIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVSeriesIE"), λ.NewTuple(NRKTVSerieBaseIE), func() λ.Dict {
			var (
				NRKTVSeriesIE__VALID_URL λ.Object
				NRKTVSeriesIE_suitable   λ.Object
			)
			NRKTVSeriesIE__VALID_URL = λ.StrLiteral("https?://(?P<domain>(?:tv|radio)\\.nrk|(?:tv\\.)?nrksuper)\\.no/(?P<serie_kind>serie|pod[ck]ast)/(?P<id>[^/]+)")
			NRKTVSeriesIE_suitable = λ.NewFunction("suitable",
				[]λ.Param{
					{Name: "cls"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcls = λargs[0]
						ϒurl = λargs[1]
					)
					return func() λ.Object {
						if λ.IsTrue(λ.Cal(λ.BuiltinAny, λ.Cal(λ.NewFunction("<generator>",
							nil,
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								return λ.NewGenerator(func(λgy λ.Yielder) λ.Object {
									var (
										ϒie  λ.Object
										τmp0 λ.Object
										τmp1 λ.Object
									)
									τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
										NRKTVIE,
										NRKTVEpisodeIE,
										NRKRadioPodkastIE,
										NRKTVSeasonIE,
									))
									for {
										if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
											break
										}
										ϒie = τmp1
										λgy.Yield(λ.Calm(ϒie, "suitable", ϒurl))
									}
									return λ.None
								})
							})))) {
							return λ.False
						} else {
							return λ.Calm(λ.Cal(λ.SuperType, NRKTVSeriesIE, ϒcls), "suitable", ϒurl)
						}
					}()
				})
			NRKTVSeriesIE_suitable = λ.Cal(λ.ClassMethodType, NRKTVSeriesIE_suitable)
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKTVSeriesIE__VALID_URL,
				"suitable":   NRKTVSeriesIE_suitable,
			})
		}())
		NRKTVDirekteIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVDirekteIE"), λ.NewTuple(NRKTVIE), func() λ.Dict {
			var (
				NRKTVDirekteIE__VALID_URL λ.Object
			)
			NRKTVDirekteIE__VALID_URL = λ.StrLiteral("https?://(?:tv|radio)\\.nrk\\.no/direkte/(?P<id>[^/?#&]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKTVDirekteIE__VALID_URL,
			})
		}())
		NRKRadioPodkastIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKRadioPodkastIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NRKRadioPodkastIE__VALID_URL    λ.Object
				NRKRadioPodkastIE__real_extract λ.Object
			)
			NRKRadioPodkastIE__VALID_URL = λ.StrLiteral("https?://radio\\.nrk\\.no/pod[ck]ast/(?:[^/]+/)+(?P<id>l_[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12})")
			NRKRadioPodkastIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself     = λargs[0]
						ϒurl      = λargs[1]
						ϒvideo_id λ.Object
					)
					ϒvideo_id = λ.Calm(ϒself, "_match_id", ϒurl)
					return λ.Call(λ.GetAttr(ϒself, "url_result", nil), λ.NewArgs(λ.Mod(λ.StrLiteral("nrk:%s"), ϒvideo_id)), λ.KWArgs{
						{Name: "ie", Value: λ.Calm(NRKIE, "ie_key")},
						{Name: "video_id", Value: ϒvideo_id},
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL":    NRKRadioPodkastIE__VALID_URL,
				"_real_extract": NRKRadioPodkastIE__real_extract,
			})
		}())
		NRKPlaylistBaseIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKPlaylistBaseIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {

			return λ.ClassDictLiteral(map[λ.Object]λ.Object{})
		}())
		NRKPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKPlaylistIE"), λ.NewTuple(NRKPlaylistBaseIE), func() λ.Dict {
			var (
				NRKPlaylistIE__VALID_URL λ.Object
			)
			NRKPlaylistIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?nrk\\.no/(?!video|skole)(?:[^/]+/)+(?P<id>[^/]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKPlaylistIE__VALID_URL,
			})
		}())
		NRKTVEpisodesIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKTVEpisodesIE"), λ.NewTuple(NRKPlaylistBaseIE), func() λ.Dict {
			var (
				NRKTVEpisodesIE__VALID_URL λ.Object
			)
			NRKTVEpisodesIE__VALID_URL = λ.StrLiteral("https?://tv\\.nrk\\.no/program/[Ee]pisodes/[^/]+/(?P<id>\\d+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKTVEpisodesIE__VALID_URL,
			})
		}())
		NRKSkoleIE = λ.Cal(λ.TypeType, λ.StrLiteral("NRKSkoleIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NRKSkoleIE__VALID_URL λ.Object
			)
			NRKSkoleIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?nrk\\.no/skole/?\\?.*\\bmediaId=(?P<id>\\d+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NRKSkoleIE__VALID_URL,
			})
		}())
	})
}
