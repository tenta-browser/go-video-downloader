// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * newgrounds/module.go: transpiled from https://github.com/ytdl-org/youtube-dl/blob/master/youtube_dl/extractor/newgrounds.py
 */

package newgrounds

import (
	Ωcommon "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/extractor/common"
	Ωutils "github.com/tenta-browser/go-video-downloader/gen/youtube_dl/utils"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	InfoExtractor        λ.Object
	NewgroundsIE         λ.Object
	NewgroundsPlaylistIE λ.Object
	ϒextract_attributes  λ.Object
	ϒint_or_none         λ.Object
	ϒparse_duration      λ.Object
	ϒparse_filesize      λ.Object
	ϒunified_timestamp   λ.Object
)

func init() {
	λ.InitModule(func() {
		InfoExtractor = Ωcommon.InfoExtractor
		ϒextract_attributes = Ωutils.ϒextract_attributes
		ϒint_or_none = Ωutils.ϒint_or_none
		ϒparse_duration = Ωutils.ϒparse_duration
		ϒparse_filesize = Ωutils.ϒparse_filesize
		ϒunified_timestamp = Ωutils.ϒunified_timestamp
		NewgroundsIE = λ.Cal(λ.TypeType, λ.StrLiteral("NewgroundsIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NewgroundsIE__VALID_URL    λ.Object
				NewgroundsIE__real_extract λ.Object
			)
			NewgroundsIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?newgrounds\\.com/(?:audio/listen|portal/view)/(?P<id>[0-9]+)")
			NewgroundsIE__real_extract = λ.NewFunction("_real_extract",
				[]λ.Param{
					{Name: "self"},
					{Name: "url"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒduration        λ.Object
						ϒfilesize_approx λ.Object
						ϒformats         λ.Object
						ϒmax_resolution  λ.Object
						ϒmedia_id        λ.Object
						ϒmedia_url       λ.Object
						ϒresolution      λ.Object
						ϒself            = λargs[0]
						ϒtimestamp       λ.Object
						ϒtitle           λ.Object
						ϒuploader        λ.Object
						ϒurl             = λargs[1]
						ϒurl_base        λ.Object
						ϒwebpage         λ.Object
						τmp0             λ.Object
						τmp1             λ.Object
					)
					ϒmedia_id = λ.Calm(ϒself, "_match_id", ϒurl)
					ϒwebpage = λ.Calm(ϒself, "_download_webpage", ϒurl, ϒmedia_id)
					ϒtitle = λ.Calm(ϒself, "_html_search_regex", λ.StrLiteral("<title>([^>]+)</title>"), ϒwebpage, λ.StrLiteral("title"))
					ϒmedia_url = λ.Calm(ϒself, "_parse_json", λ.Calm(ϒself, "_search_regex", λ.StrLiteral("\"url\"\\s*:\\s*(\"[^\"]+\"),"), ϒwebpage, λ.StrLiteral("")), ϒmedia_id)
					ϒformats = λ.NewList(λ.DictLiteral(map[string]λ.Object{
						"url":       ϒmedia_url,
						"format_id": λ.StrLiteral("source"),
						"quality":   λ.IntLiteral(1),
					}))
					ϒmax_resolution = λ.Cal(ϒint_or_none, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("max_resolution[\"\\']\\s*:\\s*(\\d+)"),
						ϒwebpage,
						λ.StrLiteral("max resolution"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					}))
					if λ.IsTrue(ϒmax_resolution) {
						ϒurl_base = λ.GetItem(λ.Calm(ϒmedia_url, "rpartition", λ.StrLiteral(".")), λ.IntLiteral(0))
						τmp0 = λ.Cal(λ.BuiltinIter, λ.NewTuple(
							λ.IntLiteral(360),
							λ.IntLiteral(720),
							λ.IntLiteral(1080),
						))
						for {
							if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
								break
							}
							ϒresolution = τmp1
							if λ.IsTrue(λ.Gt(ϒresolution, ϒmax_resolution)) {
								break
							}
							λ.Calm(ϒformats, "append", λ.DictLiteral(map[string]λ.Object{
								"url": λ.Mod(λ.StrLiteral("%s.%dp.mp4"), λ.NewTuple(
									ϒurl_base,
									ϒresolution,
								)),
								"format_id": λ.Mod(λ.StrLiteral("%dp"), ϒresolution),
								"height":    ϒresolution,
							}))
						}
					}
					λ.Calm(ϒself, "_check_formats", ϒformats, ϒmedia_id)
					λ.Calm(ϒself, "_sort_formats", ϒformats)
					ϒuploader = λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.NewTuple(
							λ.StrLiteral("(?s)<h4[^>]*>(.+?)</h4>.*?<em>\\s*Author\\s*</em>"),
							λ.StrLiteral("(?:Author|Writer)\\s*<a[^>]+>([^<]+)"),
						),
						ϒwebpage,
						λ.StrLiteral("uploader"),
					), λ.KWArgs{
						{Name: "fatal", Value: λ.False},
					})
					ϒtimestamp = λ.Cal(ϒunified_timestamp, λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.NewTuple(
							λ.StrLiteral("<dt>\\s*Uploaded\\s*</dt>\\s*<dd>([^<]+</dd>\\s*<dd>[^<]+)"),
							λ.StrLiteral("<dt>\\s*Uploaded\\s*</dt>\\s*<dd>([^<]+)"),
						),
						ϒwebpage,
						λ.StrLiteral("timestamp"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					}))
					ϒduration = λ.Cal(ϒparse_duration, λ.Call(λ.GetAttr(ϒself, "_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?s)<dd>\\s*Song\\s*</dd>\\s*<dd>.+?</dd>\\s*<dd>([^<]+)"),
						ϒwebpage,
						λ.StrLiteral("duration"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					}))
					ϒfilesize_approx = λ.Cal(ϒparse_filesize, λ.Call(λ.GetAttr(ϒself, "_html_search_regex", nil), λ.NewArgs(
						λ.StrLiteral("(?s)<dd>\\s*Song\\s*</dd>\\s*<dd>(.+?)</dd>"),
						ϒwebpage,
						λ.StrLiteral("filesize"),
					), λ.KWArgs{
						{Name: "default", Value: λ.None},
					}))
					if λ.IsTrue(λ.Eq(λ.Cal(λ.BuiltinLen, ϒformats), λ.IntLiteral(1))) {
						λ.SetItem(λ.GetItem(ϒformats, λ.IntLiteral(0)), λ.StrLiteral("filesize_approx"), ϒfilesize_approx)
					}
					if λ.Contains(ϒwebpage, λ.StrLiteral("<dd>Song")) {
						λ.SetItem(λ.GetItem(ϒformats, λ.IntLiteral(0)), λ.StrLiteral("vcodec"), λ.StrLiteral("none"))
					}
					return λ.DictLiteral(map[string]λ.Object{
						"id":        ϒmedia_id,
						"title":     ϒtitle,
						"uploader":  ϒuploader,
						"timestamp": ϒtimestamp,
						"duration":  ϒduration,
						"formats":   ϒformats,
					})
				})
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL":    NewgroundsIE__VALID_URL,
				"_real_extract": NewgroundsIE__real_extract,
			})
		}())
		NewgroundsPlaylistIE = λ.Cal(λ.TypeType, λ.StrLiteral("NewgroundsPlaylistIE"), λ.NewTuple(InfoExtractor), func() λ.Dict {
			var (
				NewgroundsPlaylistIE__VALID_URL λ.Object
			)
			NewgroundsPlaylistIE__VALID_URL = λ.StrLiteral("https?://(?:www\\.)?newgrounds\\.com/(?:collection|[^/]+/search/[^/]+)/(?P<id>[^/?#&]+)")
			return λ.ClassDictLiteral(map[string]λ.Object{
				"_VALID_URL": NewgroundsPlaylistIE__VALID_URL,
			})
		}())
	})
}
