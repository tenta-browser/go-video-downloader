// Code generated by transpiler. DO NOT EDIT.

/**
 * Go Video Downloader
 *
 *    Copyright 2019 Tenta, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * For any questions, please contact developer@tenta.io
 *
 * re/module.go: transpiled from re.py
 */

package re

import (
	Ωre "github.com/tenta-browser/go-video-downloader/lib/re"
	λ "github.com/tenta-browser/go-video-downloader/runtime"
)

var (
	DOTALL        λ.Object
	MULTILINE     λ.Object
	Match         λ.Object
	MatchIterator λ.Object
	Pattern       λ.Object
	VERBOSE       λ.Object
	ϒcompile      λ.Object
	ϒescape       λ.Object
	ϒfindall      λ.Object
	ϒfinditer     λ.Object
	ϒmatch        λ.Object
	ϒsearch       λ.Object
	ϒsub          λ.Object
	τmp0          λ.Object
)

func init() {
	λ.InitModule(func() {
		τmp0 = Ωre.FlagIgnoreCase

		τmp0 = Ωre.FlagMultiline
		MULTILINE = τmp0

		τmp0 = Ωre.FlagDotAll
		DOTALL = τmp0

		τmp0 = Ωre.FlagUnicode

		τmp0 = Ωre.FlagVerbose
		VERBOSE = τmp0

		Match = λ.Cal(λ.TypeType, λ.NewStr("Match"), λ.NewTuple(), func() λ.Dict {
			var (
				Match___init__  λ.Object
				Match_group     λ.Object
				Match_groupdict λ.Object
				Match_groups    λ.Object
			)
			Match___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "m"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒm       = λargs[2]
						ϒpattern = λargs[1]
						ϒself    = λargs[0]
					)
					λ.SetAttr(ϒself, "pattern", ϒpattern)
					λ.SetAttr(ϒself, "m", ϒm)
					λ.SetAttr(ϒself, "st", λ.GetAttr(ϒpattern, "st", nil))
					return λ.None
				})
			Match_group = λ.NewFunction("group",
				[]λ.Param{
					{Name: "self"},
				},
				0, true, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒgroup  λ.Object
						ϒgroups = λargs[1]
						ϒl      λ.Object
						ϒself   = λargs[0]
						ϒvals   λ.Object
						τmp0    λ.Object
						τmp1    λ.Object
					)
					ϒl = λ.Cal(λ.BuiltinLen, ϒgroups)
					if λ.IsTrue(λ.Eq(ϒl, λ.NewInt(0))) {
						return λ.Cal(Ωre.Group, λ.GetAttr(ϒself, "m", nil), λ.GetAttr(ϒself, "st", nil), λ.NewInt(0), λ.None)
					} else {
						if λ.IsTrue(λ.Eq(ϒl, λ.NewInt(1))) {
							return λ.Cal(Ωre.Group, λ.GetAttr(ϒself, "m", nil), λ.GetAttr(ϒself, "st", nil), λ.GetItem(ϒgroups, λ.NewInt(0)), λ.None)
						} else {
							ϒvals = λ.NewList()
							τmp0 = λ.Cal(λ.BuiltinIter, ϒgroups)
							for {
								if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
									break
								}
								ϒgroup = τmp1
								λ.Cal(λ.GetAttr(ϒvals, "append", nil), λ.Cal(Ωre.Group, λ.GetAttr(ϒself, "m", nil), λ.GetAttr(ϒself, "st", nil), ϒgroup, λ.None))
							}
							return λ.Cal(λ.TupleType, ϒvals)
						}
					}
					return λ.None
				})
			Match_groups = λ.NewFunction("groups",
				[]λ.Param{
					{Name: "self"},
					{Name: "default", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcnt     λ.Object
						ϒdefault = λargs[1]
						ϒi       λ.Object
						ϒself    = λargs[0]
						ϒvals    λ.Object
						τmp0     λ.Object
					)
					ϒvals = λ.NewList()
					ϒcnt = λ.Cal(Ωre.Groups, λ.GetAttr(ϒself, "m", nil))
					ϒi = λ.NewInt(1)
					for λ.IsTrue(λ.Le(ϒi, ϒcnt)) {
						λ.Cal(λ.GetAttr(ϒvals, "append", nil), λ.Cal(Ωre.Group, λ.GetAttr(ϒself, "m", nil), λ.GetAttr(ϒself, "st", nil), ϒi, ϒdefault))
						τmp0 = λ.IAdd(ϒi, λ.NewInt(1))
						ϒi = τmp0
					}
					return λ.Cal(λ.TupleType, ϒvals)
				})
			Match_groupdict = λ.NewFunction("groupdict",
				[]λ.Param{
					{Name: "self"},
					{Name: "default", Def: λ.None},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒd       λ.Object
						ϒdefault = λargs[1]
						ϒgroup   λ.Object
						ϒself    = λargs[0]
						τmp0     λ.Object
						τmp1     λ.Object
					)
					ϒd = λ.NewDictWithTable(map[λ.Object]λ.Object{})
					τmp0 = λ.Cal(λ.BuiltinIter, λ.Cal(Ωre.GroupNames, λ.GetAttr(λ.GetAttr(ϒself, "pattern", nil), "r", nil)))
					for {
						if τmp1 = λ.NextDefault(τmp0, λ.AfterLast); τmp1 == λ.AfterLast {
							break
						}
						ϒgroup = τmp1
						λ.SetItem(ϒd, ϒgroup, λ.Cal(Ωre.Group, λ.GetAttr(ϒself, "m", nil), λ.GetAttr(ϒself, "st", nil), ϒgroup, ϒdefault))
					}
					return ϒd
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"):  Match___init__,
				λ.NewStr("group"):     Match_group,
				λ.NewStr("groupdict"): Match_groupdict,
				λ.NewStr("groups"):    Match_groups,
			})
		}())
		MatchIterator = λ.Cal(λ.TypeType, λ.NewStr("MatchIterator"), λ.NewTuple(), func() λ.Dict {
			var (
				MatchIterator___init__ λ.Object
				MatchIterator___iter__ λ.Object
				MatchIterator___next__ λ.Object
			)
			MatchIterator___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "pattern"},
					{Name: "m"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒm       = λargs[2]
						ϒpattern = λargs[1]
						ϒself    = λargs[0]
					)
					λ.SetAttr(ϒself, "pattern", ϒpattern)
					λ.SetAttr(ϒself, "m", ϒm)
					λ.SetAttr(ϒself, "first", λ.True)
					return λ.None
				})
			MatchIterator___iter__ = λ.NewFunction("__iter__",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					return ϒself
				})
			MatchIterator___next__ = λ.NewFunction("__next__",
				[]λ.Param{
					{Name: "self"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself = λargs[0]
					)
					if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.GetAttr(ϒself, "m", nil)))) {
						panic(λ.Raise(λ.StopIterationType))
					}
					if λ.IsTrue(λ.GetAttr(ϒself, "first", nil)) {
						λ.SetAttr(ϒself, "first", λ.False)
					} else {
						if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(Ωre.Next, λ.GetAttr(ϒself, "m", nil))))) {
							λ.SetAttr(ϒself, "m", λ.None)
							panic(λ.Raise(λ.StopIterationType))
						}
					}
					return λ.Cal(Match, λ.GetAttr(ϒself, "pattern", nil), λ.GetAttr(ϒself, "m", nil))
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"): MatchIterator___init__,
				λ.NewStr("__iter__"): MatchIterator___iter__,
				λ.NewStr("__next__"): MatchIterator___next__,
			})
		}())
		Pattern = λ.Cal(λ.TypeType, λ.NewStr("Pattern"), λ.NewTuple(), func() λ.Dict {
			var (
				Pattern___init__ λ.Object
				Pattern__search  λ.Object
				Pattern_findall  λ.Object
				Pattern_finditer λ.Object
				Pattern_match    λ.Object
				Pattern_search   λ.Object
				Pattern_sub      λ.Object
			)
			Pattern___init__ = λ.NewFunction("__init__",
				[]λ.Param{
					{Name: "self"},
					{Name: "r"},
					{Name: "p"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒp    = λargs[2]
						ϒr    = λargs[1]
						ϒself = λargs[0]
					)
					λ.SetAttr(ϒself, "r", ϒr)
					λ.SetAttr(ϒself, "p", ϒp)
					λ.SetAttr(ϒself, "st", λ.Cal(λ.BuiltinIsInstance, ϒr, λ.StrType))
					return λ.None
				})
			Pattern_search = λ.NewFunction("search",
				[]λ.Param{
					{Name: "self"},
					{Name: "string"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself   = λargs[0]
						ϒstring = λargs[1]
					)
					return λ.Cal(λ.GetAttr(ϒself, "_search", nil), ϒstring, λ.False)
				})
			Pattern_match = λ.NewFunction("match",
				[]λ.Param{
					{Name: "self"},
					{Name: "string"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒself   = λargs[0]
						ϒstring = λargs[1]
					)
					return λ.Cal(λ.GetAttr(ϒself, "_search", nil), ϒstring, λ.True)
				})
			Pattern__search = λ.NewFunction("_search",
				[]λ.Param{
					{Name: "self"},
					{Name: "string"},
					{Name: "anchor_start"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒanchor_start = λargs[2]
						ϒm            λ.Object
						ϒself         = λargs[0]
						ϒstring       = λargs[1]
					)
					ϒm = λ.Cal(Ωre.Search, λ.GetAttr(ϒself, "p", nil), ϒstring, ϒanchor_start)
					if λ.IsTrue(λ.NewBool(ϒm == λ.None)) {
						return λ.None
					}
					return λ.Cal(Match, ϒself, ϒm)
				})
			Pattern_findall = λ.NewFunction("findall",
				[]λ.Param{
					{Name: "self"},
					{Name: "string"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒgcnt   λ.Object
						ϒgvals  λ.Object
						ϒi      λ.Object
						ϒm      λ.Object
						ϒself   = λargs[0]
						ϒstring = λargs[1]
						ϒval    λ.Object
						ϒvals   λ.Object
						τmp0    λ.Object
					)
					ϒm = λ.Cal(Ωre.Search, λ.GetAttr(ϒself, "p", nil), ϒstring)
					ϒvals = λ.NewList()
					if λ.IsTrue(ϒm) {
						ϒgcnt = λ.Cal(Ωre.Groups, ϒm)
						for λ.IsTrue(λ.True) {
							if λ.IsTrue(λ.Eq(ϒgcnt, λ.NewInt(0))) {
								ϒval = λ.Cal(Ωre.Group, ϒm, λ.GetAttr(ϒself, "st", nil), λ.NewInt(0), λ.NewStr(""))
							} else {
								if λ.IsTrue(λ.Eq(ϒgcnt, λ.NewInt(1))) {
									ϒval = λ.Cal(Ωre.Group, ϒm, λ.GetAttr(ϒself, "st", nil), λ.NewInt(1), λ.NewStr(""))
								} else {
									ϒgvals = λ.NewList()
									ϒi = λ.NewInt(1)
									for λ.IsTrue(λ.Le(ϒi, ϒgcnt)) {
										λ.Cal(λ.GetAttr(ϒgvals, "append", nil), λ.Cal(Ωre.Group, ϒm, λ.GetAttr(ϒself, "st", nil), ϒi, λ.NewStr("")))
										τmp0 = λ.IAdd(ϒi, λ.NewInt(1))
										ϒi = τmp0
									}
									ϒval = λ.Cal(λ.TupleType, ϒgvals)
								}
							}
							λ.Cal(λ.GetAttr(ϒvals, "append", nil), ϒval)
							if λ.IsTrue(λ.NewBool(!λ.IsTrue(λ.Cal(Ωre.Next, ϒm)))) {
								break
							}
						}
					}
					return ϒvals
				})
			Pattern_finditer = λ.NewFunction("finditer",
				[]λ.Param{
					{Name: "self"},
					{Name: "string"},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒm      λ.Object
						ϒself   = λargs[0]
						ϒstring = λargs[1]
					)
					ϒm = λ.Cal(Ωre.Search, λ.GetAttr(ϒself, "p", nil), ϒstring)
					return λ.Cal(MatchIterator, ϒself, ϒm)
				})
			Pattern_sub = λ.NewFunction("sub",
				[]λ.Param{
					{Name: "self"},
					{Name: "repl"},
					{Name: "string"},
					{Name: "count", Def: λ.NewInt(0)},
				},
				0, false, false,
				func(λargs []λ.Object) λ.Object {
					var (
						ϒcount  = λargs[3]
						ϒrepl   = λargs[1]
						ϒself   = λargs[0]
						ϒstring = λargs[2]
					)
					if λ.IsTrue(ϒcount) {
						panic(λ.Raise(λ.Cal(λ.NotImplementedErrorType, λ.NewStr("Non-zero count in re.sub"))))
					}
					if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒrepl, λ.StrType)) {
						return λ.Cal(Ωre.Replace, λ.GetAttr(ϒself, "p", nil), ϒrepl, ϒstring)
					} else {
						return λ.Cal(Ωre.ReplaceFunc, λ.GetAttr(ϒself, "p", nil), λ.NewFunction("<lambda>",
							[]λ.Param{
								{Name: "m"},
							},
							0, false, false,
							func(λargs []λ.Object) λ.Object {
								var (
									ϒm = λargs[0]
								)
								return λ.Cal(ϒrepl, λ.Cal(Match, ϒself, ϒm))
							}), ϒstring)
					}
					return λ.None
				})
			return λ.NewDictWithTable(map[λ.Object]λ.Object{
				λ.NewStr("__init__"): Pattern___init__,
				λ.NewStr("_search"):  Pattern__search,
				λ.NewStr("findall"):  Pattern_findall,
				λ.NewStr("finditer"): Pattern_finditer,
				λ.NewStr("match"):    Pattern_match,
				λ.NewStr("search"):   Pattern_search,
				λ.NewStr("sub"):      Pattern_sub,
			})
		}())
		ϒcompile = λ.NewFunction("compile",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒflags   = λargs[1]
					ϒpattern = λargs[0]
				)
				if λ.IsTrue(λ.Cal(λ.BuiltinIsInstance, ϒpattern, Pattern)) {
					return ϒpattern
				}
				return λ.Cal(Pattern, ϒpattern, λ.Cal(Ωre.Compile, ϒpattern, ϒflags))
			})
		ϒsearch = λ.NewFunction("search",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "string"},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒflags   = λargs[2]
					ϒpattern = λargs[0]
					ϒstring  = λargs[1]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(ϒcompile, ϒpattern, ϒflags), "search", nil), ϒstring)
			})
		ϒmatch = λ.NewFunction("match",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "string"},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒflags   = λargs[2]
					ϒpattern = λargs[0]
					ϒstring  = λargs[1]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(ϒcompile, ϒpattern, ϒflags), "match", nil), ϒstring)
			})
		ϒfindall = λ.NewFunction("findall",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "string"},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒflags   = λargs[2]
					ϒpattern = λargs[0]
					ϒstring  = λargs[1]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(ϒcompile, ϒpattern, ϒflags), "findall", nil), ϒstring)
			})
		ϒfinditer = λ.NewFunction("finditer",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "string"},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒflags   = λargs[2]
					ϒpattern = λargs[0]
					ϒstring  = λargs[1]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(ϒcompile, ϒpattern, ϒflags), "finditer", nil), ϒstring)
			})
		ϒsub = λ.NewFunction("sub",
			[]λ.Param{
				{Name: "pattern"},
				{Name: "repl"},
				{Name: "string"},
				{Name: "count", Def: λ.NewInt(0)},
				{Name: "flags", Def: λ.NewInt(0)},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒcount   = λargs[3]
					ϒflags   = λargs[4]
					ϒpattern = λargs[0]
					ϒrepl    = λargs[1]
					ϒstring  = λargs[2]
				)
				return λ.Cal(λ.GetAttr(λ.Cal(ϒcompile, ϒpattern, ϒflags), "sub", nil), ϒrepl, ϒstring, ϒcount)
			})
		ϒescape = λ.NewFunction("escape",
			[]λ.Param{
				{Name: "pattern"},
			},
			0, false, false,
			func(λargs []λ.Object) λ.Object {
				var (
					ϒpattern = λargs[0]
				)
				return λ.Cal(Ωre.Escape, ϒpattern)
			})
	})
}
